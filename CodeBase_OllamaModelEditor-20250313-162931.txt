This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
  workflows/
    ci.yml
  PULL_REQUEST_TEMPLATE.md
Core/
  ConfigManager.py
  DatabaseSchema.sql
  DBManager.py
  LoggingUtils.py
  ModelManager.py
  ModelManagerExtensions.py
  ParameterStateManager.py
CurrentMods/
  old/
    OllamaModelEditor Implementation Plan.md
  Benchmark Methodology Documentation.md
  BenchmarkView.py
  Main.py
  mainwindow-update.py
  OllamaModelEditor Implementation Updates.md
  ParameterEditor.py
  ParameterStateManager.py
  StateManager Integration Guide.md
docs/
  Notes/
    Additional Features from Original Design and Brainstorming.md
    AIDEV-PascalCase Implementation Plan.md
    ConfigManager Update for PascalCase DB Schema.md
    Database Migration to PascalCase Standard.md
    implementation-plan.md
    OllamaModelEditor - Database Integration Guide.md
    OllamaModelEditor - Project Status and Roadmap.md
    OllamaModelEditor Database Integration Guide.md
    OllamaModelEditor UI and Feature Implementation Plan.md
  parameter-editor.py
  ProjectStructure.txt
GUI/
  Components/
    __init__.py
    BenchmarkView.py
    ModelSelector.py
    ParameterEditor.py
  Windows/
    MainWindow.py
    SplashScreen.py
scripts/
  GithubUpdate.sh
  MigrateDBToPascalCase.py
  MigrateToDatabase.py
  rename_report.py
  Setup.bat
  Setup.sh
  SimpleGitHubSetup.sh
  UpdateGitHub.sh
Tests/
  UnitTests/
    TestConfigManager.py
 test_pyside.py
.gitignore
LICENSE
Main.py
README.md
rename_report.sh
requirements.txt
SimpleTest.py

================================================================
Files
================================================================

================
File: .github/ISSUE_TEMPLATE/bug_report.md
================
---
name: Bug report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '...'
3. Scroll down to '...'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Environment:**
 - OS: [e.g. Windows, macOS, Linux]
 - Python Version: [e.g. 3.8, 3.9]
 - Application Version: [e.g. 1.0.0]

**Additional context**
Add any other context about the problem here.

================
File: .github/ISSUE_TEMPLATE/feature_request.md
================
---
name: Feature request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is.

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

================
File: .github/workflows/ci.yml
================
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Run tests
      run: |
        pytest

================
File: .github/PULL_REQUEST_TEMPLATE.md
================
## Description
<!-- Provide a brief description of the changes in this PR -->

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Documentation update
- [ ] Code refactoring
- [ ] Other (please describe):

## Testing Performed
<!-- Describe the testing done to verify your changes -->

## Checklist
- [ ] My code follows the AIDEV-PascalCase standards of this project
- [ ] I have performed a self-review of my own code
- [ ] I have added tests that prove my fix is effective or that my feature works
- [ ] New and existing unit tests pass locally with my changes
- [ ] I have updated the documentation accordingly

================
File: Core/ConfigManager.py
================
# File: ConfigManager.py
# Path: OllamaModelEditor/Core/ConfigManager.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-13
# Description: Configuration management for the OllamaModelEditor application

import os
import json
import yaml
from pathlib import Path
from typing import Dict, Any, Optional, Union, List
import logging

# Import DBManager if available
try:
    from Core.DBManager import DBManager
except ImportError:
    DBManager = None

class ConfigManager:
    """Manages application configuration settings and model parameters."""
    
    def __init__(self, ConfigPath: Optional[str] = None, DB: Optional['DBManager'] = None):
        """
        Initialize the configuration manager.
        
        Args:
            ConfigPath: Optional path to configuration file
            DB: Optional database manager instance
        """
        self.Logger = logging.getLogger('OllamaModelEditor.ConfigManager')
        self.ConfigPath = ConfigPath
        self.DB = DB
        self.AppConfig = {}
        self.ModelConfigs = {}
        self.UserPreferences = {}
        
        # Set default configuration path if not provided
        if not self.ConfigPath:
            self.ConfigPath = self._GetDefaultConfigPath()
    
    def _GetDefaultConfigPath(self) -> str:
        """
        Determine the default configuration path based on the operating system.
        
        Returns:
            str: Path to the default configuration directory
        """
        # Get user's home directory
        HomeDir = Path.home()
        
        # Determine configuration directory based on platform
        if os.name == 'nt':  # Windows
            ConfigDir = HomeDir / 'AppData' / 'Local' / 'OllamaModelEditor'
        else:  # macOS and Linux
            ConfigDir = HomeDir / '.config' / 'OllamaModelEditor'
        
        # Create directory if it doesn't exist
        ConfigDir.mkdir(parents=True, exist_ok=True)
        
        return str(ConfigDir / 'Config.yaml')
    
    def _SerializeQtObjects(self, Config: Dict) -> Dict:
        """
        Convert Qt objects to serializable format.
        
        Args:
            Config: Configuration dictionary
            
        Returns:
            Dictionary with serialized Qt objects
        """
        SerializedConfig = {}
        
        for Key, Value in Config.items():
            if hasattr(Value, '__class__') and Value.__class__.__module__.startswith('PySide6'):
                # Handle QByteArray
                if Value.__class__.__name__ == 'QByteArray':
                    SerializedConfig[Key] = {'__qt_type__': 'QByteArray', 'data': bytes(Value).hex()}
                # Handle QSize
                elif Value.__class__.__name__ == 'QSize':
                    SerializedConfig[Key] = {'__qt_type__': 'QSize', 'width': Value.width(), 'height': Value.height()}
                # Handle QRect
                elif Value.__class__.__name__ == 'QRect':
                    SerializedConfig[Key] = {
                        '__qt_type__': 'QRect', 
                        'x': Value.x(), 
                        'y': Value.y(),
                        'width': Value.width(), 
                        'height': Value.height()
                    }
                # Handle QPoint
                elif Value.__class__.__name__ == 'QPoint':
                    SerializedConfig[Key] = {'__qt_type__': 'QPoint', 'x': Value.x(), 'y': Value.y()}
                # Other Qt objects - store class name and basic representation
                else:
                    SerializedConfig[Key] = {
                        '__qt_type__': Value.__class__.__name__,
                        'repr': repr(Value)
                    }
            elif isinstance(Value, dict):
                SerializedConfig[Key] = self._SerializeQtObjects(Value)
            else:
                SerializedConfig[Key] = Value
                
        return SerializedConfig
    
    def _DeserializeQtObjects(self, Config: Dict) -> Dict:
        """
        Convert serialized Qt objects back to their original form.
        
        Args:
            Config: Configuration dictionary with serialized Qt objects
            
        Returns:
            Dictionary with deserialized Qt objects
        """
        from PySide6.QtCore import QByteArray, QSize, QRect, QPoint
        
        DeserializedConfig = {}
        
        for Key, Value in Config.items():
            if isinstance(Value, dict) and '__qt_type__' in Value:
                # Reconstruct Qt objects based on type
                QtType = Value['__qt_type__']
                
                if QtType == 'QByteArray':
                    DeserializedConfig[Key] = QByteArray.fromHex(bytes.fromhex(Value['data']))
                elif QtType == 'QSize':
                    DeserializedConfig[Key] = QSize(Value['width'], Value['height'])
                elif QtType == 'QRect':
                    DeserializedConfig[Key] = QRect(Value['x'], Value['y'], Value['width'], Value['height'])
                elif QtType == 'QPoint':
                    DeserializedConfig[Key] = QPoint(Value['x'], Value['y'])
                else:
                    # For other Qt objects, we can't fully reconstruct them
                    # So we'll keep them as dictionaries with their type information
                    DeserializedConfig[Key] = Value
            elif isinstance(Value, dict):
                DeserializedConfig[Key] = self._DeserializeQtObjects(Value)
            else:
                DeserializedConfig[Key] = Value
                
        return DeserializedConfig
    
    def LoadConfig(self) -> bool:
        """
        Load configuration from file.
        
        Returns:
            bool: True if configuration loaded successfully, False otherwise
        """
        # If using database, populate from there
        if self.DB:
            try:
                # Load app config from database
                self._LoadAppConfigFromDB()
                
                # Load user preferences from database
                self._LoadUserPreferencesFromDB()
                
                # Load model configs from database
                self._LoadModelConfigsFromDB()
                
                self.Logger.info("Configuration loaded from database")
                return True
            
            except Exception as Error:
                self.Logger.error(f"Error loading configuration from database: {Error}")
                # Fall back to file-based configuration
        
        # File-based configuration loading
        try:
            ConfigPath = Path(self.ConfigPath)
            
            # Create default configuration if file doesn't exist
            if not ConfigPath.exists():
                self._CreateDefaultConfig()
                return True
            
            # Load configuration based on file extension
            if ConfigPath.suffix.lower() == '.json':
                with open(ConfigPath, 'r') as ConfigFile:
                    ConfigData = json.load(ConfigFile)
            elif ConfigPath.suffix.lower() in ['.yaml', '.yml']:
                with open(ConfigPath, 'r') as ConfigFile:
                    ConfigData = yaml.safe_load(ConfigFile)
            else:
                self.Logger.error(f"Unsupported configuration file format: {ConfigPath.suffix}")
                return False
            
            # Parse configuration sections
            if 'AppConfig' in ConfigData:
                self.AppConfig = self._DeserializeQtObjects(ConfigData.get('AppConfig', {}))
            
            if 'ModelConfigs' in ConfigData:
                self.ModelConfigs = self._DeserializeQtObjects(ConfigData.get('ModelConfigs', {}))
            
            if 'UserPreferences' in ConfigData:
                self.UserPreferences = self._DeserializeQtObjects(ConfigData.get('UserPreferences', {}))
            
            self.Logger.info(f"Configuration loaded from file: {ConfigPath}")
            return True
            
        except Exception as Error:
            self.Logger.error(f"Error loading configuration: {Error}")
            # Create default configuration on error
            self._CreateDefaultConfig()
            return False
    
    def _LoadAppConfigFromDB(self) -> None:
        """Load application configuration from database."""
        # Get all app settings
        Settings = self.DB.ExecuteQuery(
            "SELECT Key, Value, ValueType FROM AppSettings"
        )
        
        # Clear existing app config
        self.AppConfig = {}
        
        # Convert settings to appropriate types and add to AppConfig
        for Key, Value, ValueType in Settings:
            if ValueType == "int":
                self.AppConfig[Key] = int(Value)
            elif ValueType == "float":
                self.AppConfig[Key] = float(Value)
            elif ValueType == "bool":
                self.AppConfig[Key] = Value.lower() in ("true", "1", "yes")
            elif ValueType == "json":
                self.AppConfig[Key] = json.loads(Value)
            else:
                self.AppConfig[Key] = Value
    
    def _LoadUserPreferencesFromDB(self) -> None:
        """Load user preferences from database."""
        # Get all user preferences
        Preferences = self.DB.ExecuteQuery(
            "SELECT Key, Value, ValueType FROM UserPreferences"
        )
        
        # Clear existing preferences
        self.UserPreferences = {}
        
        # Convert preferences to appropriate types and add to UserPreferences
        for Key, Value, ValueType in Preferences:
            if ValueType == "int":
                self.UserPreferences[Key] = int(Value)
            elif ValueType == "float":
                self.UserPreferences[Key] = float(Value)
            elif ValueType == "bool":
                self.UserPreferences[Key] = Value.lower() in ("true", "1", "yes")
            elif ValueType == "json":
                self.UserPreferences[Key] = json.loads(Value)
            else:
                self.UserPreferences[Key] = Value
    
    def _LoadModelConfigsFromDB(self) -> None:
        """Load model configurations from database."""
        # Get all model configurations
        ModelConfigs = self.DB.ExecuteQuery(
            """
            SELECT ModelName, ConfigName, Temperature, TopP, MaxTokens,
                   FrequencyPenalty, PresencePenalty
            FROM ModelConfigs
            """
        )
        
        # Clear existing model configs
        self.ModelConfigs = {}
        
        # Group configurations by model
        for ModelName, ConfigName, Temperature, TopP, MaxTokens, FrequencyPenalty, PresencePenalty in ModelConfigs:
            # Create model entry if it doesn't exist
            if ModelName not in self.ModelConfigs:
                self.ModelConfigs[ModelName] = {}
            
            # Add configuration
            self.ModelConfigs[ModelName][ConfigName] = {
                'Temperature': Temperature,
                'TopP': TopP,
                'MaxTokens': MaxTokens,
                'FrequencyPenalty': FrequencyPenalty,
                'PresencePenalty': PresencePenalty
            }
    
    def SaveConfig(self) -> bool:
        """
        Save current configuration to file or database.
        
        Returns:
            bool: True if configuration saved successfully, False otherwise
        """
        # If using database, save there
        if self.DB:
            try:
                # Save app config to database
                for Key, Value in self.AppConfig.items():
                    self.DB.SetAppSetting(Key, Value)
                
                # Save user preferences to database
                for Key, Value in self.UserPreferences.items():
                    self.DB.SetUserPreference(Key, Value)
                
                # Save model configs to database (handled by ModelManager)
                # We don't save model configs here to avoid overwriting changes
                
                self.Logger.info("Configuration saved to database")
                return True
            
            except Exception as Error:
                self.Logger.error(f"Error saving configuration to database: {Error}")
                # Fall back to file-based saving
        
        # File-based configuration saving
        try:
            ConfigPath = Path(self.ConfigPath)
            
            # Prepare configuration data
            ConfigData = {
                'AppConfig': self._SerializeQtObjects(self.AppConfig),
                'ModelConfigs': self._SerializeQtObjects(self.ModelConfigs),
                'UserPreferences': self._SerializeQtObjects(self.UserPreferences)
            }
            
            # Create directory if it doesn't exist
            ConfigPath.parent.mkdir(parents=True, exist_ok=True)
            
            # Save configuration based on file extension
            if ConfigPath.suffix.lower() == '.json':
                with open(ConfigPath, 'w') as ConfigFile:
                    json.dump(ConfigData, ConfigFile, indent=2)
            elif ConfigPath.suffix.lower() in ['.yaml', '.yml']:
                with open(ConfigPath, 'w') as ConfigFile:
                    yaml.dump(ConfigData, ConfigFile, default_flow_style=False)
            else:
                self.Logger.error(f"Unsupported configuration file format: {ConfigPath.suffix}")
                return False
            
            self.Logger.info(f"Configuration saved to file: {ConfigPath}")
            return True
            
        except Exception as Error:
            self.Logger.error(f"Error saving configuration: {Error}")
            return False
    
    def _CreateDefaultConfig(self) -> None:
        """Create default configuration settings."""
        # Default application configuration
        self.AppConfig = {
            'Version': '1.0.0',
            'APIEndpoint': 'http://localhost:11434/api',
            'LogLevel': 'INFO',
            'MaxConcurrentRequests': 3,
            'Theme': 'system'
        }
        
        # Default model configurations
        self.ModelConfigs = {
            'DefaultParameters': {
                'Temperature': 0.7,
                'TopP': 0.9,
                'MaxTokens': 2048,
                'FrequencyPenalty': 0.0,
                'PresencePenalty': 0.0
            }
        }
        
        # Default user preferences
        self.UserPreferences = {
            'UIFontSize': 12,
            'EditorFontFamily': 'Consolas, Menlo, monospace',
            'ShowWelcomeOnStartup': True,
            'AutoSaveInterval': 300,  # seconds
            'RecentModels': []
        }
        
        # Save default configuration
        if self.DB:
            # Save to database
            for Key, Value in self.AppConfig.items():
                self.DB.SetAppSetting(Key, Value)
            
            for Key, Value in self.UserPreferences.items():
                self.DB.SetUserPreference(Key, Value)
            
            # Save default parameters
            DefaultParams = self.ModelConfigs['DefaultParameters']
            self.DB.SaveModelConfig('DefaultParameters', 'Default', DefaultParams)
            
            self.Logger.info("Default configuration created and saved to database")
        else:
            # Save to file
            self.SaveConfig()
            self.Logger.info("Default configuration created and saved to file")
    
    def GetAppConfig(self, Key: Optional[str] = None, Default: Any = None) -> Any:
        """
        Get application configuration.
        
        Args:
            Key: Optional configuration key to retrieve
            Default: Default value if key not found
            
        Returns:
            Configuration value or entire configuration dictionary
        """
        if self.DB and Key:
            # Try to get from database first
            Value = self.DB.GetAppSetting(Key, None)
            if Value is not None:
                return Value
        
        # Fall back to memory cache
        if Key:
            return self.AppConfig.get(Key, Default)
        return self.AppConfig
    
    def SetAppConfig(self, Key: str, Value: Any) -> None:
        """
        Set application configuration.
        
        Args:
            Key: Configuration key to set
            Value: Configuration value
        """
        self.AppConfig[Key] = Value
        
        # Save to database if available
        if self.DB:
            self.DB.SetAppSetting(Key, Value)
    
    def GetModelConfig(self, ModelName: str) -> Dict[str, Any]:
        """
        Get configuration for a specific model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dict: Model configuration
        """
        if self.DB:
            # Try to get from database first
            Config = self.DB.GetModelConfig(ModelName)
            if Config:
                return {
                    'Temperature': Config['Temperature'],
                    'TopP': Config['TopP'],
                    'MaxTokens': Config['MaxTokens'],
                    'FrequencyPenalty': Config['FrequencyPenalty'],
                    'PresencePenalty': Config['PresencePenalty']
                }
        
        # Fall back to memory cache
        return self.ModelConfigs.get(ModelName, self.ModelConfigs.get('DefaultParameters', {}))
    
    def SetModelConfig(self, ModelName: str, Config: Dict[str, Any]) -> None:
        """
        Set configuration for a specific model.
        
        Args:
            ModelName: Name of the model
            Config: Model configuration
        """
        self.ModelConfigs[ModelName] = Config
        
        # Save to database if available
        if self.DB:
            self.DB.SaveModelConfig(ModelName, 'Default', Config)
    
    def GetUserPreference(self, Key: str, Default: Any = None) -> Any:
        """
        Get user preference.
        
        Args:
            Key: Preference key
            Default: Default value if preference not found
            
        Returns:
            User preference value
        """
        if self.DB:
            # Try to get from database first
            Value = self.DB.GetUserPreference(Key, None)
            if Value is not None:
                return Value
        
        # Fall back to memory cache
        return self.UserPreferences.get(Key, Default)
    
    def SetUserPreference(self, Key: str, Value: Any) -> None:
        """
        Set user preference.
        
        Args:
            Key: Preference key
            Value: Preference value
        """
        self.UserPreferences[Key] = Value
        
        # Save to database if available
        if self.DB:
            self.DB.SetUserPreference(Key, Value)
    
    def AddRecentModel(self, ModelName: str) -> None:
        """
        Add model to recent models list.
        
        Args:
            ModelName: Name of the model
        """
        # Get current recent models list
        RecentModels = self.GetUserPreference('RecentModels', [])
        
        # Remove model if it already exists in the list
        if ModelName in RecentModels:
            RecentModels.remove(ModelName)
        
        # Add model to the beginning of the list
        RecentModels.insert(0, ModelName)
        
        # Keep only the 10 most recent models
        RecentModels = RecentModels[:10]
        
        # Update preference
        self.SetUserPreference('RecentModels', RecentModels)
    
    def ExportModelConfig(self, ModelName: str, FilePath: str) -> bool:
        """
        Export model configuration to a file.
        
        Args:
            ModelName: Name of the model
            FilePath: Path to save the configuration
            
        Returns:
            bool: True if export successful, False otherwise
        """
        try:
            # Get model configuration
            ModelConfig = self.GetModelConfig(ModelName)
            
            if not ModelConfig:
                self.Logger.error(f"No configuration found for model: {ModelName}")
                return False
            
            # Ensure export directory exists
            Path(FilePath).parent.mkdir(parents=True, exist_ok=True)
            
            # Export based on file extension
            FileExt = Path(FilePath).suffix.lower()
            
            if FileExt == '.json':
                with open(FilePath, 'w') as ExportFile:
                    json.dump(ModelConfig, ExportFile, indent=2)
            elif FileExt in ['.yaml', '.yml']:
                with open(FilePath, 'w') as ExportFile:
                    yaml.dump(ModelConfig, ExportFile, default_flow_style=False)
            else:
                self.Logger.error(f"Unsupported export format: {FileExt}")
                return False
            
            self.Logger.info(f"Model configuration exported to: {FilePath}")
            return True
            
        except Exception as Error:
            self.Logger.error(f"Error exporting model configuration: {Error}")
            return False
    
    def ImportModelConfig(self, ModelName: str, FilePath: str) -> bool:
        """
        Import model configuration from a file.
        
        Args:
            ModelName: Name of the model
            FilePath: Path to the configuration file
            
        Returns:
            bool: True if import successful, False otherwise
        """
        try:
            # Check if file exists
            ConfigFile = Path(FilePath)
            if not ConfigFile.exists():
                self.Logger.error(f"Configuration file not found: {FilePath}")
                return False
            
            # Import based on file extension
            FileExt = ConfigFile.suffix.lower()
            
            if FileExt == '.json':
                with open(FilePath, 'r') as ImportFile:
                    ModelConfig = json.load(ImportFile)
            elif FileExt in ['.yaml', '.yml']:
                with open(FilePath, 'r') as ImportFile:
                    ModelConfig = yaml.safe_load(ImportFile)
            else:
                self.Logger.error(f"Unsupported import format: {FileExt}")
                return False
            
            # Validate imported configuration
            if not self._ValidateModelConfig(ModelConfig):
                self.Logger.error("Invalid model configuration format")
                return False
            
            # Set model configuration
            self.SetModelConfig(ModelName, ModelConfig)
            
            # Add to recent models
            self.AddRecentModel(ModelName)
            
            self.Logger.info(f"Model configuration imported from: {FilePath}")
            return True
            
        except Exception as Error:
            self.Logger.error(f"Error importing model configuration: {Error}")
            return False
    
    def _ValidateModelConfig(self, Config: Dict[str, Any]) -> bool:
        """
        Validate model configuration format.
        
        Args:
            Config: Model configuration to validate
            
        Returns:
            bool: True if configuration is valid, False otherwise
        """
        # Required parameters for valid model configuration
        RequiredParams = ['Temperature', 'TopP', 'MaxTokens']
        
        # Check if all required parameters exist
        for Param in RequiredParams:
            if Param not in Config:
                self.Logger.error(f"Missing required parameter: {Param}")
                return False
        
        # Validate parameter types and ranges
        if not isinstance(Config.get('Temperature'), (int, float)) or not 0 <= Config.get('Temperature') <= 2:
            self.Logger.error("Temperature must be a number between 0 and 2")
            return False
        
        if not isinstance(Config.get('TopP'), (int, float)) or not 0 <= Config.get('TopP') <= 1:
            self.Logger.error("TopP must be a number between 0 and 1")
            return False
        
        if not isinstance(Config.get('MaxTokens'), int) or Config.get('MaxTokens') <= 0:
            self.Logger.error("MaxTokens must be a positive integer")
            return False
        
        return True
    
    def MigrateToDatabase(self, DB: 'DBManager') -> bool:
        """
        Migrate file-based configuration to database.
        
        Args:
            DB: Database manager instance
            
        Returns:
            bool: True if migration successful, False otherwise
        """
        if not DB:
            self.Logger.error("No database manager provided")
            return False
        
        try:
            # Make sure configuration is loaded
            self.LoadConfig()
            
            # Set database reference
            self.DB = DB
            
            # Migrate application settings
            self.Logger.info("Migrating application settings...")
            for Key, Value in self.AppConfig.items():
                DB.SetAppSetting(Key, Value)
            
            # Migrate user preferences
            self.Logger.info("Migrating user preferences...")
            for Key, Value in self.UserPreferences.items():
                DB.SetUserPreference(Key, Value)
            
            # Migrate model configurations
            self.Logger.info("Migrating model configurations...")
            for ModelName, ModelConfig in self.ModelConfigs.items():
                if isinstance(ModelConfig, dict) and not isinstance(list(ModelConfig.values())[0], dict):
                    # This is a single configuration (not a dict of configs)
                    DB.SaveModelConfig(ModelName, "Default", ModelConfig)
                else:
                    # This is a dict of configurations
                    for ConfigName, ConfigParams in ModelConfig.items():
                        DB.SaveModelConfig(ModelName, ConfigName, ConfigParams)
            
            self.Logger.info("Migration to database completed successfully")
            return True
            
        except Exception as Error:
            self.Logger.error(f"Error migrating to database: {Error}")
            return False

================
File: Core/DatabaseSchema.sql
================
-- File: DatabaseSchema.sql
-- Path: OllamaModelEditor/Core/DatabaseSchema.sql
-- Standard: AIDEV-PascalCase-1.2
-- Created: 2025-03-12
-- Last Modified: 2025-03-12 08:45PM
-- Description: SQL schema for the OllamaModelEditor database

-- Database version
CREATE TABLE IF NOT EXISTS DBVersion (
    Version INTEGER PRIMARY KEY,
    AppliedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Model configurations
CREATE TABLE IF NOT EXISTS ModelConfigs (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    ModelName TEXT NOT NULL,
    ConfigName TEXT NOT NULL,
    Temperature REAL DEFAULT 0.7,
    TopP REAL DEFAULT 0.9,
    MaxTokens INTEGER DEFAULT 2048,
    FrequencyPenalty REAL DEFAULT 0.0,
    PresencePenalty REAL DEFAULT 0.0,
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    LastUsed TIMESTAMP,
    IsDefault BOOLEAN DEFAULT 0,
    UNIQUE(ModelName, ConfigName)
);

-- Preset configurations
CREATE TABLE IF NOT EXISTS Presets (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    Name TEXT UNIQUE NOT NULL,
    Description TEXT,
    Temperature REAL DEFAULT 0.7,
    TopP REAL DEFAULT 0.9,
    MaxTokens INTEGER DEFAULT 2048,
    FrequencyPenalty REAL DEFAULT 0.0,
    PresencePenalty REAL DEFAULT 0.0,
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    LastUsed TIMESTAMP
);

-- User-defined presets
CREATE TABLE IF NOT EXISTS UserPresets (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    Name TEXT UNIQUE NOT NULL,
    Description TEXT,
    Temperature REAL DEFAULT 0.7,
    TopP REAL DEFAULT 0.9,
    MaxTokens INTEGER DEFAULT 2048,
    FrequencyPenalty REAL DEFAULT 0.0,
    PresencePenalty REAL DEFAULT 0.0,
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    LastUsed TIMESTAMP
);

-- User preferences
CREATE TABLE IF NOT EXISTS UserPreferences (
    Key TEXT PRIMARY KEY,
    Value TEXT,
    ValueType TEXT,  -- For type conversion: "string", "int", "float", "bool", "json"
    UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Application settings
CREATE TABLE IF NOT EXISTS AppSettings (
    Key TEXT PRIMARY KEY,
    Value TEXT,
    ValueType TEXT,  -- For type conversion
    Description TEXT,
    UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Parameter definitions and descriptions
CREATE TABLE IF NOT EXISTS Parameters (
    Name TEXT PRIMARY KEY,
    DisplayName TEXT NOT NULL,
    Description TEXT,
    MinValue REAL,
    MaxValue REAL,
    DefaultValue REAL,
    StepSize REAL,
    IsInteger BOOLEAN DEFAULT 0,
    Category TEXT,  -- e.g., "basic", "advanced"
    OrderIndex INTEGER  -- For display ordering
);

-- Generation history
CREATE TABLE IF NOT EXISTS GenerationHistory (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    ModelName TEXT NOT NULL,
    Prompt TEXT NOT NULL,
    Response TEXT,
    Temperature REAL,
    TopP REAL,
    MaxTokens INTEGER,
    FrequencyPenalty REAL,
    PresencePenalty REAL,
    InputTokens INTEGER,
    OutputTokens INTEGER,
    TotalTokens INTEGER,
    GenerationTime REAL,  -- in seconds
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Benchmark results
CREATE TABLE IF NOT EXISTS BenchmarkResults (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    BenchmarkName TEXT,
    ModelName TEXT NOT NULL,
    ConfigID INTEGER,
    Prompt TEXT,
    AverageTime REAL,  -- Average generation time in seconds
    AverageTokens INTEGER,
    AverageTokensPerSecond REAL,
    Runs INTEGER,  -- Number of benchmark runs
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(ConfigID) REFERENCES ModelConfigs(ID)
);

-- Messages for UI elements
CREATE TABLE IF NOT EXISTS UIMessages (
    Key TEXT PRIMARY KEY,
    Message TEXT NOT NULL,
    Context TEXT,  -- e.g., "error", "info", "tooltip"
    UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- UI strings for internationalization
CREATE TABLE IF NOT EXISTS UIStrings (
    Key TEXT PRIMARY KEY,
    EnText TEXT NOT NULL,  -- English text
    Description TEXT,
    Context TEXT   -- Where this string is used
);

================
File: Core/DBManager.py
================
# File: DBManager.py
# Path: OllamaModelEditor/Core/DBManager.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-12
# Last Modified: 2025-03-12 08:30PM
# Description: Database management for the OllamaModelEditor application

import os
import sqlite3
import json
import time
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple
import logging

class DBManager:
    """Manages the SQLite database for OllamaModelEditor."""
    
    def __init__(self, DBPath: Optional[str] = None):
        """
        Initialize the database manager.
        
        Args:
            DBPath: Optional path to database file
        """
        self.Logger = logging.getLogger('OllamaModelEditor.DBManager')
        
        # Set default database path if not provided
        if not DBPath:
            self.DBPath = self._GetDefaultDBPath()
        else:
            self.DBPath = DBPath
        
        # Ensure directory exists
        os.makedirs(os.path.dirname(self.DBPath), exist_ok=True)
        
        # Initialize database
        self._InitializeDB()
    
    def _GetDefaultDBPath(self) -> str:
        """
        Determine the default database path based on the operating system.
        
        Returns:
            str: Path to the default database file
        """
        # Get user's home directory
        HomeDir = Path.home()
        
        # Determine configuration directory based on platform
        if os.name == 'nt':  # Windows
            ConfigDir = HomeDir / 'AppData' / 'Local' / 'OllamaModelEditor'
        else:  # macOS and Linux
            ConfigDir = HomeDir / '.config' / 'OllamaModelEditor'
        
        # Create directory if it doesn't exist
        ConfigDir.mkdir(parents=True, exist_ok=True)
        
        return str(ConfigDir / 'OllamaModelEditor.db')
    
    def _InitializeDB(self) -> None:
        """Initialize the database with required tables and default data."""
        try:
            # Create schema definition
            Schema = """
            -- Database version
            CREATE TABLE IF NOT EXISTS DBVersion (
                Version INTEGER PRIMARY KEY,
                AppliedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- Model configurations
            CREATE TABLE IF NOT EXISTS ModelConfigs (
                ID INTEGER PRIMARY KEY AUTOINCREMENT,
                ModelName TEXT NOT NULL,
                ConfigName TEXT NOT NULL,
                Temperature REAL DEFAULT 0.7,
                TopP REAL DEFAULT 0.9,
                MaxTokens INTEGER DEFAULT 2048,
                FrequencyPenalty REAL DEFAULT 0.0,
                PresencePenalty REAL DEFAULT 0.0,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                LastUsed TIMESTAMP,
                IsDefault BOOLEAN DEFAULT 0,
                UNIQUE(ModelName, ConfigName)
            );

            -- Preset configurations
            CREATE TABLE IF NOT EXISTS Presets (
                ID INTEGER PRIMARY KEY AUTOINCREMENT,
                Name TEXT UNIQUE NOT NULL,
                Description TEXT,
                Temperature REAL DEFAULT 0.7,
                TopP REAL DEFAULT 0.9,
                MaxTokens INTEGER DEFAULT 2048,
                FrequencyPenalty REAL DEFAULT 0.0,
                PresencePenalty REAL DEFAULT 0.0,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                LastUsed TIMESTAMP
            );
            
            -- User-defined presets
            CREATE TABLE IF NOT EXISTS UserPresets (
                ID INTEGER PRIMARY KEY AUTOINCREMENT,
                Name TEXT UNIQUE NOT NULL,
                Description TEXT,
                Temperature REAL DEFAULT 0.7,
                TopP REAL DEFAULT 0.9,
                MaxTokens INTEGER DEFAULT 2048,
                FrequencyPenalty REAL DEFAULT 0.0,
                PresencePenalty REAL DEFAULT 0.0,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                LastUsed TIMESTAMP
            );
            
            -- User preferences
            CREATE TABLE IF NOT EXISTS UserPreferences (
                Key TEXT PRIMARY KEY,
                Value TEXT,
                ValueType TEXT,
                UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- Application settings
            CREATE TABLE IF NOT EXISTS AppSettings (
                Key TEXT PRIMARY KEY,
                Value TEXT,
                ValueType TEXT,
                Description TEXT,
                UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- Parameter definitions and descriptions
            CREATE TABLE IF NOT EXISTS Parameters (
                Name TEXT PRIMARY KEY,
                DisplayName TEXT NOT NULL,
                Description TEXT,
                MinValue REAL,
                MaxValue REAL,
                DefaultValue REAL,
                StepSize REAL,
                IsInteger BOOLEAN DEFAULT 0,
                Category TEXT,
                OrderIndex INTEGER
            );
            
            -- Generation history
            CREATE TABLE IF NOT EXISTS GenerationHistory (
                ID INTEGER PRIMARY KEY AUTOINCREMENT,
                ModelName TEXT NOT NULL,
                Prompt TEXT NOT NULL,
                Response TEXT,
                Temperature REAL,
                TopP REAL,
                MaxTokens INTEGER,
                FrequencyPenalty REAL,
                PresencePenalty REAL,
                InputTokens INTEGER,
                OutputTokens INTEGER,
                TotalTokens INTEGER,
                GenerationTime REAL,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- Benchmark results
            CREATE TABLE IF NOT EXISTS BenchmarkResults (
                ID INTEGER PRIMARY KEY AUTOINCREMENT,
                BenchmarkName TEXT,
                ModelName TEXT NOT NULL,
                ConfigID INTEGER,
                Prompt TEXT,
                AverageTime REAL,
                AverageTokens INTEGER,
                AverageTokensPerSecond REAL,
                Runs INTEGER,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(ConfigID) REFERENCES ModelConfigs(ID)
            );
            
            -- Messages for UI elements
            CREATE TABLE IF NOT EXISTS UIMessages (
                Key TEXT PRIMARY KEY,
                Message TEXT NOT NULL,
                Context TEXT,
                UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- UI strings for internationalization
            CREATE TABLE IF NOT EXISTS UIStrings (
                Key TEXT PRIMARY KEY,
                EnText TEXT NOT NULL,
                Description TEXT,
                Context TEXT
            );
            """
            
            # Connect to database
            with sqlite3.connect(self.DBPath) as Conn:
                Cursor = Conn.cursor()
                
                # Execute schema script
                Cursor.executescript(Schema)
                
                # Check current database version
                Cursor.execute("SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='DBVersion'")
                if Cursor.fetchone()[0] > 0:
                    Cursor.execute("SELECT MAX(Version) FROM DBVersion")
                    Result = Cursor.fetchone()
                    CurrentVersion = Result[0] if Result[0] is not None else 0
                else:
                    CurrentVersion = 0
                
                # Set initial version if it doesn't exist
                if CurrentVersion == 0:
                    Cursor.execute("INSERT INTO DBVersion (Version) VALUES (1)")
                    CurrentVersion = 1
                
                # Check if presets need to be initialized
                Cursor.execute("SELECT COUNT(*) FROM Presets")
                PresetCount = Cursor.fetchone()[0]
                
                if PresetCount == 0:
                    self._InitializePresets(Cursor)
                
                # Check if parameters need to be initialized
                Cursor.execute("SELECT COUNT(*) FROM Parameters")
                ParameterCount = Cursor.fetchone()[0]
                
                if ParameterCount == 0:
                    self._InitializeParameters(Cursor)
                
                # Check if UI strings need to be initialized
                Cursor.execute("SELECT COUNT(*) FROM UIStrings")
                UIStringCount = Cursor.fetchone()[0]
                
                if UIStringCount == 0:
                    self._InitializeUIStrings(Cursor)
                
                Conn.commit()
                
            self.Logger.info(f"Database initialized: {self.DBPath}")
                
        except sqlite3.Error as Error:
            self.Logger.error(f"Error initializing database: {Error}")
            raise
    
    def _InitializePresets(self, Cursor) -> None:
        """
        Initialize default presets.
        
        Args:
            Cursor: Database cursor
        """
        Presets = [
            (
                "Default", 
                "Balanced settings suitable for most tasks.", 
                0.7, 0.9, 2048, 0.0, 0.0
            ),
            (
                "Creative", 
                "Higher temperature and diversity for more creative, varied outputs.", 
                1.0, 0.95, 4096, 0.0, 0.0
            ),
            (
                "Precise", 
                "Lower temperature for more focused, deterministic responses.", 
                0.3, 0.7, 2048, 0.5, 0.0
            ),
            (
                "Fast", 
                "Optimized for speed with shorter outputs.", 
                0.7, 0.9, 1024, 0.0, 0.0
            ),
            (
                "Balanced", 
                "Moderate settings with some repetition control for well-rounded responses.", 
                0.6, 0.85, 2048, 0.3, 0.3
            ),
            (
                "Deterministic", 
                "Minimal randomness for highly predictable, consistent outputs.", 
                0.0, 0.5, 2048, 0.0, 0.0
            )
        ]
        
        Cursor.executemany(
            """
            INSERT INTO Presets (Name, Description, Temperature, TopP, MaxTokens, 
                               FrequencyPenalty, PresencePenalty)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """, 
            Presets
        )
    
    def _InitializeParameters(self, Cursor) -> None:
        """
        Initialize parameter definitions.
        
        Args:
            Cursor: Database cursor
        """
        Parameters = [
            (
                "Temperature", "Temperature", 
                "Controls randomness in text generation. Higher values (0.7-1.0) produce more creative outputs, while lower values (0.2-0.5) make output more focused and deterministic.",
                0.0, 2.0, 0.7, 0.1, 0, "basic", 1
            ),
            (
                "TopP", "Top-P",
                "Controls diversity via nucleus sampling. Lower values make output more focused on likely tokens. 0.9 is a good starting point.",
                0.0, 1.0, 0.9, 0.01, 0, "basic", 2
            ),
            (
                "MaxTokens", "Max Tokens",
                "The maximum length of the generated text. Higher values allow for longer responses but consume more resources.",
                1, 32000, 2048, 1, 1, "basic", 3
            ),
            (
                "FrequencyPenalty", "Frequency Penalty",
                "Reduces repetition by penalizing tokens that have already appeared in the text. Higher values (0.5-1.0) strongly discourage repetition.",
                0.0, 2.0, 0.0, 0.1, 0, "advanced", 4
            ),
            (
                "PresencePenalty", "Presence Penalty",
                "Penalizes tokens that have appeared at all, encouraging the model to discuss new topics. Useful for keeping responses diverse.",
                0.0, 2.0, 0.0, 0.1, 0, "advanced", 5
            )
        ]
        
        Cursor.executemany(
            """
            INSERT INTO Parameters (Name, DisplayName, Description, MinValue, MaxValue, 
                                 DefaultValue, StepSize, IsInteger, Category, OrderIndex)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, 
            Parameters
        )
    
    def _InitializeUIStrings(self, Cursor) -> None:
        """
        Initialize UI strings.
        
        Args:
            Cursor: Database cursor
        """
        # Example UI strings initialization
        UIStrings = [
            ("app.title", "Ollama Model Editor", "Main window title", "window"),
            ("menu.file", "File", "File menu", "menu"),
            ("menu.edit", "Edit", "Edit menu", "menu"),
            ("menu.view", "View", "View menu", "menu"),
            ("menu.tools", "Tools", "Tools menu", "menu"),
            ("menu.help", "Help", "Help menu", "menu"),
            ("button.apply", "Apply Changes", "Apply button", "button"),
            ("button.reset", "Reset to Default", "Reset button", "button"),
            ("error.no_model", "Please select a model first.", "Error message", "error"),
            ("label.parameter_editor", "Parameter Editor", "Tab label", "tab"),
            ("label.benchmark", "Benchmark", "Tab label", "tab"),
            ("label.analysis", "Analysis", "Tab label", "tab"),
            ("label.temperature", "Temperature:", "Parameter label", "parameter"),
            ("label.top_p", "Top-P:", "Parameter label", "parameter"),
            ("label.max_tokens", "Max Tokens:", "Parameter label", "parameter"),
            ("label.frequency_penalty", "Frequency Penalty:", "Parameter label", "parameter"),
            ("label.presence_penalty", "Presence Penalty:", "Parameter label", "parameter"),
            ("label.model_library", "Model Library", "Dock title", "dock"),
            ("label.presets", "Preset:", "Presets label", "parameter"),
            ("label.available_models", "Available Models:", "Model list label", "label"),
            ("status.loading_models", "Loading models...", "Status message", "status"),
            ("status.models_loaded", "Loaded {0} models", "Status message", "status"),
            ("status.model_selected", "Model {0} selected", "Status message", "status"),
            ("status.api_connected", "API: Connected", "Status message", "status"),
            ("status.api_error", "API: Error", "Status message", "status"),
            ("status.no_connection", "API: Not connected", "Status message", "status")
        ]
        
        Cursor.executemany(
            """
            INSERT INTO UIStrings (Key, EnText, Description, Context)
            VALUES (?, ?, ?, ?)
            """, 
            UIStrings
        )
    
    def GetConnection(self) -> sqlite3.Connection:
        """
        Get a database connection.
        
        Returns:
            sqlite3.Connection: Database connection
        """
        return sqlite3.connect(self.DBPath)
    
    def ExecuteQuery(self, Query: str, Params: tuple = ()) -> List[tuple]:
        """
        Execute a query and return results.
        
        Args:
            Query: SQL query
            Params: Query parameters
            
        Returns:
            List of result tuples
        """
        try:
            with self.GetConnection() as Conn:
                Cursor = Conn.cursor()
                Cursor.execute(Query, Params)
                return Cursor.fetchall()
        except sqlite3.Error as Error:
            self.Logger.error(f"Error executing query: {Error}")
            self.Logger.debug(f"Query: {Query}, Params: {Params}")
            raise
    
    def ExecuteNonQuery(self, Query: str, Params: tuple = ()) -> int:
        """
        Execute a non-query statement.
        
        Args:
            Query: SQL statement
            Params: Statement parameters
            
        Returns:
            Row count or last row ID
        """
        try:
            with self.GetConnection() as Conn:
                Cursor = Conn.cursor()
                Cursor.execute(Query, Params)
                Conn.commit()
                return Cursor.lastrowid or Cursor.rowcount
        except sqlite3.Error as Error:
            self.Logger.error(f"Error executing non-query: {Error}")
            self.Logger.debug(f"Query: {Query}, Params: {Params}")
            raise
    
    # Model Configuration Methods
    
    def GetModelConfigs(self, ModelName: str) -> List[Dict[str, Any]]:
        """
        Get all configurations for a model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            List of configuration dictionaries
        """
        Results = self.ExecuteQuery(
            "SELECT * FROM ModelConfigs WHERE ModelName = ?",
            (ModelName,)
        )
        
        Columns = [
            "ID", "ModelName", "ConfigName", "Temperature", "TopP", 
            "MaxTokens", "FrequencyPenalty", "PresencePenalty", 
            "CreatedAt", "LastUsed", "IsDefault"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def GetModelConfig(self, ModelName: str, ConfigName: str = "Default") -> Optional[Dict[str, Any]]:
        """
        Get a specific configuration for a model.
        
        Args:
            ModelName: Name of the model
            ConfigName: Name of the configuration
            
        Returns:
            Configuration dictionary or None if not found
        """
        Results = self.ExecuteQuery(
            "SELECT * FROM ModelConfigs WHERE ModelName = ? AND ConfigName = ?",
            (ModelName, ConfigName)
        )
        
        if not Results:
            return None
        
        Columns = [
            "ID", "ModelName", "ConfigName", "Temperature", "TopP", 
            "MaxTokens", "FrequencyPenalty", "PresencePenalty", 
            "CreatedAt", "LastUsed", "IsDefault"
        ]
        
        return dict(zip(Columns, Results[0]))
    
    def SaveModelConfig(self, ModelName: str, ConfigName: str, Params: Dict[str, Any]) -> int:
        """
        Save a model configuration.
        
        Args:
            ModelName: Name of the model
            ConfigName: Name of the configuration
            Params: Configuration parameters
            
        Returns:
            Row ID of the saved configuration
        """
        # Check if configuration exists
        ExistingConfig = self.GetModelConfig(ModelName, ConfigName)
        
        if ExistingConfig:
            # Update existing configuration
            Query = """
            UPDATE ModelConfigs
            SET Temperature = ?, TopP = ?, MaxTokens = ?, 
                FrequencyPenalty = ?, PresencePenalty = ?,
                LastUsed = CURRENT_TIMESTAMP
            WHERE ModelName = ? AND ConfigName = ?
            """
            
            self.ExecuteNonQuery(
                Query,
                (
                    Params.get('Temperature', 0.7),
                    Params.get('TopP', 0.9),
                    Params.get('MaxTokens', 2048),
                    Params.get('FrequencyPenalty', 0.0),
                    Params.get('PresencePenalty', 0.0),
                    ModelName,
                    ConfigName
                )
            )
            
            return ExistingConfig["ID"]
        else:
            # Insert new configuration
            Query = """
            INSERT INTO ModelConfigs
            (ModelName, ConfigName, Temperature, TopP, MaxTokens, 
             FrequencyPenalty, PresencePenalty)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """
            
            return self.ExecuteNonQuery(
                Query,
                (
                    ModelName,
                    ConfigName,
                    Params.get('Temperature', 0.7),
                    Params.get('TopP', 0.9),
                    Params.get('MaxTokens', 2048),
                    Params.get('FrequencyPenalty', 0.0),
                    Params.get('PresencePenalty', 0.0)
                )
            )
    
    def DeleteModelConfig(self, ModelName: str, ConfigName: str) -> bool:
        """
        Delete a model configuration.
        
        Args:
            ModelName: Name of the model
            ConfigName: Name of the configuration
            
        Returns:
            True if deleted, False if not found
        """
        Result = self.ExecuteNonQuery(
            "DELETE FROM ModelConfigs WHERE ModelName = ? AND ConfigName = ?",
            (ModelName, ConfigName)
        )
        
        return Result > 0
    
    # Preset Methods
    
    def GetPresets(self) -> List[Dict[str, Any]]:
        """
        Get all preset configurations.
        
        Returns:
            List of preset dictionaries
        """
        Results = self.ExecuteQuery("SELECT * FROM Presets ORDER BY Name")
        
        Columns = [
            "ID", "Name", "Description", "Temperature", "TopP", 
            "MaxTokens", "FrequencyPenalty", "PresencePenalty", 
            "CreatedAt", "LastUsed"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def GetPreset(self, PresetName: str) -> Optional[Dict[str, Any]]:
        """
        Get a specific preset configuration.
        
        Args:
            PresetName: Name of the preset
            
        Returns:
            Preset dictionary or None if not found
        """
        Results = self.ExecuteQuery(
            "SELECT * FROM Presets WHERE Name = ?",
            (PresetName,)
        )
        
        if not Results:
            return None
        
        Columns = [
            "ID", "Name", "Description", "Temperature", "TopP", 
            "MaxTokens", "FrequencyPenalty", "PresencePenalty", 
            "CreatedAt", "LastUsed"
        ]
        
        return dict(zip(Columns, Results[0]))
    
    def UpdatePresetUsage(self, PresetName: str) -> bool:
        """
        Update the LastUsed timestamp for a preset.
        
        Args:
            PresetName: Name of the preset
            
        Returns:
            True if updated, False if not found
        """
        Result = self.ExecuteNonQuery(
            "UPDATE Presets SET LastUsed = CURRENT_TIMESTAMP WHERE Name = ?",
            (PresetName,)
        )
        
        return Result > 0
    
    # User-defined Preset Methods
    
    def GetUserPresets(self) -> List[Dict[str, Any]]:
        """
        Get all user-defined presets.
        
        Returns:
            List of user preset dictionaries
        """
        Results = self.ExecuteQuery("SELECT * FROM UserPresets ORDER BY Name")
        
        Columns = [
            "ID", "Name", "Description", "Temperature", "TopP", 
            "MaxTokens", "FrequencyPenalty", "PresencePenalty", 
            "CreatedAt", "LastUsed"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def SaveUserPreset(self, PresetName: str, Description: str, Params: Dict[str, Any]) -> int:
        """
        Save a user-defined preset.
        
        Args:
            PresetName: Name of the preset
            Description: Preset description
            Params: Preset parameters
            
        Returns:
            Row ID of the saved preset
        """
        # Check if preset exists
        ExistingPreset = self.ExecuteQuery(
            "SELECT ID FROM UserPresets WHERE Name = ?",
            (PresetName,)
        )
        
        if ExistingPreset:
            # Update existing preset
            Query = """
            UPDATE UserPresets
            SET Description = ?, Temperature = ?, TopP = ?, MaxTokens = ?, 
                FrequencyPenalty = ?, PresencePenalty = ?,
                LastUsed = CURRENT_TIMESTAMP
            WHERE Name = ?
            """
            
            self.ExecuteNonQuery(
                Query,
                (
                    Description,
                    Params.get('Temperature', 0.7),
                    Params.get('TopP', 0.9),
                    Params.get('MaxTokens', 2048),
                    Params.get('FrequencyPenalty', 0.0),
                    Params.get('PresencePenalty', 0.0),
                    PresetName
                )
            )
            
            return ExistingPreset[0][0]
        else:
            # Insert new preset
            Query = """
            INSERT INTO UserPresets
            (Name, Description, Temperature, TopP, MaxTokens, 
             FrequencyPenalty, PresencePenalty)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """
            
            return self.ExecuteNonQuery(
                Query,
                (
                    PresetName,
                    Description,
                    Params.get('Temperature', 0.7),
                    Params.get('TopP', 0.9),
                    Params.get('MaxTokens', 2048),
                    Params.get('FrequencyPenalty', 0.0),
                    Params.get('PresencePenalty', 0.0)
                )
            )
    
    def DeleteUserPreset(self, PresetName: str) -> bool:
        """
        Delete a user-defined preset.
        
        Args:
            PresetName: Name of the preset
            
        Returns:
            True if deleted, False if not found
        """
        Result = self.ExecuteNonQuery(
            "DELETE FROM UserPresets WHERE Name = ?",
            (PresetName,)
        )
        
        return Result > 0
    
    # User Preference Methods
    
    def GetUserPreference(self, Key: str, Default: Any = None) -> Any:
        """
        Get a user preference.
        
        Args:
            Key: Preference key
            Default: Default value if preference not found
            
        Returns:
            Preference value
        """
        Results = self.ExecuteQuery(
            "SELECT Value, ValueType FROM UserPreferences WHERE Key = ?",
            (Key,)
        )
        
        if not Results:
            return Default
        
        Value, ValueType = Results[0]
        
        # Convert value based on type
        if ValueType == "int":
            return int(Value)
        elif ValueType == "float":
            return float(Value)
        elif ValueType == "bool":
            return Value.lower() in ("true", "1", "yes")
        elif ValueType == "json":
            return json.loads(Value)
        else:
            return Value
    
    def SetUserPreference(self, Key: str, Value: Any) -> None:
        """
        Set a user preference.
        
        Args:
            Key: Preference key
            Value: Preference value
        """
        # Determine value type
        if isinstance(Value, bool):
            ValueStr = "true" if Value else "false"
            ValueType = "bool"
        elif isinstance(Value, int):
            ValueStr = str(Value)
            ValueType = "int"
        elif isinstance(Value, float):
            ValueStr = str(Value)
            ValueType = "float"
        elif isinstance(Value, (dict, list)):
            ValueStr = json.dumps(Value)
            ValueType = "json"
        else:
            ValueStr = str(Value)
            ValueType = "string"
        
        # Check if preference exists
        Results = self.ExecuteQuery(
            "SELECT COUNT(*) FROM UserPreferences WHERE Key = ?",
            (Key,)
        )
        
        if Results[0][0] > 0:
            # Update existing preference
            self.ExecuteNonQuery(
                """
                UPDATE UserPreferences
                SET Value = ?, ValueType = ?, UpdatedAt = CURRENT_TIMESTAMP
                WHERE Key = ?
                """,
                (ValueStr, ValueType, Key)
            )
        else:
            # Insert new preference
            self.ExecuteNonQuery(
                """
                INSERT INTO UserPreferences (Key, Value, ValueType)
                VALUES (?, ?, ?)
                """,
                (Key, ValueStr, ValueType)
            )
    
    # App Settings Methods
    
    def GetAppSetting(self, Key: str, Default: Any = None) -> Any:
        """
        Get an application setting.
        
        Args:
            Key: Setting key
            Default: Default value if setting not found
            
        Returns:
            Setting value
        """
        Results = self.ExecuteQuery(
            "SELECT Value, ValueType FROM AppSettings WHERE Key = ?",
            (Key,)
        )
        
        if not Results:
            return Default
        
        Value, ValueType = Results[0]
        
        # Convert value based on type
        if ValueType == "int":
            return int(Value)
        elif ValueType == "float":
            return float(Value)
        elif ValueType == "bool":
            return Value.lower() in ("true", "1", "yes")
        elif ValueType == "json":
            return json.loads(Value)
        else:
            return Value
    
    def SetAppSetting(self, Key: str, Value: Any, Description: str = None) -> None:
        """
        Set an application setting.
        
        Args:
            Key: Setting key
            Value: Setting value
            Description: Optional setting description
        """
        # Determine value type
        if isinstance(Value, bool):
            ValueStr = "true" if Value else "false"
            ValueType = "bool"
        elif isinstance(Value, int):
            ValueStr = str(Value)
            ValueType = "int"
        elif isinstance(Value, float):
            ValueStr = str(Value)
            ValueType = "float"
        elif isinstance(Value, (dict, list)):
            ValueStr = json.dumps(Value)
            ValueType = "json"
        else:
            ValueStr = str(Value)
            ValueType = "string"
        
        # Check if setting exists
        Results = self.ExecuteQuery(
            "SELECT COUNT(*) FROM AppSettings WHERE Key = ?",
            (Key,)
        )
        
        if Results[0][0] > 0:
            # Update existing setting
            if Description:
                self.ExecuteNonQuery(
                    """
                    UPDATE AppSettings
                    SET Value = ?, ValueType = ?, Description = ?, UpdatedAt = CURRENT_TIMESTAMP
                    WHERE Key = ?
                    """,
                    (ValueStr, ValueType, Description, Key)
                )
            else:
                self.ExecuteNonQuery(
                    """
                    UPDATE AppSettings
                    SET Value = ?, ValueType = ?, UpdatedAt = CURRENT_TIMESTAMP
                    WHERE Key = ?
                    """,
                    (ValueStr, ValueType, Key)
                )
        else:
            # Insert new setting
            self.ExecuteNonQuery(
                """
                INSERT INTO AppSettings (Key, Value, ValueType, Description)
                VALUES (?, ?, ?, ?)
                """,
                (Key, ValueStr, ValueType, Description)
            )
    
    # UI String Methods
    
    def GetUIString(self, Key: str, Default: str = None) -> str:
        """
        Get a UI string.
        
        Args:
            Key: String key
            Default: Default value if string not found
            
        Returns:
            UI string
        """
        Results = self.ExecuteQuery(
            "SELECT EnText FROM UIStrings WHERE Key = ?",
            (Key,)
        )
        
        if not Results:
            return Default or Key
        
        return Results[0][0]
    
    def GetUIStrings(self, Context: str = None) -> Dict[str, str]:
        """
        Get all UI strings, optionally filtered by context.
        
        Args:
            Context: Optional context filter
            
        Returns:
            Dictionary of UI strings (key -> text)
        """
        if Context:
            Results = self.ExecuteQuery(
                "SELECT Key, EnText FROM UIStrings WHERE Context = ?",
                (Context,)
            )
        else:
            Results = self.ExecuteQuery(
                "SELECT Key, EnText FROM UIStrings"
            )
        
        return {Key: Text for Key, Text in Results}
    
    def SetUIString(self, Key: str, Text: str, Description: str = None, Context: str = None) -> None:
        """
        Set a UI string.
        
        Args:
            Key: String key
            Text: String text (English)
            Description: Optional description
            Context: Optional context
        """
        # Check if string exists
        Results = self.ExecuteQuery(
            "SELECT COUNT(*) FROM UIStrings WHERE Key = ?",
            (Key,)
        )
        
        if Results[0][0] > 0:
            # Update existing string
            if Description and Context:
                self.ExecuteNonQuery(
                    """
                    UPDATE UIStrings
                    SET EnText = ?, Description = ?, Context = ?
                    WHERE Key = ?
                    """,
                    (Text, Description, Context, Key)
                )
            elif Description:
                self.ExecuteNonQuery(
                    """
                    UPDATE UIStrings
                    SET EnText = ?, Description = ?
                    WHERE Key = ?
                    """,
                    (Text, Description, Key)
                )
            elif Context:
                self.ExecuteNonQuery(
                    """
                    UPDATE UIStrings
                    SET EnText = ?, Context = ?
                    WHERE Key = ?
                    """,
                    (Text, Context, Key)
                )
            else:
                self.ExecuteNonQuery(
                    """
                    UPDATE UIStrings
                    SET EnText = ?
                    WHERE Key = ?
                    """,
                    (Text, Key)
                )
        else:
            # Insert new string
            self.ExecuteNonQuery(
                """
                INSERT INTO UIStrings (Key, EnText, Description, Context)
                VALUES (?, ?, ?, ?)
                """,
                (Key, Text, Description, Context)
            )
    
    # Parameter Methods
    
    def GetAllParameters(self) -> List[Dict[str, Any]]:
        """
        Get all parameter definitions.
        
        Returns:
            List of parameter dictionaries
        """
        Results = self.ExecuteQuery(
            """
            SELECT * FROM Parameters
            ORDER BY OrderIndex
            """
        )
        
        Columns = [
            "Name", "DisplayName", "Description", "MinValue", "MaxValue",
            "DefaultValue", "StepSize", "IsInteger", "Category", "OrderIndex"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def GetParametersByCategory(self, Category: str) -> List[Dict[str, Any]]:
        """
        Get parameter definitions by category.
        
        Args:
            Category: Parameter category
            
        Returns:
            List of parameter dictionaries
        """
        Results = self.ExecuteQuery(
            """
            SELECT * FROM Parameters
            WHERE Category = ?
            ORDER BY OrderIndex
            """,
            (Category,)
        )
        
        Columns = [
            "Name", "DisplayName", "Description", "MinValue", "MaxValue",
            "DefaultValue", "StepSize", "IsInteger", "Category", "OrderIndex"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def GetParameter(self, Name: str) -> Optional[Dict[str, Any]]:
        """
        Get a parameter definition.
        
        Args:
            Name: Parameter name
            
        Returns:
            Parameter dictionary or None if not found
        """
        Results = self.ExecuteQuery(
            """
            SELECT * FROM Parameters
            WHERE Name = ?
            """,
            (Name,)
        )
        
        if not Results:
            return None
        
        Columns = [
            "Name", "DisplayName", "Description", "MinValue", "MaxValue",
            "DefaultValue", "StepSize", "IsInteger", "Category", "OrderIndex"
        ]
        
        return dict(zip(Columns, Results[0]))
    
    # Generation History Methods
    
    def AddGenerationHistory(self, ModelName: str, Prompt: str, Response: str, 
                             Params: Dict[str, Any], Metrics: Dict[str, Any]) -> int:
        """
        Add a generation history entry.
        
        Args:
            ModelName: Name of the model
            Prompt: Input prompt
            Response: Generated response
            Params: Generation parameters
            Metrics: Generation metrics
            
        Returns:
            ID of the new history entry
        """
        Query = """
        INSERT INTO GenerationHistory (
            ModelName, Prompt, Response, Temperature, TopP, MaxTokens,
            FrequencyPenalty, PresencePenalty, InputTokens, OutputTokens,
            TotalTokens, GenerationTime)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        return self.ExecuteNonQuery(
            Query,
            (
                ModelName,
                Prompt,
                Response,
                Params.get('Temperature', 0.7),
                Params.get('TopP', 0.9),
                Params.get('MaxTokens', 2048),
                Params.get('FrequencyPenalty', 0.0),
                Params.get('PresencePenalty', 0.0),
                Metrics.get('InputTokens', 0),
                Metrics.get('OutputTokens', 0),
                Metrics.get('TotalTokens', 0),
                Metrics.get('GenerationTime', 0.0)
            )
        )
    
    def GetGenerationHistory(self, Limit: int = 100, Offset: int = 0) -> List[Dict[str, Any]]:
        """
        Get generation history entries.
        
        Args:
            Limit: Maximum number of entries to retrieve
            Offset: Offset for pagination
            
        Returns:
            List of history entry dictionaries
        """
        Results = self.ExecuteQuery(
            """
            SELECT * FROM GenerationHistory
            ORDER BY CreatedAt DESC
            LIMIT ? OFFSET ?
            """,
            (Limit, Offset)
        )
        
        Columns = [
            "ID", "ModelName", "Prompt", "Response", "Temperature",
            "TopP", "MaxTokens", "FrequencyPenalty", "PresencePenalty",
            "InputTokens", "OutputTokens", "TotalTokens",
            "GenerationTime", "CreatedAt"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def GetGenerationHistoryForModel(self, ModelName: str, Limit: int = 100, Offset: int = 0) -> List[Dict[str, Any]]:
        """
        Get generation history entries for a specific model.
        
        Args:
            ModelName: Name of the model
            Limit: Maximum number of entries to retrieve
            Offset: Offset for pagination
            
        Returns:
            List of history entry dictionaries
        """
        Results = self.ExecuteQuery(
            """
            SELECT * FROM GenerationHistory
            WHERE ModelName = ?
            ORDER BY CreatedAt DESC
            LIMIT ? OFFSET ?
            """,
            (ModelName, Limit, Offset)
        )
        
        Columns = [
            "ID", "ModelName", "Prompt", "Response", "Temperature",
            "TopP", "MaxTokens", "FrequencyPenalty", "PresencePenalty",
            "InputTokens", "OutputTokens", "TotalTokens",
            "GenerationTime", "CreatedAt"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def ClearGenerationHistory(self) -> int:
        """
        Clear all generation history.
        
        Returns:
            Number of entries deleted
        """
        return self.ExecuteNonQuery("DELETE FROM GenerationHistory")
    
    # Benchmark Methods
    
    def AddBenchmarkResult(self, BenchmarkName: str, ModelName: str, Prompt: str,
                          AverageTime: float, AverageTokens: int, TokensPerSecond: float,
                          Runs: int, ConfigParams: Dict[str, Any]) -> int:
        """
        Add a benchmark result.
        
        Args:
            BenchmarkName: Name of the benchmark
            ModelName: Name of the model
            Prompt: Benchmark prompt
            AverageTime: Average generation time (seconds)
            AverageTokens: Average number of tokens
            TokensPerSecond: Average tokens per second
            Runs: Number of benchmark runs
            ConfigParams: Configuration parameters used
            
        Returns:
            ID of the new benchmark result
        """
        # Save model configuration
        ConfigID = self.SaveModelConfig(ModelName, f"Benchmark-{BenchmarkName}", ConfigParams)
        
        Query = """
        INSERT INTO BenchmarkResults (
            BenchmarkName, ModelName, ConfigID, Prompt,
            AverageTime, AverageTokens, AverageTokensPerSecond, Runs)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        return self.ExecuteNonQuery(
            Query,
            (
                BenchmarkName,
                ModelName,
                ConfigID,
                Prompt,
                AverageTime,
                AverageTokens,
                TokensPerSecond,
                Runs
            )
        )
    
    def GetBenchmarkResults(self, ModelName: str = None) -> List[Dict[str, Any]]:
        """
        Get benchmark results, optionally filtered by model.
        
        Args:
            ModelName: Optional model name filter
            
        Returns:
            List of benchmark result dictionaries
        """
        if ModelName:
            Results = self.ExecuteQuery(
                """
                SELECT b.*, c.Temperature, c.TopP, c.MaxTokens, 
                       c.FrequencyPenalty, c.PresencePenalty
                FROM BenchmarkResults b
                JOIN ModelConfigs c ON b.ConfigID = c.ID
                WHERE b.ModelName = ?
                ORDER BY b.CreatedAt DESC
                """,
                (ModelName,)
            )
        else:
            Results = self.ExecuteQuery(
                """
                SELECT b.*, c.Temperature, c.TopP, c.MaxTokens, 
                       c.FrequencyPenalty, c.PresencePenalty
                FROM BenchmarkResults b
                JOIN ModelConfigs c ON b.ConfigID = c.ID
                ORDER BY b.CreatedAt DESC
                """
            )
        
        Columns = [
            "ID", "BenchmarkName", "ModelName", "ConfigID", "Prompt",
            "AverageTime", "AverageTokens", "AverageTokensPerSecond", "Runs",
            "CreatedAt", "Temperature", "TopP", "MaxTokens",
            "FrequencyPenalty", "PresencePenalty"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    # Database Utility Methods
    
    def BackupDatabase(self, BackupPath: str) -> bool:
        """
        Create a backup of the database.
        
        Args:
            BackupPath: Path for the backup file
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Ensure directory exists
            os.makedirs(os.path.dirname(BackupPath), exist_ok=True)
            
            # Connect to source database
            SourceConn = sqlite3.connect(self.DBPath)
            
            # Connect to backup database
            BackupConn = sqlite3.connect(BackupPath)
            
            # Copy database content
            SourceConn.backup(BackupConn)
            
            # Close connections
            SourceConn.close()
            BackupConn.close()
            
            self.Logger.info(f"Database backed up to: {BackupPath}")
            return True
        
        except sqlite3.Error as Error:
            self.Logger.error(f"Error backing up database: {Error}")
            return False
    
    def RestoreDatabase(self, BackupPath: str) -> bool:
        """
        Restore the database from a backup.
        
        Args:
            BackupPath: Path to the backup file
            
        Returns:
            True if successful, False otherwise
        """
        try:
            if not os.path.exists(BackupPath):
                self.Logger.error(f"Backup file not found: {BackupPath}")
                return False
            
            # Close any open connections
            try:
                self.GetConnection().close()
            except:
                pass
            
            # Connect to backup database
            BackupConn = sqlite3.connect(BackupPath)
            
            # Connect to target database
            TargetConn = sqlite3.connect(self.DBPath)
            
            # Copy database content
            BackupConn.backup(TargetConn)
            
            # Close connections
            BackupConn.close()
            TargetConn.close()
            
            self.Logger.info(f"Database restored from: {BackupPath}")
            return True
        
        except sqlite3.Error as Error:
            self.Logger.error(f"Error restoring database: {Error}")
            return False

================
File: Core/LoggingUtils.py
================
# File: LoggingUtils.py
# Path: OllamaModelEditor/Core/LoggingUtils.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Logging utilities for the OllamaModelEditor application

import logging
import os
from pathlib import Path

def SetupLogging(LogLevel=logging.INFO, LogToFile=True):
    """
    Set up logging for the application.
    
    Args:
        LogLevel: Logging level (default: INFO)
        LogToFile: Whether to log to file (default: True)
    """
    # Create logger
    Logger = logging.getLogger('OllamaModelEditor')
    Logger.setLevel(LogLevel)
    
    # Create formatter
    Formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    
    # Create console handler
    ConsoleHandler = logging.StreamHandler()
    ConsoleHandler.setLevel(LogLevel)
    ConsoleHandler.setFormatter(Formatter)
    Logger.addHandler(ConsoleHandler)
    
    # Create file handler if requested
    if LogToFile:
        # Determine log directory
        HomeDir = Path.home()
        if os.name == 'nt':  # Windows
            LogDir = HomeDir / 'AppData' / 'Local' / 'OllamaModelEditor' / 'logs'
        else:  # macOS and Linux
            LogDir = HomeDir / '.config' / 'ollamaModelEditor' / 'logs'
        
        # Create directory if it doesn't exist
        LogDir.mkdir(parents=True, exist_ok=True)
        
        # Create file handler
        LogFile = LogDir / 'ollamaModelEditor.log'
        FileHandler = logging.FileHandler(str(LogFile))
        FileHandler.setLevel(LogLevel)
        FileHandler.setFormatter(Formatter)
        Logger.addHandler(FileHandler)
    
    return Logger

================
File: Core/ModelManager.py
================
# File: ModelManager.py
# Path: OllamaModelEditor/Core/ModelManager.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-12 11:30PM
# Description: Manages Ollama model operations for the OllamaModelEditor application

import os
import json
import requests
import time
from typing import Dict, List, Any, Optional, Tuple, Union
from pathlib import Path
import logging

# Import project modules
from Core.ConfigManager import ConfigManager

class ModelManager:
    """Manages Ollama model operations and interactions."""
    
    def __init__(self, Config: ConfigManager):
        """
        Initialize the model manager.
        
        Args:
            Config: Configuration manager instance
        """
        self.Config = Config
        self.APIEndpoint = Config.GetAppConfig('APIEndpoint', 'http://localhost:11434/api')
        self.Logger = logging.getLogger('OllamaModelEditor.ModelManager')
        self.AvailableModels = []
        self.CurrentModel = None
        
        # Get database reference from Config if available
        self.DB = getattr(Config, 'DB', None)
    
    def GetAvailableModels(self) -> List[Dict[str, Any]]:
        """
        Retrieve list of available Ollama models.
        
        Returns:
            List of model information dictionaries
        """
        try:
            # Send request to Ollama API
            Response = requests.get(f"{self.APIEndpoint}/tags")
            
            if Response.status_code == 200:
                # Parse response and update available models
                ModelData = Response.json()
                self.AvailableModels = ModelData.get('models', [])
                return self.AvailableModels
            else:
                self.Logger.error(f"Failed to retrieve models: {Response.status_code}")
                return []
                
        except Exception as Error:
            self.Logger.error(f"Error retrieving models: {Error}")
            return []
    
    def GetModelDetails(self, ModelName: str) -> Dict[str, Any]:
        """
        Get detailed information about a specific model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dict containing model details or empty dict if not found
        """
        try:
            # First check if we need to fetch the latest models
            if not self.AvailableModels:
                self.GetAvailableModels()
            
            # Find model in available models
            for Model in self.AvailableModels:
                if Model.get('name') == ModelName:
                    # Get additional model information
                    Response = requests.post(
                        f"{self.APIEndpoint}/show",
                        json={"name": ModelName}
                    )
                    
                    if Response.status_code == 200:
                        # Combine basic and detailed model information
                        DetailedInfo = Response.json()
                        
                        # Store last accessed time in database if available
                        if self.DB:
                            # Check if model exists in database
                            ModelConfigs = self.DB.GetModelConfigs(ModelName)
                            if not ModelConfigs:
                                # Create default config for model
                                DefaultParams = self.Config.GetModelConfig('DefaultParameters')
                                self.DB.SaveModelConfig(ModelName, "Default", DefaultParams)
                        
                        return {**Model, **DetailedInfo}
                    else:
                        self.Logger.error(f"Failed to get model details: {Response.status_code}")
                        return Model
            
            self.Logger.warning(f"Model not found: {ModelName}")
            return {}
                
        except Exception as Error:
            self.Logger.error(f"Error getting model details: {Error}")
            return {}
    
    def SetCurrentModel(self, ModelName: str) -> bool:
        """
        Set the current working model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Get model details
            ModelDetails = self.GetModelDetails(ModelName)
            
            if not ModelDetails:
                self.Logger.error(f"Cannot set current model: {ModelName} not found")
                return False
            
            # Set current model
            self.CurrentModel = ModelDetails
            
            # Add to recent models list
            self.Config.AddRecentModel(ModelName)
            
            # Update last used timestamp in database if available
            if self.DB:
                # Update LastUsed timestamp
                self.DB.ExecuteNonQuery(
                    """
                    UPDATE ModelConfigs 
                    SET LastUsed = CURRENT_TIMESTAMP 
                    WHERE ModelName = ?
                    """,
                    (ModelName,)
                )
            
            self.Logger.info(f"Current model set to: {ModelName}")
            return True
                
        except Exception as Error:
            self.Logger.error(f"Error setting current model: {Error}")
            return False
    
    def GetCurrentModel(self) -> Optional[Dict[str, Any]]:
        """
        Get the current working model.
        
        Returns:
            Dict containing current model details or None if not set
        """
        return self.CurrentModel
    
    def GenerateCompletion(self, Prompt: str, Parameters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Generate a completion using the current model.
        
        Args:
            Prompt: Input prompt for generation
            Parameters: Optional parameter overrides
            
        Returns:
            Dict containing the response
        """
        try:
            if not self.CurrentModel:
                self.Logger.error("No current model set")
                return {"error": "No current model set"}
            
            # Get model name
            ModelName = self.CurrentModel.get('name')
            
            # Get model parameters with defaults
            ModelParams = self.Config.GetModelConfig(ModelName)
            
            # Override with provided parameters if any
            if Parameters:
                ModelParams.update(Parameters)
            
            # Start timer for performance tracking
            StartTime = time.time()
            
            # Prepare request
            RequestData = {
                "model": ModelName,
                "prompt": Prompt,
                "temperature": ModelParams.get('Temperature', 0.7),
                "top_p": ModelParams.get('TopP', 0.9),
                "max_tokens": ModelParams.get('MaxTokens', 2048),
                "frequency_penalty": ModelParams.get('FrequencyPenalty', 0.0),
                "presence_penalty": ModelParams.get('PresencePenalty', 0.0),
                "stream": False
            }
            
            # Send request to Ollama API
            Response = requests.post(
                f"{self.APIEndpoint}/generate",
                json=RequestData
            )
            
            # Calculate elapsed time
            ElapsedTime = time.time() - StartTime
            
            if Response.status_code == 200:
                ResponseData = Response.json()
                
                # Add generation time to response
                ResponseData['generation_time'] = ElapsedTime
                
                # Record in history if database is available
                if self.DB:
                    # Extract metrics
                    Metrics = {
                        'InputTokens': ResponseData.get('prompt_eval_count', 0),
                        'OutputTokens': ResponseData.get('eval_count', 0),
                        'TotalTokens': ResponseData.get('prompt_eval_count', 0) + ResponseData.get('eval_count', 0),
                        'GenerationTime': ElapsedTime
                    }
                    
                    # Add to history
                    self.DB.AddGenerationHistory(
                        ModelName,
                        Prompt,
                        ResponseData.get('response', ''),
                        ModelParams,
                        Metrics
                    )
                
                return ResponseData
            else:
                self.Logger.error(f"Generation failed: {Response.status_code}")
                return {"error": f"Generation failed: {Response.status_code}"}
                
        except Exception as Error:
            self.Logger.error(f"Error generating completion: {Error}")
            return {"error": str(Error)}
    
    def UpdateModelParameters(self, ModelName: str, Parameters: Dict[str, Any]) -> bool:
        """
        Update parameters for a specific model.
        
        Args:
            ModelName: Name of the model
            Parameters: New parameter values
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Get current parameters
            CurrentParams = self.Config.GetModelConfig(ModelName)
            
            # Update parameters
            CurrentParams.update(Parameters)
            
            # Validate parameters
            if not self._ValidateParameters(CurrentParams):
                self.Logger.error("Invalid parameters")
                return False
            
            # Save updated parameters
            self.Config.SetModelConfig(ModelName, CurrentParams)
            
            # Save to database if available
            if self.DB:
                self.DB.SaveModelConfig(ModelName, "Default", CurrentParams)
            
            self.Logger.info(f"Model parameters updated for {ModelName}")
            return True
                
        except Exception as Error:
            self.Logger.error(f"Error updating model parameters: {Error}")
            return False
    
    def _ValidateParameters(self, Parameters: Dict[str, Any]) -> bool:
        """
        Validate model parameters.
        
        Args:
            Parameters: Parameters to validate
            
        Returns:
            bool: True if parameters are valid, False otherwise
        """
        # Required parameters
        RequiredParams = ['Temperature', 'TopP', 'MaxTokens']
        
        # Check required parameters
        for Param in RequiredParams:
            if Param not in Parameters:
                self.Logger.error(f"Missing required parameter: {Param}")
                return False
        
        # Validate parameter ranges
        if not 0 <= Parameters.get('Temperature', 0) <= 2:
            self.Logger.error("Temperature must be between 0 and 2")
            return False
        
        if not 0 <= Parameters.get('TopP', 0) <= 1:
            self.Logger.error("TopP must be between 0 and 1")
            return False
        
        if Parameters.get('MaxTokens', 0) <= 0:
            self.Logger.error("MaxTokens must be greater than 0")
            return False
        
        return True
    
    def BenchmarkModel(self, ModelName: str, Prompts: List[str], 
                      Parameters: Optional[Dict[str, Any]] = None, 
                      Runs: int = 3) -> Dict[str, Any]:
        """
        Benchmark model performance with provided prompts.
        
        Args:
            ModelName: Name of the model
            Prompts: List of test prompts
            Parameters: Optional parameter overrides
            Runs: Number of runs per prompt
            
        Returns:
            Dict containing benchmark results
        """
        try:
            # Set current model if not already set
            if not self.CurrentModel or self.CurrentModel.get('name') != ModelName:
                if not self.SetCurrentModel(ModelName):
                    return {"error": f"Could not set model: {ModelName}"}
            
            # Get parameters (with overrides if provided)
            ModelParams = self.Config.GetModelConfig(ModelName)
            if Parameters:
                ModelParams.update(Parameters)
            
            # Initialize results
            Results = {
                "model": ModelName,
                "parameters": ModelParams,
                "tests": [],
                "summary": {}
            }
            
            # Run tests for each prompt
            TotalTokens = 0
            TotalTime = 0
            
            for Index, Prompt in enumerate(Prompts):
                # Initialize metrics for this prompt
                PromptTotalTime = 0
                PromptTotalTokens = 0
                PromptTotalOutputTokens = 0
                SuccessfulRuns = 0
                
                # Run multiple times for consistent results
                for Run in range(Runs):
                    # Generate completion
                    Response = self.GenerateCompletion(Prompt, ModelParams)
                    
                    # Check for errors
                    if "error" in Response:
                        continue
                    
                    # Extract metrics
                    PromptTotalTime += Response.get('generation_time', 0)
                    InputTokens = Response.get('prompt_eval_count', 0)
                    OutputTokens = Response.get('eval_count', 0)
                    PromptTotalTokens += InputTokens + OutputTokens
                    PromptTotalOutputTokens += OutputTokens
                    
                    SuccessfulRuns += 1
                
                # Skip if all runs failed
                if SuccessfulRuns == 0:
                    Results["tests"].append({
                        "id": Index,
                        "prompt": Prompt,
                        "error": "All benchmark runs failed"
                    })
                    continue
                
                # Calculate averages
                AverageTime = PromptTotalTime / SuccessfulRuns
                AverageTokens = PromptTotalTokens / SuccessfulRuns
                AverageOutputTokens = PromptTotalOutputTokens / SuccessfulRuns
                TokensPerSecond = AverageOutputTokens / AverageTime if AverageTime > 0 else 0
                
                # Update totals
                TotalTokens += PromptTotalTokens
                TotalTime += PromptTotalTime
                
                # Add test result
                Results["tests"].append({
                    "id": Index,
                    "prompt": Prompt,
                    "average_time": AverageTime,
                    "average_tokens": AverageTokens,
                    "average_output_tokens": AverageOutputTokens,
                    "tokens_per_second": TokensPerSecond,
                    "successful_runs": SuccessfulRuns
                })
                
                # Save to database if available
                if self.DB:
                    self.DB.AddBenchmarkResult(
                        f"Prompt-{Index}",
                        ModelName,
                        Prompt,
                        AverageTime,
                        AverageTokens,
                        TokensPerSecond,
                        SuccessfulRuns,
                        ModelParams
                    )
            
            # Calculate summary statistics
            TestCount = len(Results["tests"])
            if TestCount > 0:
                Results["summary"] = {
                    "total_tests": TestCount,
                    "total_tokens": TotalTokens,
                    "total_time": TotalTime,
                    "average_tokens_per_second": TotalTokens / TotalTime if TotalTime > 0 else 0,
                    "average_time_per_test": TotalTime / TestCount,
                    "benchmark_date": time.strftime("%Y-%m-%d %H:%M:%S")
                }
            
            return Results
                
        except Exception as Error:
            self.Logger.error(f"Error benchmarking model: {Error}")
            return {"error": str(Error)}
    
    def ExportModelDefinition(self, ModelName: str, FilePath: str) -> bool:
        """
        Export model definition to a file.
        
        Args:
            ModelName: Name of the model
            FilePath: Path to save the definition
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Get model details
            ModelDetails = self.GetModelDetails(ModelName)
            
            if not ModelDetails:
                self.Logger.error(f"Model not found: {ModelName}")
                return False
            
            # Get model parameters
            ModelParams = self.Config.GetModelConfig(ModelName)
            
            # Get benchmark results if available
            BenchmarkResults = []
            if self.DB:
                BenchmarkResults = self.DB.GetBenchmarkResults(ModelName)
            
            # Combine details, parameters, and benchmarks
            ExportData = {
                "name": ModelName,
                "details": ModelDetails,
                "parameters": ModelParams,
                "benchmarks": BenchmarkResults
            }
            
            # Ensure directory exists
            Path(FilePath).parent.mkdir(parents=True, exist_ok=True)
            
            # Write to file
            with open(FilePath, 'w') as ExportFile:
                json.dump(ExportData, ExportFile, indent=2)
            
            self.Logger.info(f"Model definition exported to {FilePath}")
            return True
                
        except Exception as Error:
            self.Logger.error(f"Error exporting model definition: {Error}")
            return False
    
    def GetModelHistory(self, ModelName: str, Limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get generation history for a model.
        
        Args:
            ModelName: Name of the model
            Limit: Maximum number of entries to retrieve
            
        Returns:
            List of history entries
        """
        if self.DB:
            return self.DB.GetGenerationHistoryForModel(ModelName, Limit)
        
        return []
    
    def GetModelBenchmarks(self, ModelName: str) -> List[Dict[str, Any]]:
        """
        Get benchmark results for a model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            List of benchmark results
        """
        if self.DB:
            return self.DB.GetBenchmarkResults(ModelName)
        
        return []
    
    def ApplyPreset(self, ModelName: str, PresetName: str) -> bool:
        """
        Apply a parameter preset to a model.
        
        Args:
            ModelName: Name of the model
            PresetName: Name of the preset
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Get preset parameters
            PresetParams = None
            
            if self.DB:
                # Try to get from database
                Preset = self.DB.GetPreset(PresetName)
                if Preset:
                    PresetParams = {
                        'Temperature': Preset['Temperature'],
                        'TopP': Preset['TopP'],
                        'MaxTokens': Preset['MaxTokens'],
                        'FrequencyPenalty': Preset['FrequencyPenalty'],
                        'PresencePenalty': Preset['PresencePenalty']
                    }
                    
                    # Update preset usage statistics
                    self.DB.UpdatePresetUsage(PresetName)
            
            # Fall back to hardcoded presets if not found
            if not PresetParams:
                # Define presets
                Presets = {
                    "Default": {
                        'Temperature': 0.7,
                        'TopP': 0.9,
                        'MaxTokens': 2048,
                        'FrequencyPenalty': 0.0,
                        'PresencePenalty': 0.0
                    },
                    "Creative": {
                        'Temperature': 1.0,
                        'TopP': 0.95,
                        'MaxTokens': 4096,
                        'FrequencyPenalty': 0.0,
                        'PresencePenalty': 0.0
                    },
                    "Precise": {
                        'Temperature': 0.3,
                        'TopP': 0.7,
                        'MaxTokens': 2048,
                        'FrequencyPenalty': 0.5,
                        'PresencePenalty': 0.0
                    },
                    "Fast": {
                        'Temperature': 0.7,
                        'TopP': 0.9,
                        'MaxTokens': 1024,
                        'FrequencyPenalty': 0.0,
                        'PresencePenalty': 0.0
                    }
                }
                
                if PresetName in Presets:
                    PresetParams = Presets[PresetName]
                else:
                    self.Logger.error(f"Preset not found: {PresetName}")
                    return False
            
            # Apply preset parameters
            return self.UpdateModelParameters(ModelName, PresetParams)
        
        except Exception as Error:
            self.Logger.error(f"Error applying preset: {Error}")
            return False
    
    def SaveUserPreset(self, PresetName: str, Description: str, Parameters: Dict[str, Any]) -> bool:
        """
        Save a user-defined preset.
        
        Args:
            PresetName: Name of the preset
            Description: Preset description
            Parameters: Preset parameters
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Validate parameters
            if not self._ValidateParameters(Parameters):
                self.Logger.error("Invalid parameters for preset")
                return False
            
            # Save to database if available
            if self.DB:
                self.DB.SaveUserPreset(PresetName, Description, Parameters)
                self.Logger.info(f"User preset '{PresetName}' saved")
                return True
            
            # No database, cannot save user preset
            self.Logger.error("Database not available, cannot save user preset")
            return False
            
        except Exception as Error:
            self.Logger.error(f"Error saving user preset: {Error}")
            return False
    
    def GetUserPresets(self) -> List[Dict[str, Any]]:
        """
        Get all user-defined presets.
        
        Returns:
            List of preset dictionaries
        """
        if self.DB:
            UserPresets = self.DB.GetUserPresets()
            
            # Convert database format to application format
            return [{
                'Name': Preset['Name'],
                'Description': Preset['Description'],
                'Parameters': {
                    'Temperature': Preset['Temperature'],
                    'TopP': Preset['TopP'],
                    'MaxTokens': Preset['MaxTokens'],
                    'FrequencyPenalty': Preset['FrequencyPenalty'],
                    'PresencePenalty': Preset['PresencePenalty']
                }
            } for Preset in UserPresets]
        
        return []
    
    def DeleteUserPreset(self, PresetName: str) -> bool:
        """
        Delete a user-defined preset.
        
        Args:
            PresetName: Name of the preset
            
        Returns:
            bool: True if successful, False otherwise
        """
        if self.DB:
            Result = self.DB.DeleteUserPreset(PresetName)
            if Result:
                self.Logger.info(f"User preset '{PresetName}' deleted")
            else:
                self.Logger.warning(f"Failed to delete user preset '{PresetName}'")
            return Result
        
        return False

================
File: Core/ModelManagerExtensions.py
================
# File: ModelManagerExtensions.py
# Path: OllamaModelEditor/Core/ModelManagerExtensions.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-13
# Last Modified: 2025-03-13
# Description: Extensions for ModelManager to support preset handling

from typing import Dict, List, Any, Optional

# These methods should be added to the ModelManager class

def GetPresetParameters(self, PresetName: str) -> Dict[str, Any]:
    """
    Get parameters for a preset.
    
    Args:
        PresetName: Name of the preset
        
    Returns:
        Dict containing preset parameters or empty dict if not found
    """
    # Define built-in presets
    BuiltInPresets = {
        "Default": {
            'Temperature': 0.7,
            'TopP': 0.9,
            'MaxTokens': 2048,
            'FrequencyPenalty': 0.0,
            'PresencePenalty': 0.0
        },
        "Creative": {
            'Temperature': 1.0,
            'TopP': 0.95,
            'MaxTokens': 4096,
            'FrequencyPenalty': 0.0,
            'PresencePenalty': 0.0
        },
        "Precise": {
            'Temperature': 0.3,
            'TopP': 0.7,
            'MaxTokens': 2048,
            'FrequencyPenalty': 0.5,
            'PresencePenalty': 0.0
        },
        "Fast": {
            'Temperature': 0.7,
            'TopP': 0.9,
            'MaxTokens': 1024,
            'FrequencyPenalty': 0.0,
            'PresencePenalty': 0.0
        },
        "Balanced": {
            'Temperature': 0.6,
            'TopP': 0.85,
            'MaxTokens': 2048,
            'FrequencyPenalty': 0.3,
            'PresencePenalty': 0.3
        }
    }
    
    # Check if preset is a built-in preset
    if PresetName in BuiltInPresets:
        return BuiltInPresets[PresetName]
    
    # If using database, try to get from database
    if self.DB:
        # Try to get from database
        Preset = self.DB.GetPreset(PresetName)
        if Preset:
            return {
                'Temperature': Preset['Temperature'],
                'TopP': Preset['TopP'],
                'MaxTokens': Preset['MaxTokens'],
                'FrequencyPenalty': Preset['FrequencyPenalty'],
                'PresencePenalty': Preset['PresencePenalty']
            }
        
        # Try to get from user presets
        UserPreset = self.DB.GetUserPreset(PresetName)
        if UserPreset:
            return {
                'Temperature': UserPreset['Temperature'],
                'TopP': UserPreset['TopP'],
                'MaxTokens': UserPreset['MaxTokens'],
                'FrequencyPenalty': UserPreset['FrequencyPenalty'],
                'PresencePenalty': UserPreset['PresencePenalty']
            }
    
    # Return default parameters if preset not found
    return self.Config.GetModelConfig('DefaultParameters')

def GetAllPresets(self) -> List[Dict[str, Any]]:
    """
    Get all available presets.
    
    Returns:
        List of dictionaries containing preset information
    """
    Presets = []
    
    # Add built-in presets
    BuiltInPresets = [
        {
            'Name': 'Default',
            'Description': 'Balanced settings suitable for most tasks.',
            'IsBuiltIn': True
        },
        {
            'Name': 'Creative',
            'Description': 'Higher temperature and diversity for more creative, varied outputs.',
            'IsBuiltIn': True
        },
        {
            'Name': 'Precise',
            'Description': 'Lower temperature for more focused, deterministic responses.',
            'IsBuiltIn': True
        },
        {
            'Name': 'Fast',
            'Description': 'Optimized for speed with shorter outputs.',
            'IsBuiltIn': True
        },
        {
            'Name': 'Balanced',
            'Description': 'Moderate settings with some repetition control for well-rounded responses.',
            'IsBuiltIn': True
        }
    ]
    
    Presets.extend(BuiltInPresets)
    
    # If using database, add presets from database
    if self.DB:
        # Get presets from database
        DBPresets = self.DB.GetPresets()
        for Preset in DBPresets:
            Presets.append({
                'Name': Preset.get('Name', 'Unknown'),
                'Description': Preset.get('Description', ''),
                'IsBuiltIn': False
            })
        
        # Get user presets from database
        UserPresets = self.DB.GetUserPresets()
        for Preset in UserPresets:
            Presets.append({
                'Name': Preset.get('Name', 'Unknown'),
                'Description': Preset.get('Description', ''),
                'IsBuiltIn': False,
                'IsUserPreset': True
            })
    
    return Presets

def ApplyPresetToModel(self, ModelName: str, PresetName: str) -> bool:
    """
    Apply a preset to a model.
    
    Args:
        ModelName: Name of the model
        PresetName: Name of the preset
        
    Returns:
        bool: True if successful, False otherwise
    """
    # Get preset parameters
    PresetParams = self.GetPresetParameters(PresetName)
    
    if not PresetParams:
        self.Logger.error(f"Preset not found: {PresetName}")
        return False
    
    # Update model parameters
    Success = self.UpdateModelParameters(ModelName, PresetParams)
    
    if Success:
        self.Logger.info(f"Applied preset '{PresetName}' to model '{ModelName}'")
    
    return Success

def SaveUserPreset(self, PresetName: str, Description: str, Parameters: Dict[str, Any]) -> bool:
    """
    Save a user preset.
    
    Args:
        PresetName: Name of the preset
        Description: Description of the preset
        Parameters: Parameter values for the preset
        
    Returns:
        bool: True if successful, False otherwise
    """
    # Validate parameters
    if not self._ValidateParameters(Parameters):
        self.Logger.error("Invalid parameters for preset")
        return False
    
    # Save to database if available
    if self.DB:
        try:
            self.DB.SaveUserPreset(PresetName, Description, Parameters)
            self.Logger.info(f"User preset '{PresetName}' saved")
            return True
        except Exception as Error:
            self.Logger.error(f"Error saving user preset: {Error}")
            return False
    else:
        self.Logger.error("Database not available, cannot save user preset")
        return False

def DeleteUserPreset(self, PresetName: str) -> bool:
    """
    Delete a user preset.
    
    Args:
        PresetName: Name of the preset
        
    Returns:
        bool: True if successful, False otherwise
    """
    # Delete from database if available
    if self.DB:
        try:
            Result = self.DB.DeleteUserPreset(PresetName)
            if Result:
                self.Logger.info(f"User preset '{PresetName}' deleted")
            else:
                self.Logger.warning(f"User preset '{PresetName}' not found")
            return Result
        except Exception as Error:
            self.Logger.error(f"Error deleting user preset: {Error}")
            return False
    else:
        self.Logger.error("Database not available, cannot delete user preset")
        return False

================
File: Core/ParameterStateManager.py
================
# File: ParameterStateManager.py
# Path: OllamaModelEditor/Core/ParameterStateManager.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-13
# Last Modified: 2025-03-13
# Description: Manages parameter state tracking for the OllamaModelEditor application

from typing import Dict, Any, Optional, List, Tuple
import logging
import json
import copy
from pathlib import Path

class ParameterStateManager:
    """Manages and tracks parameter states for models."""
    
    def __init__(self, ModelManager, ConfigManager):
        """
        Initialize the parameter state manager.
        
        Args:
            ModelManager: Model manager instance
            ConfigManager: Configuration manager instance
        """
        self.Logger = logging.getLogger('OllamaModelEditor.ParameterStateManager')
        self.ModelManager = ModelManager
        self.ConfigManager = ConfigManager
        
        # Store original and current parameter states
        self.OriginalStates = {}  # ModelName -> Original parameters
        self.CurrentStates = {}   # ModelName -> Current parameters
        
        # Store model file contents (if available)
        self.ModelFiles = {}      # ModelName -> Model file content
    
    def LoadModelState(self, ModelName: str) -> Tuple[Dict[str, Any], Dict[str, Any]]:
        """
        Load and track the state for a model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Tuple of (original state, current state)
        """
        # Get model details
        ModelDetails = self.ModelManager.GetModelDetails(ModelName)
        
        # Get model parameters from configuration
        ModelParams = self.ConfigManager.GetModelConfig(ModelName)
        
        # Store original state if not already stored
        if ModelName not in self.OriginalStates:
            self.OriginalStates[ModelName] = copy.deepcopy(ModelParams)
        
        # Update current state
        self.CurrentStates[ModelName] = copy.deepcopy(ModelParams)
        
        # Attempt to load model file content if available
        self._LoadModelFile(ModelName)
        
        return (self.OriginalStates[ModelName], self.CurrentStates[ModelName])
    
    def _LoadModelFile(self, ModelName: str) -> None:
        """
        Attempt to load the model file content.
        
        Args:
            ModelName: Name of the model
        """
        try:
            # Look for model file in standard Ollama locations
            HomeDir = Path.home()
            OllamaDir = HomeDir / '.ollama'
            
            # Check for model file in models directory
            ModelFile = OllamaDir / 'models' / f"{ModelName}.json"
            if not ModelFile.exists():
                # Try alternative path format
                ModelName = ModelName.replace(':', '_')
                ModelFile = OllamaDir / 'models' / f"{ModelName}.json"
            
            if ModelFile.exists():
                with open(ModelFile, 'r') as f:
                    self.ModelFiles[ModelName] = json.load(f)
                    self.Logger.info(f"Loaded model file for {ModelName}")
            else:
                self.Logger.info(f"Model file not found for {ModelName}")
        except Exception as Error:
            self.Logger.error(f"Error loading model file for {ModelName}: {Error}")
    
    def UpdateCurrentState(self, ModelName: str, Parameters: Dict[str, Any]) -> None:
        """
        Update the current state for a model.
        
        Args:
            ModelName: Name of the model
            Parameters: Updated parameters
        """
        # Ensure model state is loaded
        if ModelName not in self.CurrentStates:
            self.LoadModelState(ModelName)
        
        # Update current state
        self.CurrentStates[ModelName].update(Parameters)
    
    def GetStateDifferences(self, ModelName: str) -> Dict[str, Tuple[Any, Any]]:
        """
        Get differences between original and current states.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dictionary mapping parameter names to (original, current) value tuples
        """
        if ModelName not in self.OriginalStates or ModelName not in self.CurrentStates:
            return {}
        
        Differences = {}
        Original = self.OriginalStates[ModelName]
        Current = self.CurrentStates[ModelName]
        
        # Find all parameter keys from both states
        AllParams = set(Original.keys()) | set(Current.keys())
        
        for Param in AllParams:
            OrigValue = Original.get(Param)
            CurrValue = Current.get(Param)
            
            if OrigValue != CurrValue:
                Differences[Param] = (OrigValue, CurrValue)
        
        return Differences
    
    def GetModelFile(self, ModelName: str) -> Optional[Dict[str, Any]]:
        """
        Get the model file content if available.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dictionary containing model file content or None if not available
        """
        return self.ModelFiles.get(ModelName)
    
    def GetAllModelParameters(self, ModelName: str) -> Dict[str, Any]:
        """
        Get all available parameters for a model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dictionary containing all available parameters
        """
        # Start with current state parameters
        AllParams = copy.deepcopy(self.CurrentStates.get(ModelName, {}))
        
        # Add parameters from model file if available
        ModelFile = self.GetModelFile(ModelName)
        if ModelFile and 'parameters' in ModelFile:
            # Get parameters from model file
            FileParams = ModelFile.get('parameters', {})
            
            # Add missing parameters
            for Param, Value in FileParams.items():
                if Param not in AllParams:
                    AllParams[Param] = Value
        
        return AllParams
    
    def ResetToOriginal(self, ModelName: str) -> Dict[str, Any]:
        """
        Reset current state to original state.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dictionary containing original parameters
        """
        if ModelName in self.OriginalStates:
            self.CurrentStates[ModelName] = copy.deepcopy(self.OriginalStates[ModelName])
            return self.CurrentStates[ModelName]
        return {}
    
    def CommitCurrentState(self, ModelName: str) -> bool:
        """
        Commit current state as the new original state.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            bool: True if successful, False otherwise
        """
        if ModelName in self.CurrentStates:
            # Save current state to configuration
            self.ConfigManager.SetModelConfig(ModelName, self.CurrentStates[ModelName])
            
            # Update original state
            self.OriginalStates[ModelName] = copy.deepcopy(self.CurrentStates[ModelName])
            
            self.Logger.info(f"Committed current state for {ModelName}")
            return True
        
        self.Logger.error(f"Cannot commit state for {ModelName}: no current state")
        return False

================
File: CurrentMods/old/OllamaModelEditor Implementation Plan.md
================
# OllamaModelEditor Implementation Plan

Based on the review of the OllamaModelEditor code and the enhancements we've made, this document outlines the steps for implementing the improvements and the future roadmap for the project.

## 1. Current Status

The application currently has:
- A functional UI for viewing and editing model parameters
- Database integration for storing configurations
- Basic benchmarking functionality
- Parameter descriptions and preset management

## 2. Immediate Implementation Plan

### 2.1. Fix Configuration Loading Issue

**Issue**: QByteArray serialization in YAML is causing configuration loading errors.

**Implementation**:
1. Add the `_SerializeQtObjects` and `_DeserializeQtObjects` methods to `ConfigManager.py`
2. Update the `SaveConfig` method to use these serialization methods
3. Update the `LoadConfig` method to use these deserialization methods

**Files to Update**:
- `Core/ConfigManager.py`

### 2.2. Enhance Parameter Editor

**Implementation**:
1. Add parameter description display when parameters are selected
2. Implement preset management functionality
3. Add apply and reset buttons
4. Organize parameters into basic and advanced sections

**Files to Update**:
- `GUI/Components/ParameterEditor.py`

### 2.3. Improve Benchmark View

**Implementation**:
1. Create proper benchmark configuration UI
2. Implement configuration comparison functionality
3. Add benchmark visualization
4. Implement benchmark result export

**Files to Update**:
- `GUI/Components/BenchmarkView.py`

### 2.4. Extend Model Manager

**Implementation**:
1. Add preset management methods to `ModelManager.py`
2. Implement methods to get and apply preset parameters
3. Add support for user-defined presets

**Files to Update**:
- `Core/ModelManager.py`

## 3. Integration Plan

1. Incorporate all component changes into the main application
2. Ensure consistent interaction between components
3. Test the application with the new features
4. Verify database integration works correctly

## 4. Testing Plan

### 4.1. Unit Testing

1. Test configuration serialization/deserialization
2. Test parameter editor interactions
3. Test benchmark functionality
4. Test preset management

### 4.2. Integration Testing

1. Test end-to-end workflows
2. Verify database operations
3. Test compatibility with different Ollama models

### 4.3. User Interface Testing

1. Verify UI looks and functions correctly
2. Test response to user inputs
3. Verify error handling

## 5. Future Roadmap

### 5.1. Short-Term (Next 1-2 Weeks)

1. **Enhanced Visualization**
   - Add proper charting with a library like matplotlib or QChart
   - Provide more visual feedback for parameter adjustments

2. **Advanced Analysis**
   - Add token usage visualization
   - Implement response analysis tools
   - Add parameter impact visualization

3. **User Experience Improvements**
   - Improve error handling and user feedback
   - Add tooltips and help text
   - Implement keyboard shortcuts

### 5.2. Medium-Term (Next 1-2 Months)

1. **Generation History**
   - Implement comprehensive history tracking
   - Add filtering and search capabilities
   - Provide export functionality

2. **Advanced Benchmarking**
   - Add standardized benchmark templates
   - Implement multi-model comparison
   - Add statistical analysis of results

3. **Configuration Management**
   - Add version control for configurations
   - Implement configuration sharing capabilities
   - Add import/export functionality

### 5.3. Long-Term (3+ Months)

1. **Integration with Ollama Ecosystem**
   - Add support for model management
   - Implement model download/update functionality
   - Add integration with other Ollama tools

2. **Advanced Features**
   - Implement fine-tuning workflows
   - Add prompt library and management
   - Create collaborative features

3. **Platform Expansion**
   - Consider web interface version
   - Develop mobile companion app
   - Create CLI integration

## 6. Implementation Checklist

- [x] Fix configuration loading issue
- [x] Enhance parameter editor
- [x] Improve benchmark view
- [x] Extend model manager with preset handling
- [ ] Integrate all component changes
- [ ] Test the application
- [ ] Update documentation
- [ ] Release initial enhanced version

## 7. Resources Required

1. **Development Resources**
   - Python/PySide6 development environment
   - SQLite database tools
   - Ollama installation for testing

2. **Testing Resources**
   - Test datasets for benchmarking
   - Various Ollama models for compatibility testing
   - Different platforms for cross-platform testing

3. **Documentation Resources**
   - Documentation tools (Markdown, etc.)
   - User guide templates
   - API documentation generator

## 8. Potential Challenges

1. **Performance Considerations**
   - Ensuring efficient database operations
   - Optimizing visualization for large datasets
   - Managing memory usage with large models

2. **Cross-Platform Compatibility**
   - Ensuring consistent behavior across platforms
   - Handling platform-specific paths and configurations
   - Managing different display densities

3. **Ollama API Compatibility**
   - Adapting to changes in the Ollama API
   - Supporting different model types
   - Handling API errors gracefully

## 9. Conclusion

The OllamaModelEditor project is progressing well with core functionality in place. The immediate focus is on fixing the identified issues and enhancing the user experience with improved parameter editing, benchmarking, and preset management.

With these improvements, the application will provide a more robust and user-friendly interface for managing Ollama models, making it a valuable tool for AI developers and enthusiasts.

================
File: CurrentMods/Benchmark Methodology Documentation.md
================
# Benchmark Methodology Documentation

## Overview

This document describes the benchmarking methodology used in the OllamaModelEditor application to evaluate model performance under different parameter configurations. The benchmarking system is designed to provide quantitative performance metrics that help users optimize their models for specific use cases.

## Benchmark Metrics

The benchmark system measures several key performance indicators:

1. **Generation Time**: The time taken for the model to generate a response, measured in seconds.
2. **Token Processing Speed**: The number of tokens generated per second (tokens/s).
3. **Input & Output Tokens**: The number of tokens in the prompt and the response.
4. **Total Tokens**: The combined total of input and output tokens.
5. **Success Rate**: The percentage of successful completions out of all attempts.

## Benchmark Process

### Standard Benchmark

The standard benchmark process follows these steps:

1. **Prompt Selection**: The user provides one or more prompts that represent their typical use case.
2. **Repetition**: Each prompt is processed multiple times (default: 3) to ensure consistent results.
3. **Parameter Configuration**: The benchmark can be run with the current parameters or compared with alternative configurations.
4. **Execution**: The model processes each prompt the specified number of times.
5. **Analysis**: Results are aggregated, analyzed, and presented in the UI.

### Metrics Calculation

- **Average Time**: The mean generation time across all runs for a prompt.
- **Average Tokens**: The mean number of tokens (input + output) across all runs.
- **Average Output Tokens**: The mean number of output tokens across all runs.
- **Tokens Per Second**: Average output tokens divided by average time.
- **Total Performance**: Aggregate metrics across all prompts.

## Benchmark Categories

### 1. Standard Benchmark

The basic benchmark that evaluates model performance with user-provided prompts.

**Use Case**: General performance testing and parameter optimization.

### 2. Comparison Benchmark

Runs the same prompts with two different parameter configurations to directly compare performance.

**Use Case**: Evaluating the impact of parameter changes on performance.

### 3. Stress Test (Planned)

Tests the model's ability to handle more demanding tasks, such as:
- Very long prompts
- Complex reasoning tasks
- Multiple consecutive requests
- Memory-intensive operations

**Use Case**: Evaluating the model's limits and stability under heavy load.

### 4. Specialized Benchmarks (Planned)

Targeted benchmarks for specific use cases:

#### 4.1. Creative Writing

Tests the model's ability to generate creative and diverse content. Measures:
- Diversity of vocabulary
- Syntactic variety
- Creativity metrics

#### 4.2. Factual Accuracy

Tests the model's accuracy on factual questions across different domains.

#### 4.3. Code Generation

Tests the model's ability to generate correct, efficient code in various programming languages.

#### 4.4. Context Utilization

Tests how effectively the model uses context from longer prompts.

## Interpreting Benchmark Results

### Performance Metrics

- **Higher Tokens/Second**: Indicates better raw performance.
- **Lower Generation Time**: Indicates faster response.
- **Successful Runs**: Indicates stability and reliability.

### Parameter Impact

The benchmark results should be interpreted in the context of parameter settings:

- **Temperature**: Higher values may lead to more diverse but potentially slower responses.
- **Max Tokens**: Higher values allow longer outputs but may increase generation time.
- **TopP**: Affects the diversity and determinism of responses.
- **Penalty Settings**: May impact generation speed and quality.

## Best Practices for Benchmarking

1. **Use Representative Prompts**: Select prompts that reflect your actual use case.
2. **Run Multiple Repetitions**: Always use at least 3 repetitions for consistent results.
3. **Test Multiple Parameters**: Compare different parameter configurations to find the optimal settings.
4. **Control Testing Environment**: Ensure consistent hardware and system load during testing.
5. **Consider Both Speed and Quality**: Faster isn't always better if quality suffers.

## Planned Benchmark Features

1. **Quality Metrics**: Automated evaluation of response quality.
2. **Parameter Optimization**: Automated testing of parameter combinations to find optimal settings.
3. **Historical Tracking**: Track performance changes over time or across model versions.
4. **Benchmark Templates**: Pre-defined benchmark suites for common use cases.
5. **Resource Monitoring**: Track memory usage, GPU utilization, and other system resources during benchmarking.

## Example Benchmark Scenarios

### General-Purpose Model Testing

```
Explain the concept of neural networks.
Write a short story about a time traveler.
Summarize the key points of climate change.
```

### Programming Model Testing

```
Write a function to find prime numbers in Python.
Explain the difference between functional and object-oriented programming.
Debug this code: [example code with errors]
```

### Creative Model Testing

```
Write a poem about artificial intelligence.
Create a short science fiction story.
Describe a futuristic city in the year 2200.
```

## Conclusion

Effective benchmarking is essential for optimizing model performance and ensuring that models meet the specific requirements of your use case. The OllamaModelEditor benchmarking system provides the tools to evaluate models, compare different configurations, and make informed decisions about parameter settings.

As the system evolves, additional metrics and testing capabilities will be added to provide more comprehensive and specialized benchmarking capabilities for different model types and use cases.

================
File: CurrentMods/BenchmarkView.py
================
# File: BenchmarkView.py
# Path: OllamaModelEditor/GUI/Components/BenchmarkView.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-13
# Description: Benchmarking component with backward compatibility for the OllamaModelEditor application

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit, QPushButton, 
    QFormLayout, QSpinBox, QCheckBox, QTabWidget, QApplication, QFileDialog,
    QFrame, QGridLayout, QMessageBox, QComboBox
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QIcon
import json
import time
from datetime import datetime

class BenchmarkView(QWidget):
    """Widget for benchmarking models with backward compatibility for StateManager."""
    
    def __init__(self, ModelManager, Config, StateManager=None):
        """
        Initialize the benchmark view.
        
        Args:
            ModelManager: Model manager instance
            Config: Configuration manager instance
            StateManager: Optional parameter state manager instance
        """
        super().__init__()
        
        # Store references
        self.ModelManager = ModelManager
        self.Config = Config
        self.StateManager = StateManager
        
        # Current benchmark results
        self.CurrentResults = None
        
        # Running benchmark flag
        self.IsRunning = False
        
        # Set up UI
        self._SetupUI()
    
    def _SetupUI(self):
        """Set up the user interface."""
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add header label
        HeaderLabel = QLabel("Model Benchmark")
        HeaderLabel.setStyleSheet("font-weight: bold; font-size: 14px; margin-bottom: 10px;")
        Layout.addWidget(HeaderLabel)
        
        # Add description
        DescriptionLabel = QLabel(
            "Compare model performance with different configurations. "
            "Enter sample prompts below to test how the model responds with current settings."
        )
        DescriptionLabel.setWordWrap(True)
        Layout.addWidget(DescriptionLabel)
        
        # Add benchmark configuration section
        ConfigFrame = QFrame()
        ConfigFrame.setFrameShape(QFrame.StyledPanel)
        ConfigLayout = QFormLayout(ConfigFrame)
        
        # Add model state view button if StateManager is available
        if self.StateManager:
            self.ViewStateButton = QPushButton("View Current Model State")
            self.ViewStateButton.clicked.connect(self._OnViewModelState)
            ConfigLayout.addRow(self.ViewStateButton)
        
        # Add benchmark type selector
        BenchmarkTypeLayout = QHBoxLayout()
        BenchmarkTypeLabel = QLabel("Benchmark Type:")
        self.BenchmarkTypeCombo = QComboBox()
        self.BenchmarkTypeCombo.addItems(["Standard", "Comparison", "Stress Test"])
        self.BenchmarkTypeCombo.currentTextChanged.connect(self._OnBenchmarkTypeChanged)
        BenchmarkTypeLayout.addWidget(BenchmarkTypeLabel)
        BenchmarkTypeLayout.addWidget(self.BenchmarkTypeCombo)
        ConfigLayout.addRow(BenchmarkTypeLayout)
        
        # Add model comparison selector
        self.CompareCheckbox = QCheckBox("Compare with another configuration")
        self.CompareCheckbox.toggled.connect(self._OnCompareToggled)
        ConfigLayout.addRow(self.CompareCheckbox)
        
        # Add comparison config selector (initially hidden)
        self.ComparisonConfigLayout = QHBoxLayout()
        self.ComparisonConfigLabel = QLabel("Comparison config:")
        self.ComparisonConfigLabel.setEnabled(False)
        self.ComparisonConfigCombo = QComboBox()
        self.ComparisonConfigCombo.setEnabled(False)
        self.ComparisonConfigCombo.addItems(["Default", "Creative", "Precise", "Fast", "Custom..."])
        self.ComparisonConfigLayout.addWidget(self.ComparisonConfigLabel)
        self.ComparisonConfigLayout.addWidget(self.ComparisonConfigCombo, 1)
        ConfigLayout.addRow(self.ComparisonConfigLayout)
        
        # Add repetition control
        RepetitionLayout = QHBoxLayout()
        self.RepetitionLabel = QLabel("Repetitions:")
        self.RepetitionSpinner = QSpinBox()
        self.RepetitionSpinner.setMinimum(1)
        self.RepetitionSpinner.setMaximum(10)
        self.RepetitionSpinner.setValue(3)
        self.RepetitionSpinner.setToolTip("Number of times to run each prompt for more accurate benchmarking")
        RepetitionLayout.addWidget(self.RepetitionLabel)
        RepetitionLayout.addWidget(self.RepetitionSpinner)
        RepetitionLayout.addStretch()
        ConfigLayout.addRow(RepetitionLayout)
        
        Layout.addWidget(ConfigFrame)
        
        # Add prompt input
        PromptLabel = QLabel("Enter benchmark prompts (one per line):")
        Layout.addWidget(PromptLabel)
        
        self.PromptsText = QTextEdit()
        self.PromptsText.setPlaceholderText("Enter benchmark prompts here...\n\nExample:\nSummarize the key features of neural networks.\nExplain the difference between supervised and unsupervised learning.\nWrite a short poem about artificial intelligence.")
        self.PromptsText.setMinimumHeight(100)
        Layout.addWidget(self.PromptsText)
        
        # Add buttons
        ButtonLayout = QHBoxLayout()
        
        self.RunButton = QPushButton("Run Benchmark")
        self.RunButton.setIcon(QIcon.fromTheme("media-playback-start"))
        self.RunButton.clicked.connect(self._OnRunBenchmark)
        ButtonLayout.addWidget(self.RunButton)
        
        self.StopButton = QPushButton("Stop")
        self.StopButton.setIcon(QIcon.fromTheme("media-playback-stop"))
        self.StopButton.clicked.connect(self._OnStopBenchmark)
        self.StopButton.setEnabled(False)
        ButtonLayout.addWidget(self.StopButton)
        
        self.SaveButton = QPushButton("Save Results")
        self.SaveButton.setIcon(QIcon.fromTheme("document-save"))
        self.SaveButton.clicked.connect(self._OnSaveResults)
        self.SaveButton.setEnabled(False)
        ButtonLayout.addWidget(self.SaveButton)
        
        Layout.addLayout(ButtonLayout)
        
        # Add results display with tabs
        self.ResultsTabs = QTabWidget()
        
        # Summary tab
        self.SummaryTab = QWidget()
        SummaryLayout = QVBoxLayout(self.SummaryTab)
        
        self.SummaryText = QTextEdit()
        self.SummaryText.setReadOnly(True)
        SummaryLayout.addWidget(self.SummaryText)
        
        # Charts tab
        self.ChartsTab = QWidget()
        ChartsLayout = QVBoxLayout(self.ChartsTab)
        
        self.ChartPlaceholder = QLabel("Charts will appear here after running benchmarks")
        self.ChartPlaceholder.setAlignment(Qt.AlignCenter)
        ChartsLayout.addWidget(self.ChartPlaceholder)
        
        # Detailed results tab
        self.DetailsTab = QWidget()
        DetailsLayout = QVBoxLayout(self.DetailsTab)
        
        self.DetailsText = QTextEdit()
        self.DetailsText.setReadOnly(True)
        DetailsLayout.addWidget(self.DetailsText)
        
        # Add tabs to tab widget
        self.ResultsTabs.addTab(self.SummaryTab, "Summary")
        self.ResultsTabs.addTab(self.ChartsTab, "Charts")
        self.ResultsTabs.addTab(self.DetailsTab, "Details")

================
File: CurrentMods/Main.py
================
# File: Main.py
# Path: OllamaModelEditor/Main.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-13
# Description: Entry point for the OllamaModelEditor application

import sys
import logging
from pathlib import Path
import argparse

# Add project root to path
ProjectRoot = Path(__file__).resolve().parent
sys.path.append(str(ProjectRoot))

# Set up basic logging
logging.basicConfig(level=logging.INFO, 
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
Logger = logging.getLogger('OllamaModelEditor')

# Import Core components first to ensure they're available
try:
    from Core.DBManager import DBManager
    from Core.LoggingUtils import SetupLogging
    from Core.ConfigManager import ConfigManager
    from Core.ParameterStateManager import ParameterStateManager
    Logger.info("Core modules imported")
except ImportError as e:
    Logger.error(f"Error importing Core components: {e}")
    print(f"Error importing Core components: {e}")
    print("Please make sure all required files are in place.")
    sys.exit(1)

# Import PySide6 components
try:
    from PySide6.QtWidgets import QApplication, QMainWindow, QMessageBox
    from PySide6.QtCore import QTimer
    Logger.info("PySide6 modules imported")
except ImportError as e:
    Logger.error(f"Error importing PySide6: {e}")
    print("Error: PySide6 is required but not installed.")
    print("Please install dependencies with: pip install -r requirements.txt")
    sys.exit(1)

# Import GUI components
try:
    from GUI.Windows.MainWindow import MainWindow
    from GUI.Windows.SplashScreen import SplashScreen
    Logger.info("GUI imports successful")
except ImportError as e:
    Logger.error(f"Error importing GUI components: {e}")
    print(f"Error importing GUI components: {e}")
    print("Please make sure all required files are in place.")
    sys.exit(1)

def ShowErrorAndExit(Message, Error=None):
    """
    Show error message and exit application.
    
    Args:
        Message: Error message to display
        Error: Optional error object with details
    """
    Logger.error(f"{Message}")
    if Error:
        Logger.error(f"Error: {Error}")
    
    # Create QApplication if needed
    App = QApplication([])
    
    # Show error message
    QMessageBox.critical(None, "OllamaModelEditor Error", f"{Message}\n\n{Error}")
    
    # Exit application
    sys.exit(1)

def ParseCommandLine():
    """
    Parse command line arguments.
    
    Returns:
        Namespace with parsed arguments
    """
    Parser = argparse.ArgumentParser(description="OllamaModelEditor - A tool for managing Ollama AI models")
    Parser.add_argument("--config", help="Path to configuration file")
    Parser.add_argument("--db", help="Path to database file")
    Parser.add_argument("--migrate", action="store_true", help="Migrate from file config to database")
    Parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    return Parser.parse_args()

def Main():
    """Application entry point."""
    # Parse command line arguments
    Args = ParseCommandLine()
    
    # Set log level based on arguments
    LogLevel = logging.DEBUG if Args.debug else logging.INFO
    
    Logger.info("Starting OllamaModelEditor")
    
    # Initialize database if using database storage
    try:
        DB = DBManager(Args.db) if Args.db else None
        if DB:
            Logger.info(f"Database initialized: {DB.DBPath}")
    except Exception as Error:
        ShowErrorAndExit("Error initializing database", Error)
    
    # Initialize logging
    SetupLogging(LogLevel=LogLevel)
    
    # Create application
    App = QApplication(sys.argv)
    App.setApplicationName("OllamaModelEditor")
    App.setOrganizationName("CallMeChewy")
    
    # Initialize configuration
    try:
        Config = ConfigManager(Args.config, DB)
        
        # Migrate from file to database if requested
        if Args.migrate and DB:
            Config.MigrateToDatabase(DB)
        
        Config.LoadConfig()
        Logger.info("Configuration loaded")
    except Exception as Error:
        ShowErrorAndExit("Error loading configuration", Error)
    
    # Create and display splash screen
    try:
        Splash = SplashScreen()
        Splash.show()
        Logger.info("Splash screen displayed")
    except Exception as Error:
        Logger.error(f"Error creating splash screen: {Error}")
        # Continue without splash screen
        Splash = None
    
    # Create model manager
    try:
        from Core.ModelManager import ModelManager
        ModelManager = ModelManager(Config)
    except Exception as Error:
        ShowErrorAndExit("Error creating model manager", Error)
    
    # Create parameter state manager
    try:
        StateManager = ParameterStateManager(ModelManager, Config)
    except Exception as Error:
        ShowErrorAndExit("Error creating parameter state manager", Error)
    
    # Initialize main window
    try:
        # Update this line to pass StateManager to MainWindow
        MainWin = MainWindow(Config, StateManager)
        Logger.info("Main window created")
        
        # Close splash and show main window after delay
        if Splash:
            QTimer.singleShot(2000, lambda: ShowMainWindow(Splash, MainWin))
        else:
            MainWin.show()
    except Exception as Error:
        ShowErrorAndExit("Failed to create main window", Error)
    
    # Start event loop
    Logger.info("Starting application event loop")
    return App.exec()

def ShowMainWindow(Splash, MainWin):
    """Close splash screen and show main window."""
    try:
        Splash.finish(MainWin)
        MainWin.show()
    except Exception as Error:
        Logger.error(f"Error showing main window: {Error}")
        MainWin.show()

if __name__ == "__main__":
    sys.exit(Main())

================
File: CurrentMods/mainwindow-update.py
================
# This is a partial implementation showing the changes needed to MainWindow.py

# Update the __init__ method to accept the StateManager parameter
def __init__(self, Config, StateManager):
    """
    Initialize the main window.
    
    Args:
        Config: Configuration manager instance
        StateManager: Parameter state manager instance
    """
    super().__init__()
    
    # Initialize logging
    self.Logger = logging.getLogger('OllamaModelEditor.MainWindow')
    
    # Store configuration and state manager
    self.Config = Config
    self.StateManager = StateManager
    
    # Create model manager
    self.ModelManager = ModelManager(Config)
    
    # Set up UI
    self._SetupWindow()
    self._CreateMenus()
    self._CreateToolbars()
    self._CreateStatusBar()
    self._CreateCentralWidget()
    self._CreateDockWidgets()
    
    # Load user preferences
    self._LoadPreferences()
    
    # Connect signals and slots
    self._ConnectSignals()
    
    # Load models
    self._LoadModels()

# Update the _CreateCentralWidget method to pass StateManager to ParameterEditor and BenchmarkView
def _CreateCentralWidget(self):
    """Create the central widget."""
    # Create central widget
    self.CentralWidget = QWidget()
    self.setCentralWidget(self.CentralWidget)
    
    # Main layout
    self.MainLayout = QVBoxLayout()
    self.CentralWidget.setLayout(self.MainLayout)
    
    # Create tab widget
    self.TabWidget = QTabWidget()
    self.MainLayout.addWidget(self.TabWidget)
    
    # Add parameter editor tab - Pass StateManager to ParameterEditor
    self.ParameterEditorWidget = ParameterEditor(self.ModelManager, self.Config, self.StateManager)
    self.ParameterEditorWidget.SetStatusBar(self.StatusBar)  # Pass StatusBar reference
    self.TabWidget.addTab(self.ParameterEditorWidget, "Parameter Editor")
    
    # Add benchmark tab - Pass StateManager to BenchmarkView 
    self.BenchmarkWidget = BenchmarkView(self.ModelManager, self.Config, self.StateManager)
    self.TabWidget.addTab(self.BenchmarkWidget, "Benchmark")
    
    # Add analysis tab if available
    try:
        from GUI.Components.AnalysisView import AnalysisView
        self.AnalysisWidget = AnalysisView(self.ModelManager, self.Config)
        self.TabWidget.addTab(self.AnalysisWidget, "Analysis")
    except ImportError:
        # Analysis view not available, skip
        pass

================
File: CurrentMods/OllamaModelEditor Implementation Updates.md
================
# OllamaModelEditor Implementation Updates

## Overview

Based on the benchmark results and requirements analysis, several significant enhancements have been implemented to improve the OllamaModelEditor application. This document outlines the key changes and provides guidance for integration.

## Key Enhancements

### 1. Parameter State Tracking

The application now tracks original and current parameter states for each model, allowing users to see what changes they've made during a session. This is implemented through a new `ParameterStateManager` class.

**Benefits:**
- Users can see how their current parameter values differ from the original values
- Original states are preserved for comparison and reset functionality
- Model file contents are loaded and displayed when available

### 2. Enhanced Parameter Editor

The parameter editor has been significantly improved with:
- A tabbed interface for parameters, state changes, and model file view
- Visual highlighting of changed parameters
- Improved reset functionality with options to reset to original or default values
- Better preset management integration

**Benefits:**
- Clearer visualization of parameter changes
- More comprehensive parameter management
- Access to complete model information

### 3. Improved Benchmark View

The benchmark view now provides:
- Model state information during benchmarking
- Multiple benchmark types (Standard, Comparison, Stress Test)
- Enhanced result visualization showing parameter differences
- More detailed performance comparisons

**Benefits:**
- Users can see exactly what parameter configuration was tested
- Multiple benchmark types for different use cases
- Better visualization of results

### 4. Comprehensive Benchmark Methodology

A detailed benchmark methodology document has been created that:
- Explains the benchmarking process and metrics
- Defines different benchmark categories and their purposes
- Provides best practices for effective benchmarking
- Outlines planned future benchmark features

**Benefits:**
- Users understand what is being tested and why
- Provides guidance for effective benchmarking
- Sets expectations for future features

## Integration Steps

To integrate these enhancements into the OllamaModelEditor application:

### 1. Add Parameter State Manager

Add the new `ParameterStateManager` class to the Core components:
```
Core/ParameterStateManager.py
```

### 2. Update Main Application

Modify `Main.py` to initialize the state manager:

```python
# Create state manager
StateManager = ParameterStateManager(ModelManager, ConfigManager)

# Pass state manager to UI components
MainWindow = MainWindow(ConfigManager, ModelManager, StateManager)
```

### 3. Update MainWindow

Modify `MainWindow` to pass the state manager to the relevant components:

```python
# Create parameter editor with state manager
self.ParameterEditorWidget = ParameterEditor(self.ModelManager, self.Config, self.StateManager)

# Create benchmark view with state manager
self.BenchmarkWidget = BenchmarkView(self.ModelManager, self.Config, self.StateManager)
```

### 4. Replace UI Components

Replace the existing ParameterEditor and BenchmarkView components with the enhanced versions.

### 5. Add Documentation

Add the benchmark methodology document to the documentation directory:

```
docs/BenchmarkMethodology.md
```

## Testing Guidelines

After integration, thoroughly test the following:

1. **Parameter State Tracking**
   - Load a model and modify its parameters
   - Verify the state changes table correctly shows differences
   - Test reset to original and default functionality

2. **Model File Display**
   - Verify model file content is displayed when available
   - Check that all model parameters are correctly shown

3. **Benchmarking**
   - Test standard benchmarking with current parameters
   - Test comparison benchmarking with a different configuration
   - Verify benchmark results correctly display parameter information
   - Test saving and loading benchmark results

## Future Development

Based on these enhancements, consider the following future developments:

1. **Advanced Visualization**
   - Implement proper charting for benchmark results
   - Add visual parameter relationship diagrams
   - Create interactive charts for comparing benchmark results

2. **Additional Benchmark Types**
   - Complete stress test implementation
   - Add specialized benchmarks for different model use cases
   - Implement benchmark templates for common scenarios

3. **Parameter Optimization**
   - Add parameter optimization suggestions based on benchmark results
   - Implement automatic parameter tuning
   - Create optimization profiles for different use cases

## Conclusion

These enhancements significantly improve the user experience and functionality of the OllamaModelEditor. By clearly showing model states and parameter changes, and providing comprehensive benchmarking capabilities, users can better understand and optimize their models for specific use cases.

The implementation follows the AIDEV-PascalCase-1.2 standard and maintains compatibility with the existing codebase while adding powerful new capabilities.

================
File: CurrentMods/ParameterEditor.py
================
# File: ParameterEditor.py
# Path: OllamaModelEditor/GUI/Components/ParameterEditor.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-13
# Description: Parameter editing component for the OllamaModelEditor application with backward compatibility

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QSlider, QSpinBox, QDoubleSpinBox,
    QPushButton, QGridLayout, QGroupBox, QTextEdit, QComboBox, QMessageBox,
    QInputDialog, QLineEdit, QFrame, QTabWidget
)
from PySide6.QtCore import Qt, QEvent, Signal, Slot
from PySide6.QtGui import QIcon
from typing import Dict, Any, Tuple, List, Optional

class ParameterEditor(QWidget):
    """Widget for editing model parameters with backward compatibility for StateManager."""
    
    # Signal emitted when parameters are applied
    ParametersApplied = Signal(dict)
    
    def __init__(self, ModelManager, Config, StateManager=None):
        """
        Initialize the parameter editor.
        
        Args:
            ModelManager: Model manager instance
            Config: Configuration manager instance
            StateManager: Optional parameter state manager instance
        """
        super().__init__()
        
        # Store references
        self.ModelManager = ModelManager
        self.Config = Config
        self.StateManager = StateManager
        self.CurrentModel = None
        self.ParameterControls = {}
        
        # Access status bar from parent (will be set after initialization)
        self.StatusBar = None
        
        # Set up UI
        self._SetupUI()
    
    def _SetupUI(self):
        """Set up the user interface."""
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add header layout with labels and presets
        HeaderLayout = QHBoxLayout()
        
        # Add header label
        HeaderLabel = QLabel("Model Parameters")
        HeaderLabel.setStyleSheet("font-weight: bold; font-size: 14px;")
        HeaderLayout.addWidget(HeaderLabel)
        
        # Add spacer
        HeaderLayout.addStretch()
        
        # Add preset selector
        PresetLayout = QHBoxLayout()
        PresetLabel = QLabel("Preset:")
        self.PresetCombo = QComboBox()
        self.LoadPresets()  # Populate presets
        
        self.SavePresetButton = QPushButton("Save Preset")
        self.SavePresetButton.setIcon(QIcon.fromTheme("document-save"))
        self.SavePresetButton.clicked.connect(self._OnSavePreset)
        
        PresetLayout.addWidget(PresetLabel)
        PresetLayout.addWidget(self.PresetCombo)
        PresetLayout.addWidget(self.SavePresetButton)
        
        HeaderLayout.addLayout(PresetLayout)
        
        Layout.addLayout(HeaderLayout)
        
        # Create main content area - using TabWidget if StateManager is available
        if self.StateManager:
            self.TabWidget = QTabWidget()
            
            # Parameters tab
            self.ParametersTab = QWidget()
            ParametersLayout = QVBoxLayout(self.ParametersTab)
            
            # Create parameters section
            ParametersGroupBox = QGroupBox("Basic Parameters")
            ParamLayout = QVBoxLayout(ParametersGroupBox)
            
            # Create parameters grid
            self.ParametersGrid = QGridLayout()
            ParamLayout.addLayout(self.ParametersGrid)
            
            ParametersLayout.addWidget(ParametersGroupBox)
            
            # Add advanced parameters section
            AdvancedGroupBox = QGroupBox("Advanced Parameters")
            AdvancedGroupBox.setCheckable(True)
            AdvancedGroupBox.setChecked(False)
            AdvancedLayout = QVBoxLayout(AdvancedGroupBox)
            
            # Create advanced parameters grid
            self.AdvancedParametersGrid = QGridLayout()
            AdvancedLayout.addLayout(self.AdvancedParametersGrid)
            
            ParametersLayout.addWidget(AdvancedGroupBox)
            
            # Add parameter description section
            DescriptionGroupBox = QGroupBox("Parameter Description")
            DescriptionLayout = QVBoxLayout(DescriptionGroupBox)
            
            self.DescriptionText = QTextEdit()
            self.DescriptionText.setReadOnly(True)
            self.DescriptionText.setMinimumHeight(100)
            self.DescriptionText.setPlaceholderText("Select a parameter to see its description")
            DescriptionLayout.addWidget(self.DescriptionText)
            
            ParametersLayout.addWidget(DescriptionGroupBox)
            
            # Add to tab widget
            self.TabWidget.addTab(self.ParametersTab, "Parameters")
            
            # State changes tab (only if StateManager available)
            if self.StateManager:
                self._AddStateTab()
            
            Layout.addWidget(self.TabWidget)
        else:
            # Legacy layout without tabs
            # Create parameters section
            ParametersGroupBox = QGroupBox("Basic Parameters")
            ParamLayout = QVBoxLayout(ParametersGroupBox)
            
            # Create parameters grid
            self.ParametersGrid = QGridLayout()
            ParamLayout.addLayout(self.ParametersGrid)
            
            Layout.addWidget(ParametersGroupBox)
            
            # Add advanced parameters section
            AdvancedGroupBox = QGroupBox("Advanced Parameters")
            AdvancedGroupBox.setCheckable(True)
            AdvancedGroupBox.setChecked(False)
            AdvancedLayout = QVBoxLayout(AdvancedGroupBox)
            
            # Create advanced parameters grid
            self.AdvancedParametersGrid = QGridLayout()
            AdvancedLayout.addLayout(self.AdvancedParametersGrid)
            
            Layout.addWidget(AdvancedGroupBox)
            
            # Add parameter description section
            DescriptionGroupBox = QGroupBox("Parameter Description")
            DescriptionLayout = QVBoxLayout(DescriptionGroupBox)
            
            self.DescriptionText = QTextEdit()
            self.DescriptionText.setReadOnly(True)
            self.DescriptionText.setMinimumHeight(100)
            self.DescriptionText.setPlaceholderText("Select a parameter to see its description")
            DescriptionLayout.addWidget(self.DescriptionText)
            
            Layout.addWidget(DescriptionGroupBox)
        
        # Add action buttons
        ButtonFrame = QFrame()
        ButtonLayout = QHBoxLayout(ButtonFrame)
        ButtonLayout.setContentsMargins(0, 10, 0, 0)
        
        self.ApplyButton = QPushButton("Apply Changes")
        self.ApplyButton.setIcon(QIcon.fromTheme("dialog-ok-apply"))
        self.ApplyButton.clicked.connect(self._OnApplyChanges)
        ButtonLayout.addWidget(self.ApplyButton)
        
        # Add reset to original button if StateManager is available
        if self.StateManager:
            self.ResetButton = QPushButton("Reset to Original")
            self.ResetButton.setIcon(QIcon.fromTheme("edit-undo"))
            self.ResetButton.clicked.connect(self._OnResetToOriginal)
            ButtonLayout.addWidget(self.ResetButton)
        
        self.DefaultButton = QPushButton("Reset to Default")
        self.DefaultButton.setIcon(QIcon.fromTheme("edit-clear"))
        self.DefaultButton.clicked.connect(self._OnResetToDefault)
        ButtonLayout.addWidget(self.DefaultButton)
        
        Layout.addWidget(ButtonFrame)
        
        # Add placeholder message (hidden initially)
        self.PlaceholderLabel = QLabel("Select a model to edit parameters")
        self.PlaceholderLabel.setAlignment(Qt.AlignCenter)
        self.PlaceholderLabel.setVisible(False)
        Layout.addWidget(self.PlaceholderLabel)
    
    def _AddStateTab(self):
        """Add state changes tab to the tab widget."""
        from PySide6.QtWidgets import QTableWidget, QTableWidgetItem, QHeaderView
        from PySide6.QtGui import QColor
        
        self.StateTab = QWidget()
        StateLayout = QVBoxLayout(self.StateTab)
        
        # Add state changes table
        StateLabel = QLabel("Parameter State Changes")
        StateLayout.addWidget(StateLabel)
        
        self.StateTable = QTableWidget(0, 3)  # Rows will be added dynamically
        self.StateTable.setHorizontalHeaderLabels(["Parameter", "Original Value", "Current Value"])
        self.StateTable.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.StateTable.verticalHeader().setVisible(False)
        StateLayout.addWidget(self.StateTable)
        
        # Add model file tab
        self.ModelFileTab = QWidget()
        ModelFileLayout = QVBoxLayout(self.ModelFileTab)
        
        self.ModelFileText = QTextEdit()
        self.ModelFileText.setReadOnly(True)
        self.ModelFileText.setLineWrapMode(QTextEdit.NoWrap)
        self.ModelFileText.setFont(self.font())  # Use default font
        ModelFileLayout.addWidget(self.ModelFileText)
        
        # Add tabs to the tab widget
        self.TabWidget.addTab(self.StateTab, "State Changes")
        self.TabWidget.addTab(self.ModelFileTab, "Model File")
    
    def SetStatusBar(self, StatusBar):
        """
        Set the status bar reference.
        
        Args:
            StatusBar: Status bar widget
        """
        self.StatusBar = StatusBar
    
    def LoadModel(self, ModelName: str):
        """
        Load a model for editing.
        
        Args:
            ModelName: Name of the model to load
        """
        # Store current model
        self.CurrentModel = ModelName
        
        # Hide placeholder
        self.PlaceholderLabel.setVisible(False)
        
        # Load model state if StateManager is available
        if self.StateManager:
            OriginalState, CurrentState = self.StateManager.LoadModelState(ModelName)
        
        # Clear parameters grid
        self._ClearParameterGrids()
        
        # Clear parameter controls
        self.ParameterControls = {}
        
        # Get model parameters
        ModelParams = self.Config.GetModelConfig(ModelName)
        
        # Get parameter descriptions from database if available
        ParameterDescriptions = {}
        if self.Config.DB:
            # Get all parameters
            Parameters = self.Config.DB.GetAllParameters()
            for Param in Parameters:
                ParameterDescriptions[Param['Name']] = Param['Description']
        
        # Add parameter controls
        self._CreateParameterControl(
            "Temperature", 
            ModelParams.get('Temperature', 0.7), 
            0.0, 2.0, 0.1, 
            False,
            ParameterDescriptions.get('Temperature', '')
        )
        
        self._CreateParameterControl(
            "TopP", 
            ModelParams.get('TopP', 0.9), 
            0.0, 1.0, 0.01, 
            False,
            ParameterDescriptions.get('TopP', '')
        )
        
        self._CreateParameterControl(
            "MaxTokens", 
            ModelParams.get('MaxTokens', 2048), 
            1, 32000, 1, 
            True,
            ParameterDescriptions.get('MaxTokens', '')
        )
        
        self._CreateParameterControl(
            "FrequencyPenalty", 
            ModelParams.get('FrequencyPenalty', 0.0), 
            0.0, 2.0, 0.1, 
            False,
            ParameterDescriptions.get('FrequencyPenalty', '')
        )
        
        self._CreateParameterControl(
            "PresencePenalty", 
            ModelParams.get('PresencePenalty', 0.0), 
            0.0, 2.0, 0.1, 
            False,
            ParameterDescriptions.get('PresencePenalty', '')
        )
        
        # Update state table if StateManager is available
        if self.StateManager and hasattr(self, 'StateTable'):
            self._UpdateStateTable()
        
        # Update model file view if StateManager is available
        if self.StateManager and hasattr(self, 'ModelFileText'):
            self._UpdateModelFileView()
        
        # Set preset to "Custom" (will be updated if it matches a preset)
        Index = self.PresetCombo.findText("Custom")
        if Index >= 0:
            self.PresetCombo.setCurrentIndex(Index)
        
        # Check if current state matches a preset
        if self.StateManager:
            self._CheckForMatchingPreset(ModelParams)
    
    def _ClearParameterGrids(self):
        """Clear parameter grid layouts."""
        # Clear basic parameters grid
        while self.ParametersGrid.count():
            Item = self.ParametersGrid.takeAt(0)
            if Item.widget():
                Item.widget().deleteLater()
        
        # Clear advanced parameters grid
        while self.AdvancedParametersGrid.count():
            Item = self.AdvancedParametersGrid.takeAt(0)
            if Item.widget():
                Item.widget().deleteLater()
    
    def _CreateParameterControl(self, Name, Value, Min, Max, Step, IsInteger=False, Description=""):
        """
        Add a parameter control to the grid.
        
        Args:
            Name: Parameter name
            Value: Current value
            Min: Minimum value
            Max: Maximum value
            Step: Step size
            IsInteger: Whether the parameter is an integer
            Description: Parameter description
        """
        # Determine which grid to use
        if Name in ["Temperature", "TopP", "MaxTokens"]:
            Grid = self.ParametersGrid
            Row = Grid.rowCount()
        else:
            Grid = self.AdvancedParametersGrid
            Row = Grid.rowCount()
        
        # Add label
        Label = QLabel(f"{Name}:")
        Grid.addWidget(Label, Row, 0)
        
        # Add slider
        Slider = QSlider(Qt.Horizontal)
        if IsInteger:
            Slider.setMinimum(int(Min))
            Slider.setMaximum(int(Max))
            Slider.setValue(int(Value))
        else:
            Slider.setMinimum(int(Min * 100))
            Slider.setMaximum(int(Max * 100))
            Slider.setValue(int(Value * 100))
        Grid.addWidget(Slider, Row, 1)
        
        # Add spin box
        if IsInteger:
            SpinBox = QSpinBox()
            SpinBox.setMinimum(int(Min))
            SpinBox.setMaximum(int(Max))
            SpinBox.setValue(int(Value))
        else:
            SpinBox = QDoubleSpinBox()
            SpinBox.setMinimum(Min)
            SpinBox.setMaximum(Max)
            SpinBox.setSingleStep(Step)
            SpinBox.setValue(Value)
            SpinBox.setDecimals(2)
        Grid.addWidget(SpinBox, Row, 2)
        
        # Store parameter description
        Slider.setProperty("ParameterName", Name)
        Slider.setProperty("ParameterDescription", Description)
        SpinBox.setProperty("ParameterName", Name)
        SpinBox.setProperty("ParameterDescription", Description)
        
        # Connect signals
        if IsInteger:
            Slider.valueChanged.connect(SpinBox.setValue)
            SpinBox.valueChanged.connect(Slider.setValue)
        else:
            Slider.valueChanged.connect(lambda v: SpinBox.setValue(v / 100))
            SpinBox.valueChanged.connect(lambda v: Slider.setValue(int(v * 100)))
        
        # Connect update signals
        if self.StateManager:
            Slider.valueChanged.connect(lambda: self._OnParameterChanged(Name))
            SpinBox.valueChanged.connect(lambda: self._OnParameterChanged(Name))
        
        # Connect description update signals
        Slider.sliderPressed.connect(lambda: self._UpdateDescription(Name, Description))
        SpinBox.installEventFilter(self)
        
        # Store controls for later access
        self.ParameterControls[Name] = (Slider, SpinBox)
    
    def eventFilter(self, obj, event):
        """Handle focus events for parameter controls."""
        if event.type() == QEvent.FocusIn:
            # If it's a parameter control, update description
            ParameterName = obj.property("ParameterName")
            if ParameterName:
                Description = obj.property("ParameterDescription")
                self._UpdateDescription(ParameterName, Description)
        
        return super().eventFilter(obj, event)
    
    def _UpdateDescription(self, ParameterName, Description):
        """
        Update the parameter description text.
        
        Args:
            ParameterName: Name of the parameter
            Description: Description text
        """
        # Get parameter descriptions from database if available
        if self.Config.DB:
            # Try to get from database
            Parameter = self.Config.DB.GetParameter(ParameterName)
            if Parameter and Parameter.get('Description'):
                Description = Parameter.get('Description')
        
        # If no description is available, use predefined descriptions
        if not Description:
            Descriptions = {
                "Temperature": "Controls randomness in text generation. Higher values (0.7-1.0) produce more creative outputs, while lower values (0.2-0.5) make output more focused and deterministic.",
                "TopP": "Controls diversity via nucleus sampling. Lower values make output more focused on likely tokens. 0.9 is a good starting point.",
                "MaxTokens": "The maximum length of the generated text. Higher values allow for longer responses but consume more resources.",
                "FrequencyPenalty": "Reduces repetition by penalizing tokens that have already appeared in the text. Higher values (0.5-1.0) strongly discourage repetition.",
                "PresencePenalty": "Penalizes tokens that have appeared at all, encouraging the model to discuss new topics. Useful for keeping responses diverse."
            }
            Description = Descriptions.get(ParameterName, f"No description available for {ParameterName}")
        
        # Update the description text
        self.DescriptionText.setHtml(f"<h3>{ParameterName}</h3>\n<p>{Description}</p>")
    
    def _OnParameterChanged(self, ParameterName):
        """
        Handle parameter value change.
        
        Args:
            ParameterName: Name of the changed parameter
        """
        if not self.CurrentModel or not self.StateManager:
            return
        
        # Get current parameter values
        Params = self._GetParametersFromControls()
        
        # Update state manager
        self.StateManager.UpdateCurrentState(self.CurrentModel, Params)
        
        # Update state table
        self._UpdateStateTable()
        
        # Check if current state matches a preset
        self._CheckForMatchingPreset(Params)
    
    def _UpdateStateTable(self):
        """Update the state changes table."""
        if not self.CurrentModel or not self.StateManager or not hasattr(self, 'StateTable'):
            return
        
        # Get state differences
        Differences = self.StateManager.GetStateDifferences(self.CurrentModel)
        
        # Clear table
        self.StateTable.setRowCount(0)
        
        # Add differences to table
        Row = 0
        for Param, (OrigValue, CurrValue) in Differences.items():
            self.StateTable.insertRow(Row)
            
            # Add parameter name
            ParamItem = QTableWidgetItem(Param)
            ParamItem.setFlags(ParamItem.flags() & ~Qt.ItemIsEditable)
            self.StateTable.setItem(Row, 0, ParamItem)
            
            # Add original value
            OrigItem = QTableWidgetItem(str(OrigValue))
            OrigItem.setFlags(OrigItem.flags() & ~Qt.ItemIsEditable)
            self.StateTable.setItem(Row, 1, OrigItem)
            
            # Add current value (highlighted)
            CurrItem = QTableWidgetItem(str(CurrValue))
            CurrItem.setFlags(CurrItem.flags() & ~Qt.ItemIsEditable)
            
            from PySide6.QtGui import QColor
            CurrItem.setBackground(QColor(255, 255, 0, 100))  # Light yellow highlight
            self.StateTable.setItem(Row, 2, CurrItem)
            
            Row += 1
    
    def _UpdateModelFileView(self):
        """Update the model file view."""
        if not self.CurrentModel or not self.StateManager or not hasattr(self, 'ModelFileText'):
            return
        
        # Get model file content
        ModelFile = self.StateManager.GetModelFile(self.CurrentModel)
        
        if ModelFile:
            import json
            # Format as pretty JSON
            ModelFileText = json.dumps(ModelFile, indent=2)
            self.ModelFileText.setText(ModelFileText)
        else:
            self.ModelFileText.setText("Model file not available")
    
    def LoadPresets(self):
        """Load available presets into the preset combo box."""
        self.PresetCombo.clear()
        
        # Add "Custom" option (for current state)
        self.PresetCombo.addItem("Custom")
        
        # Add built-in presets
        BuiltInPresets = ["Default", "Creative", "Precise", "Fast", "Balanced"]
        for Preset in BuiltInPresets:
            self.PresetCombo.addItem(Preset)
        
        # Add user presets from database if available
        if self.Config.DB:
            UserPresets = self.Config.DB.GetUserPresets()
            for Preset in UserPresets:
                self.PresetCombo.addItem(Preset.get('Name', 'Unknown'))
        
        # Connect signal
        self.PresetCombo.currentTextChanged.connect(self._OnPresetSelected)
    
    def _CheckForMatchingPreset(self, Params):
        """
        Check if current parameters match a preset.
        
        Args:
            Params: Current parameters
        """
        if not self.StateManager:
            return
            
        # Compare with each preset
        PresetNames = ["Default", "Creative", "Precise", "Fast", "Balanced"]
        
        for PresetName in PresetNames:
            PresetParams = None
            
            # Get preset parameters
            if hasattr(self.ModelManager, 'GetPresetParameters'):
                PresetParams = self.ModelManager.GetPresetParameters(PresetName)
            else:
                # Fallback to hardcoded presets if method not available
                Presets = {
                    "Default": {
                        'Temperature': 0.7,
                        'TopP': 0.9,
                        'MaxTokens': 2048,
                        'FrequencyPenalty': 0.0,
                        'PresencePenalty': 0.0
                    },
                    "Creative": {
                        'Temperature': 1.0,
                        'TopP': 0.95,
                        'MaxTokens': 4096,
                        'FrequencyPenalty': 0.0,
                        'PresencePenalty': 0.0
                    },
                    "Precise": {
                        'Temperature': 0.3,
                        'TopP': 0.7,
                        'MaxTokens': 2048,
                        'FrequencyPenalty': 0.5,
                        'PresencePenalty': 0.0
                    },
                    "Fast": {
                        'Temperature': 0.7,
                        'TopP': 0.9,
                        'MaxTokens': 1024,
                        'FrequencyPenalty': 0.0,
                        'PresencePenalty': 0.0
                    },
                    "Balanced": {
                        'Temperature': 0.6,
                        'TopP': 0.85,
                        'MaxTokens': 2048,
                        'FrequencyPenalty': 0.3,
                        'PresencePenalty': 0.3
                    }
                }
                PresetParams = Presets.get(PresetName)
            
            if PresetParams:
                # Check if parameters match
                Matches = True
                for Key, Value in PresetParams.items():
                    if Key in Params and abs(Params[Key] - Value) > 0.001:
                        Matches = False
                        break
                
                if Matches:
                    # Set preset combo to matching preset
                    Index = self.PresetCombo.findText(PresetName)
                    if Index >= 0:
                        self.PresetCombo.blockSignals(True)
                        self.PresetCombo.setCurrentIndex(Index)
                        self.PresetCombo.blockSignals(False)
                    return
        
        # If no match found, set to "Custom"
        Index = self.PresetCombo.findText("Custom")
        if Index >= 0:
            self.PresetCombo.blockSignals(True)
            self.PresetCombo.setCurrentIndex(Index)
            self.PresetCombo.blockSignals(False)
    
    def _OnPresetSelected(self, PresetName):
        """
        Handle preset selection.
        
        Args:
            PresetName: Name of the selected preset
        """
        if not self.CurrentModel or PresetName == "Custom":
            return
        
        # Get preset parameters
        PresetParams = None
        
        if hasattr(self.ModelManager, 'GetPresetParameters'):
            PresetParams = self.ModelManager.GetPresetParameters(PresetName)
        else:
            # Fallback to hardcoded presets if method not available
            Presets = {
                "Default": {
                    'Temperature': 0.7,
                    'TopP': 0.9,
                    'MaxTokens': 2048,
                    'FrequencyPenalty': 0.0,
                    'PresencePenalty': 0.0
                },
                "Creative": {
                    'Temperature': 1.0,
                    'TopP': 0.95,
                    'MaxTokens': 4096,
                    'FrequencyPenalty': 0.0,
                    'PresencePenalty': 0.0
                },
                "Precise": {
                    'Temperature': 0.3,
                    'TopP': 0.7,
                    'MaxTokens': 2048,
                    'FrequencyPenalty': 0.5,
                    'PresencePenalty': 0.0
                },
                "Fast": {
                    'Temperature': 0.7,
                    'TopP': 0.9,
                    'MaxTokens': 1024,
                    'FrequencyPenalty': 0.0,
                    'PresencePenalty': 0.0
                },
                "Balanced": {
                    'Temperature': 0.6,
                    'TopP': 0.85,
                    'MaxTokens': 2048,
                    'FrequencyPenalty': 0.3,
                    'PresencePenalty': 0.3
                }
            }
            PresetParams = Presets.get(PresetName)
        
        if not PresetParams:
            return
        
        # Apply preset parameters to controls
        self._ApplyParametersToControls(PresetParams)
        
        # Update state manager
        if self.StateManager:
            self.StateManager.UpdateCurrentState(self.CurrentModel, PresetParams)
            
            # Update state table
            self._UpdateStateTable()
    
    def _OnSavePreset(self):
        """Handle save preset button click."""
        # Get current parameter values
        Params = self._GetParametersFromControls()
        
        # Prompt user for preset name
        PresetName, OK = QInputDialog.getText(
            self,
            "Save Preset",
            "Enter a name for this preset:",
            QLineEdit.Normal,
            ""
        )
        
        if not OK or not PresetName:
            return
        
        # Prompt for description
        Description, OK = QInputDialog.getText(
            self,
            "Preset Description",
            "Enter a description for this preset:",
            QLineEdit.Normal,
            ""
        )
        
        if not OK:
            Description = ""
        
        # Save preset
        Success = False
        if hasattr(self.ModelManager, 'SaveUserPreset'):
            Success = self.ModelManager.SaveUserPreset(PresetName, Description, Params)
        else:
            # If SaveUserPreset method not available, try to use database directly
            if self.Config.DB:
                try:
                    self.Config.DB.SaveUserPreset(PresetName, Description, Params)
                    Success = True
                except:
                    Success = False
        
        if Success:
            # Update preset list
            self.LoadPresets()
            
            # Select the new preset
            Index = self.PresetCombo.findText(PresetName)
            if Index >= 0:
                self.PresetCombo.setCurrentIndex(Index)
        else:
            # Show error message
            QMessageBox.warning(
                self,
                "Save Error",
                "Error saving preset. Please check the logs for details."
            )
    
    def _GetParametersFromControls(self):
        """
        Get parameter values from controls.
        
        Returns:
            Dict: Parameter values
        """
        Params = {}
        
        for Name, (Slider, SpinBox) in self.ParameterControls.items():
            Params[Name] = SpinBox.value()
        
        return Params
    
    def _ApplyParametersToControls(self, Params):
        """
        Apply parameter values to controls.
        
        Args:
            Params: Dictionary of parameter values
        """
        for Name, Value in Params.items():
            if Name in self.ParameterControls:
                Slider, SpinBox = self.ParameterControls[Name]
                
                # Block signals to prevent recursive updates
                SpinBox.blockSignals(True)
                Slider.blockSignals(True)
                
                SpinBox.setValue(Value)
                
                # Set slider value (scaled for non-integer values)
                if isinstance(SpinBox, QDoubleSpinBox):
                    Slider.setValue(int(Value * 100))
                else:
                    Slider.setValue(Value)
                
                # Unblock signals
                SpinBox.blockSignals(False)
                Slider.blockSignals(False)
        
        # Trigger parameter changed event for each parameter if StateManager is available
        if self.StateManager:
            for Name in Params.keys():
                if Name in self.ParameterControls:
                    self._OnParameterChanged(Name)
    
    def _OnApplyChanges(self):
        """Handle apply changes button click."""
        if not self.CurrentModel:
            return
        
        # Get parameter values
        Params = self._GetParametersFromControls()
        
        # Update model parameters
        Success = self.ModelManager.UpdateModelParameters(self.CurrentModel, Params)
        
        if Success:
            # Commit current state if StateManager is available
            if self.StateManager:
                self.StateManager.CommitCurrentState(self.CurrentModel)
                
                # Update state table
                self._UpdateStateTable()
            
            # Show success message
            if self.StatusBar:
                self.StatusBar.showMessage(f"Parameters updated for {self.CurrentModel}", 3000)
            
            # Set preset to "Custom"
            Index = self.PresetCombo.findText("Custom")
            if Index >= 0:
                self.PresetCombo.setCurrentIndex(Index)
            
            # Check if now matches a preset
            if self.StateManager:
                self._CheckForMatchingPreset(Params)
            
            # Emit signal
            self.ParametersApplied.emit(Params)
        else:
            # Show error message
            QMessageBox.warning(
                self,
                "Update Error",
                f"Failed to update parameters for {self.CurrentModel}"
            )
    
    def _OnResetToOriginal(self):
        """Handle reset to original button click."""
        if not self.CurrentModel or not self.StateManager:
            return
        
        # Reset to original state
        OriginalParams = self.StateManager.ResetToOriginal(self.CurrentModel)
        
        if OriginalParams:
            # Apply original parameters to controls
            self._ApplyParametersToControls(OriginalParams)
            
            # Update state table
            self._UpdateStateTable()
            
            # Show message
            if self.StatusBar:
                self.StatusBar.showMessage("Parameters reset to original values", 3000)
    
    def _OnResetToDefault(self):
        """Handle reset to default button click."""
        if not self.CurrentModel:
            return
        
        # Get default parameters
        DefaultParams = self.Config.GetModelConfig('DefaultParameters')
        
        # Apply default parameters to controls
        self._ApplyParametersToControls(DefaultParams)
        
        # Update state manager if available
        if self.StateManager:
            self.StateManager.UpdateCurrentState(self.CurrentModel, DefaultParams)
            
            # Update state table
            self._UpdateStateTable()
        
        # Show message
        if self.StatusBar:
            self.StatusBar.showMessage("Parameters reset to default values", 3000)

================
File: CurrentMods/ParameterStateManager.py
================
# File: ParameterStateManager.py
# Path: OllamaModelEditor/Core/ParameterStateManager.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-13
# Last Modified: 2025-03-13
# Description: Simplified parameter state tracking for the OllamaModelEditor application

from typing import Dict, Any, Optional, List, Tuple
import logging
import copy

class ParameterStateManager:
    """Manages and tracks parameter states for models."""
    
    def __init__(self, ModelManager, ConfigManager):
        """
        Initialize the parameter state manager.
        
        Args:
            ModelManager: Model manager instance
            ConfigManager: Configuration manager instance
        """
        self.Logger = logging.getLogger('OllamaModelEditor.ParameterStateManager')
        self.ModelManager = ModelManager
        self.ConfigManager = ConfigManager
        
        # Store original and current parameter states
        self.OriginalStates = {}  # ModelName -> Original parameters
        self.CurrentStates = {}   # ModelName -> Current parameters
        
        # Store model file contents (if available)
        self.ModelFiles = {}      # ModelName -> Model file content
    
    def LoadModelState(self, ModelName: str) -> Tuple[Dict[str, Any], Dict[str, Any]]:
        """
        Load and track the state for a model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Tuple of (original state, current state)
        """
        # Get model parameters from configuration
        ModelParams = self.ConfigManager.GetModelConfig(ModelName)
        
        # Store original state if not already stored
        if ModelName not in self.OriginalStates:
            self.OriginalStates[ModelName] = copy.deepcopy(ModelParams)
        
        # Update current state
        self.CurrentStates[ModelName] = copy.deepcopy(ModelParams)
        
        return (self.OriginalStates[ModelName], self.CurrentStates[ModelName])
    
    def UpdateCurrentState(self, ModelName: str, Parameters: Dict[str, Any]) -> None:
        """
        Update the current state for a model.
        
        Args:
            ModelName: Name of the model
            Parameters: Updated parameters
        """
        # Ensure model state is loaded
        if ModelName not in self.CurrentStates:
            self.LoadModelState(ModelName)
        
        # Update current state
        self.CurrentStates[ModelName].update(Parameters)
    
    def GetStateDifferences(self, ModelName: str) -> Dict[str, Tuple[Any, Any]]:
        """
        Get differences between original and current states.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dictionary mapping parameter names to (original, current) value tuples
        """
        if ModelName not in self.OriginalStates or ModelName not in self.CurrentStates:
            return {}
        
        Differences = {}
        Original = self.OriginalStates[ModelName]
        Current = self.CurrentStates[ModelName]
        
        # Find all parameter keys from both states
        AllParams = set(Original.keys()) | set(Current.keys())
        
        for Param in AllParams:
            OrigValue = Original.get(Param)
            CurrValue = Current.get(Param)
            
            if OrigValue != CurrValue:
                Differences[Param] = (OrigValue, CurrValue)
        
        return Differences
    
    def GetModelFile(self, ModelName: str) -> Optional[Dict[str, Any]]:
        """
        Get the model file content if available.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dictionary containing model file content or None if not available
        """
        return self.ModelFiles.get(ModelName)
    
    def GetAllModelParameters(self, ModelName: str) -> Dict[str, Any]:
        """
        Get all available parameters for a model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dictionary containing all available parameters
        """
        # Start with current state parameters
        AllParams = copy.deepcopy(self.CurrentStates.get(ModelName, {}))
        return AllParams
    
    def ResetToOriginal(self, ModelName: str) -> Dict[str, Any]:
        """
        Reset current state to original state.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dictionary containing original parameters
        """
        if ModelName in self.OriginalStates:
            self.CurrentStates[ModelName] = copy.deepcopy(self.OriginalStates[ModelName])
            return self.CurrentStates[ModelName]
        return {}
    
    def CommitCurrentState(self, ModelName: str) -> bool:
        """
        Commit current state as the new original state.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            bool: True if successful, False otherwise
        """
        if ModelName in self.CurrentStates:
            # Save current state to configuration
            self.ConfigManager.SetModelConfig(ModelName, self.CurrentStates[ModelName])
            
            # Update original state
            self.OriginalStates[ModelName] = copy.deepcopy(self.CurrentStates[ModelName])
            
            self.Logger.info(f"Committed current state for {ModelName}")
            return True
        
        self.Logger.error(f"Cannot commit state for {ModelName}: no current state")
        return False

================
File: CurrentMods/StateManager Integration Guide.md
================
# StateManager Integration Guide

This guide provides step-by-step instructions for integrating the new ParameterStateManager into your OllamaModelEditor application to resolve the error you're encountering.

## Overview of Error

The error occurs because you've added the enhanced `ParameterEditor` which now requires a `StateManager` parameter:

```
TypeError: ParameterEditor.__init__() missing 1 required positional argument: 'StateManager'
```

## Integration Steps

### 1. Add the ParameterStateManager File

First, create the `ParameterStateManager.py` file in the Core directory:

```
Core/ParameterStateManager.py
```

Use the implementation provided in the previous artifact.

### 2. Update Main.py

Modify your `Main.py` file to:
1. Import the `ParameterStateManager`
2. Create an instance of it
3. Pass it to the `MainWindow` constructor

Key changes:
```python
# Add import
from Core.ParameterStateManager import ParameterStateManager

# In the Main() function, add:
# Create parameter state manager
try:
    StateManager = ParameterStateManager(ModelManager, Config)
except Exception as Error:
    ShowErrorAndExit("Error creating parameter state manager", Error)

# Update MainWindow creation
MainWin = MainWindow(Config, StateManager)
```

### 3. Update MainWindow.py

Modify your `MainWindow.py` file to:
1. Accept the `StateManager` parameter in the constructor
2. Store it as an instance variable
3. Pass it to the `ParameterEditor` and `BenchmarkView` components

Key changes:
```python
# Update constructor
def __init__(self, Config, StateManager):
    # Store state manager
    self.StateManager = StateManager
    
    # Rest of constructor...

# In _CreateCentralWidget method:
self.ParameterEditorWidget = ParameterEditor(self.ModelManager, self.Config, self.StateManager)
self.BenchmarkWidget = BenchmarkView(self.ModelManager, self.Config, self.StateManager)
```

### 4. Replace Component Implementations

Replace your existing component implementations with the enhanced versions:

1. `GUI/Components/ParameterEditor.py` -> Replace with enhanced version
2. `GUI/Components/BenchmarkView.py` -> Replace with enhanced version

### 5. Handling Temporary Backward Compatibility (Optional)

If you need a temporary solution before implementing all changes, you can modify the ParameterEditor to make StateManager optional:

```python
def __init__(self, ModelManager, Config, StateManager=None):
    # ...
    self.StateManager = StateManager
    # ...
```

Then conditionally use the StateManager functions only if it's available.

## Testing the Integration

After making these changes:

1. Start the application
2. Verify that the ParameterEditor loads correctly
3. Test parameter editing and state tracking
4. Test benchmarking with state information

## Troubleshooting

If you encounter issues after integration:

1. **ImportError**: Ensure the `ParameterStateManager.py` file is correctly placed in the Core directory
2. **AttributeError**: Check that all required methods are implemented in the StateManager
3. **UI Issues**: Verify that the updated components are correctly displaying state information

## Next Steps

After successful integration:

1. Implement the model file loading functionality
2. Enhance the benchmark results display
3. Add the stress test benchmark implementation
4. Consider adding parameter optimization suggestions

This integration provides a solid foundation for tracking and displaying parameter states, enhancing the user experience, and improving benchmark functionality.

================
File: docs/Notes/Additional Features from Original Design and Brainstorming.md
================
# Additional Features from Original Design and Brainstorming

# 1. Add benchmark functionality to BenchmarkView.py

# Update BenchmarkView._SetupUI method
def _SetupUI(self):
    """Set up the user interface."""
    # Create layout
    Layout = QVBoxLayout()
    self.setLayout(Layout)
    
    # Add header label
    HeaderLabel = QLabel("Model Benchmark")
    HeaderLabel.setStyleSheet("font-weight: bold; font-size: 14px; margin-bottom: 10px;")
    Layout.addWidget(HeaderLabel)
    
    # Add description
    DescriptionLabel = QLabel(
        "Compare model performance with different configurations. "
        "Enter sample prompts below to test how the model responds with current settings."
    )
    DescriptionLabel.setWordWrap(True)
    Layout.addWidget(DescriptionLabel)
    
    # Add benchmark configuration section
    ConfigFrame = QFrame()
    ConfigFrame.setFrameShape(QFrame.StyledPanel)
    ConfigLayout = QFormLayout(ConfigFrame)
    
    # Add model comparison selector
    self.CompareCheckbox = QCheckBox("Compare with another configuration")
    self.CompareCheckbox.toggled.connect(self._OnCompareToggled)
    ConfigLayout.addRow(self.CompareCheckbox)
    
    # Add comparison config selector (initially hidden)
    self.ComparisonConfigLayout = QHBoxLayout()
    self.ComparisonConfigLabel = QLabel("Comparison config:")
    self.ComparisonConfigLabel.setEnabled(False)
    self.ComparisonConfigCombo = QComboBox()
    self.ComparisonConfigCombo.setEnabled(False)
    self.ComparisonConfigCombo.addItems(["Default", "Creative", "Precise", "Fast", "Custom..."])
    self.ComparisonConfigLayout.addWidget(self.ComparisonConfigLabel)
    self.ComparisonConfigLayout.addWidget(self.ComparisonConfigCombo, 1)
    ConfigLayout.addRow(self.ComparisonConfigLayout)
    
    # Add repetition control
    RepetitionLayout = QHBoxLayout()
    self.RepetitionLabel = QLabel("Repetitions:")
    self.RepetitionSpinner = QSpinBox()
    self.RepetitionSpinner.setMinimum(1)
    self.RepetitionSpinner.setMaximum(10)
    self.RepetitionSpinner.setValue(3)
    self.RepetitionSpinner.setToolTip("Number of times to run each prompt for more accurate benchmarking")
    RepetitionLayout.addWidget(self.RepetitionLabel)
    RepetitionLayout.addWidget(self.RepetitionSpinner)
    RepetitionLayout.addStretch()
    ConfigLayout.addRow(RepetitionLayout)
    
    Layout.addWidget(ConfigFrame)
    
    # Add prompt input
    PromptLabel = QLabel("Enter benchmark prompts (one per line):")
    Layout.addWidget(PromptLabel)
    
    self.PromptsText = QTextEdit()
    self.PromptsText.setPlaceholderText("Enter benchmark prompts here...\n\nExample:\nSummarize the key features of neural networks.\nExplain the difference between supervised and unsupervised learning.\nWrite a short poem about artificial intelligence.")
    self.PromptsText.setMinimumHeight(100)
    Layout.addWidget(self.PromptsText)
    
    # Add buttons
    ButtonLayout = QHBoxLayout()
    
    self.RunButton = QPushButton("Run Benchmark")
    self.RunButton.setIcon(QIcon.fromTheme("media-playback-start"))
    self.RunButton.clicked.connect(self._OnRunBenchmark)
    ButtonLayout.addWidget(self.RunButton)
    
    self.StopButton = QPushButton("Stop")
    self.StopButton.setIcon(QIcon.fromTheme("media-playback-stop"))
    self.StopButton.clicked.connect(self._OnStopBenchmark)
    self.StopButton.setEnabled(False)
    ButtonLayout.addWidget(self.StopButton)
    
    self.SaveButton = QPushButton("Save Results")
    self.SaveButton.setIcon(QIcon.fromTheme("document-save"))
    self.SaveButton.clicked.connect(self._OnSaveResults)
    self.SaveButton.setEnabled(False)
    ButtonLayout.addWidget(self.SaveButton)
    
    Layout.addLayout(ButtonLayout)
    
    # Add results display with tabs
    self.ResultsTabs = QTabWidget()
    
    # Summary tab
    self.SummaryTab = QWidget()
    SummaryLayout = QVBoxLayout(self.SummaryTab)
    
    self.SummaryText = QTextEdit()
    self.SummaryText.setReadOnly(True)
    SummaryLayout.addWidget(self.SummaryText)
    
    # Charts tab
    self.ChartsTab = QWidget()
    ChartsLayout = QVBoxLayout(self.ChartsTab)
    
    self.ChartPlaceholder = QLabel("Charts will appear here after running benchmarks")
    self.ChartPlaceholder.setAlignment(Qt.AlignCenter)
    ChartsLayout.addWidget(self.ChartPlaceholder)
    
    # Detailed results tab
    self.DetailsTab = QWidget()
    DetailsLayout = QVBoxLayout(self.DetailsTab)
    
    self.DetailsText = QTextEdit()
    self.DetailsText.setReadOnly(True)
    DetailsLayout.addWidget(self.DetailsText)
    
    # Add tabs to tab widget
    self.ResultsTabs.addTab(self.SummaryTab, "Summary")
    self.ResultsTabs.addTab(self.ChartsTab, "Charts")
    self.ResultsTabs.addTab(self.DetailsTab, "Details")
    
    Layout.addWidget(self.ResultsTabs)

# Add new method to BenchmarkView
def _OnCompareToggled(self, Checked):
    """
    Handle compare checkbox toggle.
    
    Args:
        Checked: Whether the checkbox is checked
    """
    self.ComparisonConfigLabel.setEnabled(Checked)
    self.ComparisonConfigCombo.setEnabled(Checked)

# 2. Add configuration export/import functionality to MainWindow.py

# Add to MainWindow._OnExportModel
def _OnExportModel(self) -> None:
    """Handle export model definition action."""
    CurrentModel = self.ModelManager.GetCurrentModel()
    if not CurrentModel:
        QMessageBox.warning(
            self,
            "Export Error",
            "Please select a model first."
        )
        return
    
    ModelName = CurrentModel.get('name', 'unknown')
    
    # Get save file path
    FilePath, _ = QFileDialog.getSaveFileName(
        self,
        "Export Model Configuration",
        f"{ModelName}_config.json",
        "JSON Files (*.json);;YAML Files (*.yaml *.yml);;All Files (*.*)"
    )
    
    if not FilePath:
        return
    
    # Export model definition
    Success = self.ModelManager.ExportModelDefinition(ModelName, FilePath)
    
    if Success:
        QMessageBox.information(
            self,
            "Export Successful",
            f"Model configuration for {ModelName} was exported successfully to {FilePath}."
        )
    else:
        QMessageBox.critical(
            self,
            "Export Error",
            f"Failed to export model configuration for {ModelName}."
        )

# Add export configuration dialog
class ExportConfigDialog(QDialog):
    """Dialog for exporting model configuration."""
    
    def __init__(self, ModelName, Config, Parent=None):
        """
        Initialize the dialog.
        
        Args:
            ModelName: Name of the model
            Config: Configuration manager instance
            Parent: Parent widget
        """
        super().__init__(Parent)
        
        self.ModelName = ModelName
        self.Config = Config
        
        self.setWindowTitle(f"Export {ModelName} Configuration")
        self.setMinimumWidth(400)
        
        # Create layout
        Layout = QVBoxLayout(self)
        
        # Add export options
        OptionsGroup = QGroupBox("Export Options")
        OptionsLayout = QVBoxLayout(OptionsGroup)
        
        self.IncludeModelInfo = QCheckBox("Include Model Information")
        self.IncludeModelInfo.setChecked(True)
        OptionsLayout.addWidget(self.IncludeModelInfo)
        
        self.IncludeParameters = QCheckBox("Include Parameters")
        self.IncludeParameters.setChecked(True)
        OptionsLayout.addWidget(self.IncludeParameters)
        
        self.IncludeBenchmarks = QCheckBox("Include Benchmark Results")
        self.IncludeBenchmarks.setChecked(False)
        OptionsLayout.addWidget(self.IncludeBenchmarks)
        
        Layout.addWidget(OptionsGroup)
        
        # Add file format selection
        FormatGroup = QGroupBox("File Format")
        FormatLayout = QVBoxLayout(FormatGroup)
        
        self.JsonFormat = QRadioButton("JSON")
        self.JsonFormat.setChecked(True)
        FormatLayout.addWidget(self.JsonFormat)
        
        self.YamlFormat = QRadioButton("YAML")
        FormatLayout.addWidget(self.YamlFormat)
        
        Layout.addWidget(FormatGroup)
        
        # Add buttons
        ButtonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        ButtonBox.accepted.connect(self.accept)
        ButtonBox.rejected.connect(self.reject)
        Layout.addWidget(ButtonBox)

# 3. Add detailed analysis view

# Create new AnalysisView.py component
"""
# File: AnalysisView.py
# Path: OllamaModelEditor/GUI/Components/AnalysisView.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-12
# Last Modified: 2025-03-12
# Description: Detailed analysis component for the OllamaModelEditor application

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QTextEdit, QComboBox, QSplitter, QTabWidget, QFrame,
    QFormLayout, QSpinBox, QCheckBox
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QFont

class AnalysisView(QWidget):
    \"""Widget for detailed model analysis.\"""
    
    def __init__(self, ModelManager, Config):
        \"""
        Initialize the analysis view.
        
        Args:
            ModelManager: Model manager instance
            Config: Configuration manager instance
        \"""
        super().__init__()
        
        # Store references
        self.ModelManager = ModelManager
        self.Config = Config
        
        # Set up UI
        self._SetupUI()
    
    def _SetupUI(self):
        \"""Set up the user interface.\"""
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add header label
        HeaderLabel = QLabel("Detailed Analysis")
        HeaderLabel.setStyleSheet("font-weight: bold; font-size: 14px; margin-bottom: 10px;")
        Layout.addWidget(HeaderLabel)
        
        # Add description
        DescriptionLabel = QLabel(
            "Get detailed insights into how parameter changes affect model performance. "
            "Test with different inputs and analyze the outputs."
        )
        DescriptionLabel.setWordWrap(True)
        Layout.addWidget(DescriptionLabel)
        
        # Create main splitter
        Splitter = QSplitter(Qt.Vertical)
        Splitter.setHandleWidth(6)
        Splitter.setChildrenCollapsible(False)
        
        # Input section
        InputWidget = QWidget()
        InputLayout = QVBoxLayout(InputWidget)
        InputLayout.setContentsMargins(0, 0, 0, 0)
        
        # Input parameters
        InputParamsLayout = QHBoxLayout()
        
        # Input type selector
        InputTypeLayout = QFormLayout()
        self.InputTypeCombo = QComboBox()
        self.InputTypeCombo.addItems(["Text", "Code", "Summary", "Translation", "Question/Answer"])
        InputTypeLayout.addRow("Input Type:", self.InputTypeCombo)
        InputParamsLayout.addLayout(InputTypeLayout)
        
        # Max tokens
        MaxTokensLayout = QFormLayout()
        self.MaxTokensSpinner = QSpinBox()
        self.MaxTokensSpinner.setRange(1, 32000)
        self.MaxTokensSpinner.setValue(2048)
        MaxTokensLayout.addRow("Max Tokens:", self.MaxTokensSpinner)
        InputParamsLayout.addLayout(MaxTokensLayout)
        
        # Stream output
        StreamLayout = QFormLayout()
        self.StreamCheckbox = QCheckBox("Stream Output")
        self.StreamCheckbox.setChecked(True)
        StreamLayout.addRow(self.StreamCheckbox)
        InputParamsLayout.addLayout(StreamLayout)
        
        InputLayout.addLayout(InputParamsLayout)
        
        # Input text
        InputLabel = QLabel("Input:")
        InputLayout.addWidget(InputLabel)
        
        self.InputText = QTextEdit()
        self.InputText.setPlaceholderText("Enter your input text here...")
        self.InputText.setMinimumHeight(100)
        InputLayout.addWidget(self.InputText)
        
        # Action buttons
        ButtonLayout = QHBoxLayout()
        
        self.AnalyzeButton = QPushButton("Analyze")
        self.AnalyzeButton.clicked.connect(self._OnAnalyze)
        ButtonLayout.addWidget(self.AnalyzeButton)
        
        self.ClearButton = QPushButton("Clear")
        self.ClearButton.clicked.connect(self._OnClear)
        ButtonLayout.addWidget(self.ClearButton)
        
        InputLayout.addLayout(ButtonLayout)
        
        # Add input widget to splitter
        Splitter.addWidget(InputWidget)
        
        # Results section
        ResultsWidget = QWidget()
        ResultsLayout = QVBoxLayout(ResultsWidget)
        ResultsLayout.setContentsMargins(0, 0, 0, 0)
        
        # Results tabs
        self.ResultsTabs = QTabWidget()
        
        # Output tab
        self.OutputTab = QWidget()
        OutputLayout = QVBoxLayout(self.OutputTab)
        
        self.OutputText = QTextEdit()
        self.OutputText.setReadOnly(True)
        OutputLayout.addWidget(self.OutputText)
        
        # Analysis tab
        self.AnalysisTab = QWidget()
        AnalysisLayout = QVBoxLayout(self.AnalysisTab)
        
        self.AnalysisText = QTextEdit()
        self.AnalysisText.setReadOnly(True)
        AnalysisLayout.addWidget(self.AnalysisText)
        
        # Metrics tab
        self.MetricsTab = QWidget()
        MetricsLayout = QVBoxLayout(self.MetricsTab)
        
        self.MetricsText = QTextEdit()
        self.MetricsText.setReadOnly(True)
        MetricsLayout.addWidget(self.MetricsText)
        
        # Add tabs to tab widget
        self.ResultsTabs.addTab(self.OutputTab, "Output")
        self.ResultsTabs.addTab(self.AnalysisTab, "Analysis")
        self.ResultsTabs.addTab(self.MetricsTab, "Metrics")
        
        ResultsLayout.addWidget(self.ResultsTabs)
        
        # Add results widget to splitter
        Splitter.addWidget(ResultsWidget)
        
        # Set initial splitter sizes
        Splitter.

================
File: docs/Notes/AIDEV-PascalCase Implementation Plan.md
================
# AIDEV-PascalCase Implementation Plan

## Overview

This document outlines the comprehensive plan for implementing the AIDEV-PascalCase-1.2 standard throughout the OllamaModelEditor project, with a particular focus on ensuring the database schema and related components adhere to the standard.

## Goals

1. Ensure complete consistency with the AIDEV-PascalCase-1.2 standard across all components
2. Update the database schema to use PascalCase for all tables and columns
3. Modify all code that interacts with the database to use the new schema
4. Provide migration tools for existing users to update their databases
5. Update documentation to reflect the changes

## Components to Update

### 1. Database Schema

- [x] Create PascalCase database schema (`DatabaseSchema.sql`)
- [x] Update all table names to PascalCase
- [x] Update all column names to PascalCase
- [x] Ensure special terms (API, DB, GUI, etc.) are properly capitalized

### 2. Database Manager

- [x] Update `DBManager.py` to use PascalCase for all database interactions
- [x] Update SQL queries to use PascalCase column names
- [x] Update the default database path to use PascalCase filename

### 3. Configuration Manager

- [x] Update `ConfigManager.py` to work with the PascalCase database schema
- [x] Update methods that interact with the database
- [x] Update the configuration migration logic

### 4. Model Manager

- [ ] Update `ModelManager.py` to work with the PascalCase database schema
- [ ] Update methods that interact with the database
- [ ] Update any SQL queries to use PascalCase column names

### 5. Main Application

- [ ] Update `Main.py` to handle database initialization with the new schema
- [ ] Update command-line arguments for database path if necessary
- [ ] Add support for database migration from snake_case to PascalCase

### 6. GUI Components

- [ ] Update `BenchmarkView.py` to use PascalCase for database interactions
- [ ] Update `ParameterEditor.py` to work with the new schema if it interacts with the database
- [ ] Update any other GUI components that directly interact with the database

### 7. Utility Scripts

- [x] Create a database migration script (`MigrateDBToPascalCase.py`)
- [ ] Update any utility scripts that interact with the database

### 8. Testing

- [ ] Create test cases for the new database schema
- [ ] Test the migration script with different database states
- [ ] Test all components that interact with the database

### 9. Documentation

- [x] Create database migration guide
- [ ] Update general documentation to reflect PascalCase usage
- [ ] Add notes about the AIDEV-PascalCase-1.2 standard in relevant documentation

## Implementation Steps

### Phase 1: Core Database Components

1. ✅ Create a PascalCase database schema
2. ✅ Update DBManager class to use PascalCase
3. ✅ Create a database migration script
4. ✅ Update ConfigManager to work with the new schema

### Phase 2: Application Logic Components

5. Update ModelManager to work with the new schema
6. Update other core components that interact with the database
7. Test database migrations and functionality

### Phase 3: GUI and Utility Components

8. Update GUI components that interact with the database
9. Update utility scripts to support the new schema
10. Test GUI functionality with the PascalCase database

### Phase 4: Documentation and Finalization

11. ✅ Create documentation for the PascalCase standard implementation
12. Update user guides to reference the new schema
13. Add migration instructions to documentation
14. Perform final comprehensive testing

## Migration Strategy

### For Developers

1. Create a branch for the PascalCase implementation
2. Implement changes in phases as outlined above
3. Create merge requests for each phase
4. Review code changes thoroughly before merging

### For Users

1. Provide a database migration script that:
   - ✅ Backs up the existing database
   - ✅ Creates new tables with PascalCase names
   - ✅ Transfers data from old tables to new ones
   - ✅ Updates any indices or constraints

2. Include clear documentation on how to:
   - Backup existing data
   - Run the migration script
   - Verify successful migration
   - Troubleshoot common issues

## Testing Plan

1. Unit tests for each updated component
2. Integration tests for database interactions
3. Migration tests with various database states:
   - Empty database
   - Database with minimal data
   - Database with substantial data
   - Database with custom user data

4. Edge case testing:
   - Migration failure scenarios
   - Database corruption recovery
   - Concurrent access during migration

## Timeline

- Day 1: Complete Phase 1 (Core Database Components) ✅
- Day 2: Complete Phase 2 (Application Logic Components)
- Day 3: Complete Phase 3 (GUI and Utility Components)
- Day 4: Complete Phase 4 (Documentation and Finalization)
- Day 5: Final testing and refinement

## Potential Challenges

1. Maintaining backward compatibility with existing user databases
   - Solution: Provide comprehensive migration tools and documentation

2. Ensuring all database queries are updated correctly
   - Solution: Thorough testing and code review

3. Handling special case names with acronyms (API, DB, etc.)
   - Solution: Apply consistent rules for special terms as per the AIDEV-PascalCase-1.2 standard

4. Maintaining performance during database migration
   - Solution: Optimize migration script for efficiency with large datasets

## Conclusion

By following this implementation plan, we will fully align the OllamaModelEditor project with the AIDEV-PascalCase-1.2 standard, ensuring a consistent visual fingerprint throughout the codebase and improving the overall coherence and maintainability of the project.

The plan prioritizes the most critical components first, provides comprehensive migration tools for users, and includes thorough testing to ensure a smooth transition to the new standard.

================
File: docs/Notes/ConfigManager Update for PascalCase DB Schema.md
================
# ConfigManager Update for PascalCase Database Schema

## Overview

The `ConfigManager` class needs to be updated to work with the new PascalCase database schema. This document outlines the necessary changes and provides a plan for implementation.

## Required Changes

1. Update database interaction methods to use PascalCase column names
2. Update method names to consistently use PascalCase (if any are not already)
3. Ensure all variable names follow PascalCase conventions
4. Update any hardcoded SQL queries to use the new column names
5. Modify database-related methods to work with the new schema

## Implementation Plan

### 1. Update DB-Related Methods

The following methods in the `ConfigManager` class need to be updated:

- `_LoadAppConfigFromDB()`
- `_LoadUserPreferencesFromDB()`
- `_LoadModelConfigsFromDB()`
- `MigrateToDatabase()`

### 2. Update SQL Queries

All SQL queries in the class need to be updated to use PascalCase column names. For example:

Old:
```python
Settings = self.DB.ExecuteQuery(
    "SELECT key, value, value_type FROM AppSettings"
)
```

New:
```python
Settings = self.DB.ExecuteQuery(
    "SELECT Key, Value, ValueType FROM AppSettings"
)
```

### 3. Update Database Path Logic

Ensure the database path logic uses PascalCase for filenames:

Old:
```python
return str(ConfigDir / 'ollama_model_editor.db')
```

New:
```python
return str(ConfigDir / 'OllamaModelEditor.db')
```

### 4. Update Dictionary Keys

Update dictionary keys to maintain PascalCase throughout:

Old:
```python
self.AppConfig[Key] = Value
```

This is already using PascalCase, so no change needed. Verify all other dictionary keys.

### 5. Code Snippet for ConfigManager Class Update

Here are the key changes required for the `ConfigManager` class:

```python
def _LoadAppConfigFromDB(self) -> None:
    """Load application configuration from database."""
    # Get all app settings
    Settings = self.DB.ExecuteQuery(
        "SELECT Key, Value, ValueType FROM AppSettings"
    )
    
    # Clear existing app config
    self.AppConfig = {}
    
    # Convert settings to appropriate types and add to AppConfig
    for Key, Value, ValueType in Settings:
        if ValueType == "int":
            self.AppConfig[Key] = int(Value)
        elif ValueType == "float":
            self.AppConfig[Key] = float(Value)
        elif ValueType == "bool":
            self.AppConfig[Key] = Value.lower() in ("true", "1", "yes")
        elif ValueType == "json":
            self.AppConfig[Key] = json.loads(Value)
        else:
            self.AppConfig[Key] = Value

def _LoadUserPreferencesFromDB(self) -> None:
    """Load user preferences from database."""
    # Get all user preferences
    Preferences = self.DB.ExecuteQuery(
        "SELECT Key, Value, ValueType FROM UserPreferences"
    )
    
    # Clear existing preferences
    self.UserPreferences = {}
    
    # Convert preferences to appropriate types and add to UserPreferences
    for Key, Value, ValueType in Preferences:
        if ValueType == "int":
            self.UserPreferences[Key] = int(Value)
        elif ValueType == "float":
            self.UserPreferences[Key] = float(Value)
        elif ValueType == "bool":
            self.UserPreferences[Key] = Value.lower() in ("true", "1", "yes")
        elif ValueType == "json":
            self.UserPreferences[Key] = json.loads(Value)
        else:
            self.UserPreferences[Key] = Value

def _LoadModelConfigsFromDB(self) -> None:
    """Load model configurations from database."""
    # Get all model configurations
    ModelConfigs = self.DB.ExecuteQuery(
        """
        SELECT ModelName, ConfigName, Temperature, TopP, MaxTokens,
               FrequencyPenalty, PresencePenalty
        FROM ModelConfigs
        """
    )
    
    # Clear existing model configs
    self.ModelConfigs = {}
    
    # Group configurations by model
    for ModelName, ConfigName, Temperature, TopP, MaxTokens, FrequencyPenalty, PresencePenalty in ModelConfigs:
        # Create model entry if it doesn't exist
        if ModelName not in self.ModelConfigs:
            self.ModelConfigs[ModelName] = {}
        
        # Add configuration
        self.ModelConfigs[ModelName][ConfigName] = {
            'Temperature': Temperature,
            'TopP': TopP,
            'MaxTokens': MaxTokens,
            'FrequencyPenalty': FrequencyPenalty,
            'PresencePenalty': PresencePenalty
        }
```

### 6. Testing

After implementing these changes, thorough testing is required to ensure all functionality works correctly with the new database schema:

1. Test loading configuration from the database
2. Test saving configuration to the database
3. Test migrating from file to database
4. Test all get/set methods for the different configuration types
5. Test interaction with the ModelManager class

## Migration Strategy

To ensure a smooth transition, we recommend the following approach:

1. Make a backup of the existing code and database
2. Implement the changes to the ConfigManager class
3. Create a new test database with the PascalCase schema
4. Test the updated ConfigManager with the new database
5. Once verified, migrate the production database using the migration script
6. Deploy the updated code

## Additional Considerations

- Ensure any other classes that interact with the database are also updated to use the PascalCase schema
- Update any documentation that references the database schema
- Communicate the changes to the development team
- Consider adding a version check to handle potential version mismatches between code and database

## Conclusion

By updating the ConfigManager class to work with the PascalCase database schema, we maintain consistency throughout the codebase and adhere to the AIDEV-PascalCase-1.2 standard. This change will improve code readability and maintainability while ensuring the unique visual signature of the project is preserved at all levels.

================
File: docs/Notes/Database Migration to PascalCase Standard.md
================
# Database Migration to PascalCase Standard

## Overview

As part of our commitment to the AIDEV-PascalCase-1.2 standard, we've updated our database schema to use PascalCase for all table and column names. This document explains why this change was made and provides instructions for migrating existing databases to the new standard.

## Why PascalCase for Database Schema?

The AIDEV-PascalCase standard specifies that PascalCase should be used for naming conventions across the entire codebase, including:

- Classes
- Methods
- Functions
- Variables
- Database elements (tables, columns, etc.)

By using PascalCase for all database elements, we maintain a consistent visual fingerprint throughout the codebase. This consistency:

1. Improves code readability
2. Eliminates the need for mental translation between snake_case and PascalCase
3. Strengthens the distinctive signature of the project
4. Makes it easier to identify and correct naming inconsistencies

## Key Changes

The following changes have been made to standardize the database schema:

1. All table names now use PascalCase (e.g., `model_configs` → `ModelConfigs`)
2. All column names now use PascalCase (e.g., `model_name` → `ModelName`)
3. Special terms are properly capitalized (e.g., `api_key` → `APIKey`, `db_connection` → `DBConnection`)
4. Database filename uses PascalCase (`OllamaModelEditor.db` instead of `ollama_model_editor.db`)
5. Related file paths also use PascalCase for consistency

## Migration Process

### Automatic Migration

We provide a migration script that will automatically convert your existing database to the new PascalCase standard:

```bash
python scripts/MigrateDBToPascalCase.py --db /path/to/your/database.db --backup
```

The `--backup` flag will create a backup of your database before migration, which is strongly recommended.

### Migration Process Details

The migration script will:

1. Create a backup of your database (if the `--backup` flag is used)
2. Analyze all tables and columns in the database
3. Create temporary tables with PascalCase names and column definitions
4. Copy data from the original tables to the temporary tables
5. Drop the original tables
6. Rename the temporary tables to their final PascalCase names

### Manual Migration

If you prefer to perform the migration manually or if the automatic migration fails, you can use the SQL schema file `Core/DatabaseSchema.sql` to create a new database with the PascalCase standard, and then manually copy your data:

```bash
# Create a new database with the PascalCase schema
sqlite3 OllamaModelEditor_new.db < Core/DatabaseSchema.sql

# Then use SQLite tools to export and import your data
```

## Troubleshooting

If you encounter any issues during migration:

1. Check the logs for specific error messages
2. Restore from the backup if available
3. Try using the `--force` flag with the migration script to continue despite non-critical errors
4. If all else fails, create a new database using the schema file and manually copy your data

## Verifying Migration Success

After migration, you can verify that the database structure has been properly updated:

```bash
sqlite3 OllamaModelEditor.db ".schema"
```

All table and column names should now use PascalCase, with special terms like "API", "DB", etc. properly capitalized.

## Moving Forward

From this point forward, all database operations will use the PascalCase naming convention. The `DBManager` class has been updated to work with the new schema, so all database operations should continue to work seamlessly after migration.

## Support

If you encounter any issues with the migration process or the new database schema, please open an issue on the project repository or contact the project maintainer at Herb@BowersWorld.com.

================
File: docs/Notes/implementation-plan.md
================
# OllamaModelEditor UI and Feature Implementation Plan

Based on our brainstorming and the original design, here's a comprehensive plan to enhance the OllamaModelEditor application.

## 1. UI Improvements

### Menu and Tab Contrast
- Apply stylesheet to better differentiate the menu bar from tab controls
- Add subtle shadows or borders to create visual hierarchy
- Implement consistent padding and margins for cleaner separation

### Sidebar Behavior
- Fix the sidebar toggle to properly hide/show the sidebar
- Add proper resize handles with visible feedback
- Ensure the sidebar doesn't block the main content when toggled

### Parameter Controls
- Enhance sliders with better visual feedback
- Add parameter guidance information
- Implement preset system with quick-select options
- Add more advanced parameters from the original design

### Overall Styling
- Apply consistent dark theme with proper contrast
- Add visual distinction between interactive and static elements
- Ensure proper spacing between UI elements
- Add visual feedback for interactive elements (hover, click, etc.)

## 2. New Features to Implement

### Parameter Presets
- Pre-defined parameter combinations optimized for different use cases
- User-defined custom presets with save/load functionality
- Preset comparison tool

### Detailed Analysis
- Token-by-token analysis of generated content
- Performance metrics and visualization
- Parameter impact analysis

### Configuration Management
- Export/import parameter configurations
- Version tracking for configurations
- Configuration comparison tools

### Documentation and Help System
- Integrated documentation browser
- Context-sensitive help
- Parameter reference guide with explanations
- Interactive tutorials

### Benchmarking Enhancements
- More detailed metrics
- Visualization of benchmark results
- Configuration comparison
- Export benchmark results

## 3. Immediate Action Items

1. **Fix Sidebar Behavior**
   - Update the dock widget implementation
   - Add proper controls for hiding/showing

2. **Enhance Parameter Controls**
   - Add parameter guidance section
   - Implement preset selector
   - Add visual improvements to sliders

3. **Apply Styling Fixes**
   - Implement consistent stylesheet
   - Fix menu/tab contrast issues
   - Add proper spacing and margins

4. **Add Additional Parameters**
   - Include frequency penalty and presence penalty
   - Add context window settings
   - Include stop sequence configuration

## 4. Technical Implementation Notes

### UI Components
- Use QDockWidget for properly dockable sidebars
- Use QSplitter for resizable panels
- Apply stylesheet consistently across all elements
- Set objectNames for all major components

### Data Flow
- Maintain clear separation between UI and data objects
- Implement proper update mechanisms for parameter changes
- Use signals/slots for UI component communication

### Performance Considerations
- Lazy-load complex UI elements
- Implement background processing for intensive operations
- Add progress indicators for long-running tasks

### Error Handling
- Add robust error handling for API interactions
- Provide clear user feedback for errors
- Implement recovery mechanisms

## 5. Testing Plan

- Test UI on different screen sizes
- Verify all controls function as expected
- Test with both keyboard and mouse navigation
- Verify performance with large models
- Test error scenarios and recovery

================
File: docs/Notes/OllamaModelEditor - Database Integration Guide.md
================
# OllamaModelEditor - Database Integration Guide

## Overview

This guide will help you implement the SQLite database integration in the OllamaModelEditor project. The database will centralize data storage, eliminate hard-coded values, and provide a foundation for advanced features like history tracking and analytics.

## Implementation Steps

### 1. Add the DBManager Class

1. Create a new file `Core/DBManager.py` with the provided implementation.
2. This class handles all database operations and provides a clean interface for the rest of the application.
3. It includes automatic schema creation, data initialization, and comprehensive methods for working with the database.

### 2. Update Core Components

1. Update `Core/ConfigManager.py` to work with the database:
   - Add database support in the constructor
   - Modify methods to read/write from the database when available
   - Add migration functionality
   - Keep file-based configuration as a fallback

2. Update `Core/ModelManager.py` to leverage the database:
   - Add database integration for model configurations
   - Store generation history in the database
   - Save benchmark results
   - Implement user-defined presets

3. Update `Main.py` to initialize the database:
   - Add command-line arguments for database path
   - Create the database manager
   - Pass it to ConfigManager
   - Add migration option

### 3. Create Migration Script

1. Add `scripts/MigrateToDatabase.py` to transfer existing configuration to the database
2. This script can be run separately or from within the application
3. Ensures a smooth transition from file-based to database storage

## Testing the Implementation

### Running Migration

```bash
# Migrate existing configuration to database (interactive)
python scripts/MigrateToDatabase.py

# Specify source configuration and database location
python scripts/MigrateToDatabase.py --config config.yaml --db ollamaModelEditor.db
```

### Running With Database

```bash
# Run with database
python Main.py --db ollamaModelEditor.db

# Run with migration from file to database
python Main.py --migrate
```

### Database Verification

1. You can inspect the database using a SQLite browser tool like DB Browser for SQLite
2. Check that tables are created correctly
3. Verify data is stored as expected

## Benefits of Database Integration

The database integration provides several significant advantages:

1. **Centralized Data Storage**: All application data in one place with proper schema
2. **Improved Data Management**: Better organization and maintenance of application data
3. **Reduced Code Complexity**: No need to manage file I/O and format conversions
4. **Better Performance**: Faster data access, especially with indexed queries
5. **Enhanced Features**: Easier to implement history tracking, model comparisons, and user preferences
6. **Scalability**: Accommodates future growth and more complex data relationships
7. **Simplified Backup**: Single file to back up and restore

## Backward Compatibility

The implementation maintains backward compatibility with the file-based approach:

1. If database is not available, falls back to file-based configuration
2. Configuration can be exported from database to files
3. Command-line arguments allow choosing between database and file storage

## Future Enhancements

Once the database integration is complete, you can implement several advanced features:

1. **Generation History Viewer**: Display and filter past generations
2. **Benchmark Analytics**: Visualize performance trends over time
3. **Parameter Impact Analysis**: See how parameter changes affect output
4. **User Preset Management**: Save, share, and apply custom parameter presets
5. **Multi-Model Comparison**: Compare performance across different models
6. **Internationalization**: Support multiple languages with UI strings from database

## Tips for Implementation

1. **Gradual Integration**: Start with ConfigManager, then ModelManager
2. **Test Each Change**: Verify each component works with the database before moving on
3. **Error Handling**: Ensure robust fallbacks if database operations fail
4. **Migration Tools**: Create tools to help users transition to the database
5. **Documentation**: Update documentation to explain database features

## Conclusion

The database integration transforms OllamaModelEditor from a configuration tool to a comprehensive model management platform. By centralizing data and providing a foundation for advanced features, it significantly enhances the application's capabilities while making the code more maintainable and extensible.

================
File: docs/Notes/OllamaModelEditor - Project Status and Roadmap.md
================
# OllamaModelEditor - Project Status and Roadmap

## Project Overview

OllamaModelEditor is a comprehensive GUI application designed to customize, optimize, and manage Ollama AI models. It provides an intuitive interface for adjusting model parameters, comparing performance across different configurations, and streamlining AI workflows.

This document outlines the current status of the project, its objectives, development progress, and future roadmap.

## Project Objectives

### Primary Objectives

1. **Provide Intuitive Parameter Editing**
   - Create a user-friendly GUI for customizing model parameters
   - Support all major Ollama model parameters (Temperature, TopP, MaxTokens, etc.)
   - Offer visual guidance for parameter selection

2. **Facilitate Model Performance Benchmarking**
   - Allow users to compare model performance across different parameter sets
   - Display meaningful performance metrics
   - Offer tools to save and analyze benchmark results

3. **Simplify Model Management**
   - Provide easy access to all locally available Ollama models
   - Support multiple parameter configurations for each model
   - Enable configuration import/export

4. **Enhance User Workflow**
   - Improve interaction with Ollama models through visual tools
   - Reduce the need for command-line operations
   - Provide presets for common use cases

### Secondary Objectives

1. **Maintain Consistent Design Standards**
   - Adhere to the AIDEV-PascalCase-1.2 standard throughout the codebase
   - Ensure consistent visual design across the application
   - Create a distinctive developer fingerprint

2. **Implement Robust Data Management**
   - Provide both file-based and database-backed configuration
   - Track model usage history and benchmark results
   - Enable data export for external analysis

3. **Support Cross-Platform Usage**
   - Ensure compatibility with Windows, macOS, and Linux
   - Maintain consistent user experience across platforms
   - Handle platform-specific paths and configurations

## Current Development Status

### Completed Components

1. **Core Framework**
   - ✅ Base application structure with PySide6
   - ✅ Core configuration management
   - ✅ Logging system
   - ✅ Model management interface

2. **Database Integration**
   - ✅ SQLite database implementation
   - ✅ Database schema design following PascalCase standards
   - ✅ Migration tools for database schema
   - ✅ Fallback to file-based configuration

3. **User Interface Components**
   - ✅ Main application window
   - ✅ Model selector sidebar
   - ✅ Parameter editor interface
   - ✅ Benchmark view
   - ✅ Splash screen

4. **Features**
   - ✅ Basic parameter editing
   - ✅ Model selection from available Ollama models
   - ✅ Parameter preset system
   - ✅ Benchmark functionality
   - ✅ Configuration saving/loading

### In Progress Components

1. **UI Refinements**
   - 🔄 Styling improvements for better visual hierarchy
   - 🔄 Responsive layout for different screen sizes
   - 🔄 Additional visual feedback for user actions

2. **Feature Enhancements**
   - 🔄 Advanced parameter analysis tools
   - 🔄 Visual representation of benchmark results
   - 🔄 Detailed model information display

3. **Documentation**
   - 🔄 User guide
   - 🔄 Developer documentation
   - 🔄 API reference

### Pending Components

1. **Advanced Features**
   - ⏳ Generation history viewer
   - ⏳ Parameter impact analysis
   - ⏳ Token usage visualization
   - ⏳ Multi-model comparison tools

2. **User Experience**
   - ⏳ Theme customization
   - ⏳ Keyboard shortcuts
   - ⏳ Context-sensitive help

3. **Platform Integration**
   - ⏳ Automatic Ollama server detection
   - ⏳ System integration (file associations, etc.)
   - ⏳ Update checking/notification

## Future Development Steps

### Short-Term Goals (1-3 months)

1. **Complete UI Refinements**
   - Finalize application styling
   - Improve layout responsiveness
   - Enhance visual feedback for user actions

2. **Implement Advanced Parameter Analysis**
   - Add parameter impact visualization
   - Develop comparative analysis tools
   - Create parameter optimization suggestions

3. **Enhance Documentation**
   - Complete user guide with examples
   - Finalize developer documentation
   - Create video tutorials

4. **Improve Testing**
   - Expand unit test coverage
   - Implement UI tests
   - Create benchmark standardization

### Medium-Term Goals (3-6 months)

1. **Add Generation History Features**
   - Implement comprehensive history tracking
   - Create visualization tools for token usage
   - Develop filtering and search capabilities

2. **Implement Model Comparison Tools**
   - Create side-by-side model comparison
   - Develop benchmark visualization
   - Add statistical analysis of performance

3. **Enhance User Experience**
   - Implement theme customization
   - Add keyboard shortcut system
   - Create context-sensitive help

4. **Improve Platform Integration**
   - Develop automatic Ollama server detection
   - Implement system integration features
   - Create update checking mechanism

### Long-Term Goals (6+ months)

1. **Extend to Advanced Use Cases**
   - Add support for fine-tuning workflows
   - Implement dataset management tools
   - Develop prompt library and management

2. **Create Collaborative Features**
   - Add configuration sharing capabilities
   - Implement preset community repository
   - Create benchmark result sharing

3. **Expand Platform Support**
   - Consider web interface version
   - Develop mobile companion app
   - Create CLI integration tools

4. **Performance Optimization**
   - Improve memory usage for large models
   - Optimize database operations
   - Enhance startup performance

## Suggested Improvements

### Technical Improvements

1. **Code Structure and Architecture**
   - Implement a more robust plugin architecture for extensibility
   - Refactor core components to improve separation of concerns
   - Create comprehensive test suites for all components

2. **Database Enhancements**
   - Add support for SQLite WAL mode for better concurrency
   - Implement database versioning and automatic upgrades
   - Add database compression or cleanup utilities

3. **Performance Optimizations**
   - Implement lazy loading for UI components
   - Add caching mechanisms for frequently accessed data
   - Optimize benchmark operations for multicore processors

4. **Integration Capabilities**
   - Develop API for external tool integration
   - Add support for multiple Ollama server connections
   - Create import/export formats for interoperability with other tools

### User Experience Improvements

1. **Interface Enhancements**
   - Add customizable dashboard view
   - Implement drag-and-drop functionality for model management
   - Create mini mode for compact display

2. **Visualization Tools**
   - Develop interactive charts for performance comparison
   - Create visual parameter relationship diagrams
   - Add real-time performance monitoring

3. **Workflow Improvements**
   - Implement project-based workflow with saved configurations
   - Add batch processing capabilities
   - Create automated testing sequences

4. **Accessibility Features**
   - Implement keyboard navigation for all features
   - Add screen reader support
   - Create high-contrast themes

### Feature Improvements

1. **Model Management**
   - Add model tagging and organization
   - Implement version control for configurations
   - Create model family grouping

2. **Parameter Handling**
   - Add parameter interdependency visualization
   - Implement parameter optimization algorithms
   - Create guided parameter selection wizards

3. **Benchmark System**
   - Add standard benchmark templates
   - Implement comparative scoring system
   - Create benchmark report generation

4. **Data Analysis**
   - Add statistical analysis of model performance
   - Implement export to common data analysis formats
   - Create recommendation engine for parameter optimization

## Conclusion

The OllamaModelEditor project has made significant progress in creating a robust GUI application for Ollama model management. The core architecture is established with a consistent design standard, and many of the fundamental features are implemented.

The immediate focus should be on completing UI refinements, implementing advanced analysis tools, and enhancing documentation. Medium-term goals include expanding the feature set with generation history tracking, model comparison tools, and enhanced user experience. Long-term vision includes advanced use cases, collaborative features, expanded platform support, and performance optimization.

By following this roadmap and implementing the suggested improvements, OllamaModelEditor can become a comprehensive solution for AI model management that enhances productivity and accessibility for both casual users and AI professionals.

================
File: docs/Notes/OllamaModelEditor Database Integration Guide.md
================
# OllamaModelEditor Database Integration Guide

## Overview

This guide explains how the OllamaModelEditor application integrates with its SQLite database and provides information about the PascalCase naming convention used in the database schema.

## Database Schema

The OllamaModelEditor application uses a SQLite database with a schema that follows the AIDEV-PascalCase-1.2 standard. This means all table and column names use PascalCase (e.g., `ModelConfigs`, `ModelName`) instead of the more common snake_case (e.g., `model_configs`, `model_name`).

### Main Tables

- **ModelConfigs**: Stores model configurations
  - **ID**: Primary key
  - **ModelName**: Name of the model
  - **ConfigName**: Name of the configuration
  - **Temperature**: Model temperature parameter
  - **TopP**: Top-P parameter
  - **MaxTokens**: Maximum tokens parameter
  - **FrequencyPenalty**: Frequency penalty parameter
  - **PresencePenalty**: Presence penalty parameter
  - **CreatedAt**: Creation timestamp
  - **LastUsed**: Last usage timestamp
  - **IsDefault**: Flag for default configuration

- **Presets**: Stores predefined parameter presets
  - **ID**: Primary key
  - **Name**: Preset name
  - **Description**: Preset description
  - **Temperature**, **TopP**, **MaxTokens**, etc.: Parameter values

- **UserPresets**: Stores user-defined parameter presets
  - Similar structure to Presets

- **UserPreferences**: Stores user preferences
  - **Key**: Preference key
  - **Value**: Preference value
  - **ValueType**: Type of the value for conversion
  - **UpdatedAt**: Last update timestamp

- **AppSettings**: Stores application settings
  - Similar structure to UserPreferences

- **GenerationHistory**: Stores history of text generations
  - **ID**: Primary key
  - **ModelName**: Model used
  - **Prompt**: Input prompt
  - **Response**: Generated response
  - **Temperature**, **TopP**, etc.: Parameters used
  - **InputTokens**, **OutputTokens**, etc.: Metrics
  - **CreatedAt**: Timestamp

- **BenchmarkResults**: Stores benchmark results
  - **ID**: Primary key
  - **BenchmarkName**: Name of the benchmark
  - **ModelName**: Model used
  - **ConfigID**: Reference to configuration
  - **AverageTime**, **AverageTokens**, etc.: Metrics
  - **CreatedAt**: Timestamp

## Using the Database

### Command Line Options

The application provides several database-related command line options:

```
--db PATH               Path to database file
--migrate               Migrate from file config to database
--migrate-schema        Migrate database schema to PascalCase
```

### Basic Usage

1. **First Run with Database**:
   ```
   python Main.py --db OllamaModelEditor.db
   ```
   This creates a new database if it doesn't exist and initializes all tables.

2. **Migrating from File Configuration**:
   ```
   python Main.py --db OllamaModelEditor.db --migrate
   ```
   This migrates your existing file-based configuration to the database.

3. **Migrating Database Schema**:
   ```
   python Main.py --db OllamaModelEditor.db --migrate-schema
   ```
   This migrates an existing database from snake_case to PascalCase schema.

### Migration Scripts

The application includes two migration scripts:

1. **MigrateToDatabase.py**: Migrates configuration from files to database
   ```
   python scripts/MigrateToDatabase.py --config config.yaml --db OllamaModelEditor.db
   ```

2. **MigrateDBToPascalCase.py**: Migrates database schema from snake_case to PascalCase
   ```
   python scripts/MigrateDBToPascalCase.py --db OllamaModelEditor.db --backup
   ```
   The `--backup` flag creates a backup of your database before migration.

## Benefits of the Database Approach

Using a database for configuration storage provides several advantages:

1. **Centralized Storage**: All application data in one place with a proper schema
2. **Better Organization**: Structured storage with relationships between data
3. **Improved Performance**: Faster access to configuration and history
4. **Enhanced Features**: History tracking, benchmarking, and analytics
5. **Better Multi-Model Support**: Easier to manage multiple models and configurations
6. **Simplified Backup**: Single file to back up and restore

## Backwards Compatibility

The application maintains backward compatibility with file-based configuration:

- If no database is specified, the application falls back to file-based configuration
- Configuration can be exported from the database to files
- The application can run with either approach

## For Developers

If you're developing or extending the OllamaModelEditor application, keep these points in mind:

1. **PascalCase Consistency**: All database field references should use PascalCase
2. **SQL Queries**: Ensure all SQL queries use PascalCase column names
3. **DBManager Class**: Use the `DBManager` class for all database interactions
4. **Migration Support**: Maintain support for both file and database configurations
5. **Error Handling**: Implement proper error handling for database operations

### Example Code

```python
# Correct way to interact with the database
ModelConfigs = DB.ExecuteQuery(
    """
    SELECT ModelName, ConfigName, Temperature, TopP, MaxTokens
    FROM ModelConfigs
    WHERE ModelName = ?
    """,
    (ModelName,)
)

# Correct way to update the database
DB.ExecuteNonQuery(
    """
    UPDATE ModelConfigs
    SET LastUsed = CURRENT_TIMESTAMP
    WHERE ModelName = ? AND ConfigName = ?
    """,
    (ModelName, ConfigName)
)
```

## Troubleshooting

### Common Issues

1. **Database Not Found**:
   - Check the path specified with `--db`
   - Ensure the directory exists and is writable

2. **Migration Errors**:
   - Use the `--backup` flag to create a backup before migration
   - Check logs for specific error messages
   - Restore from backup if necessary

3. **Permission Issues**:
   - Ensure you have write permissions for the database file and directory

### Database Inspection

You can inspect the database structure and content using SQLite tools:

```
sqlite3 OllamaModelEditor.db ".schema"  # Show schema
sqlite3 OllamaModelEditor.db "SELECT * FROM ModelConfigs"  # Query data
```

For a graphical interface, we recommend using [DB Browser for SQLite](https://sqlitebrowser.org/).

## Conclusion

The OllamaModelEditor database integration provides a robust foundation for managing model configurations, user preferences, and benchmarking results. By following the AIDEV-PascalCase-1.2 standard, it maintains a consistent visual fingerprint throughout the codebase while offering enhanced functionality and performance.

If you encounter any issues or have questions about the database integration, please refer to the project documentation or open an issue on the project repository.

================
File: docs/Notes/OllamaModelEditor UI and Feature Implementation Plan.md
================
# OllamaModelEditor UI and Feature Implementation Plan

Based on our brainstorming and the original design, here's a comprehensive plan to enhance the OllamaModelEditor application.

## 1. UI Improvements

### Menu and Tab Contrast
- Apply stylesheet to better differentiate the menu bar from tab controls
- Add subtle shadows or borders to create visual hierarchy
- Implement consistent padding and margins for cleaner separation

### Sidebar Behavior
- Fix the sidebar toggle to properly hide/show the sidebar
- Add proper resize handles with visible feedback
- Ensure the sidebar doesn't block the main content when toggled

### Parameter Controls
- Enhance sliders with better visual feedback
- Add parameter guidance information
- Implement preset system with quick-select options
- Add more advanced parameters from the original design

### Overall Styling
- Apply consistent dark theme with proper contrast
- Add visual distinction between interactive and static elements
- Ensure proper spacing between UI elements
- Add visual feedback for interactive elements (hover, click, etc.)

## 2. New Features to Implement

### Parameter Presets
- Pre-defined parameter combinations optimized for different use cases
- User-defined custom presets with save/load functionality
- Preset comparison tool

### Detailed Analysis
- Token-by-token analysis of generated content
- Performance metrics and visualization
- Parameter impact analysis

### Configuration Management
- Export/import parameter configurations
- Version tracking for configurations
- Configuration comparison tools

### Documentation and Help System
- Integrated documentation browser
- Context-sensitive help
- Parameter reference guide with explanations
- Interactive tutorials

### Benchmarking Enhancements
- More detailed metrics
- Visualization of benchmark results
- Configuration comparison
- Export benchmark results

## 3. Immediate Action Items

1. **Fix Sidebar Behavior**
   - Update the dock widget implementation
   - Add proper controls for hiding/showing

2. **Enhance Parameter Controls**
   - Add parameter guidance section
   - Implement preset selector
   - Add visual improvements to sliders

3. **Apply Styling Fixes**
   - Implement consistent stylesheet
   - Fix menu/tab contrast issues
   - Add proper spacing and margins

4. **Add Additional Parameters**
   - Include frequency penalty and presence penalty
   - Add context window settings
   - Include stop sequence configuration

## 4. Technical Implementation Notes

### UI Components
- Use QDockWidget for properly dockable sidebars
- Use QSplitter for resizable panels
- Apply stylesheet consistently across all elements
- Set objectNames for all major components

### Data Flow
- Maintain clear separation between UI and data objects
- Implement proper update mechanisms for parameter changes
- Use signals/slots for UI component communication

### Performance Considerations
- Lazy-load complex UI elements
- Implement background processing for intensive operations
- Add progress indicators for long-running tasks

### Error Handling
- Add robust error handling for API interactions
- Provide clear user feedback for errors
- Implement recovery mechanisms

## 5. Testing Plan

- Test UI on different screen sizes
- Verify all controls function as expected
- Test with both keyboard and mouse navigation
- Verify performance with large models
- Test error scenarios and recovery

================
File: docs/parameter-editor.py
================
# File: ParameterEditor.py
# Path: OllamaModelEditor/GUI/Components/ParameterEditor.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-12 15:00PM
# Description: Parameter editing component for the OllamaModelEditor application

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QGridLayout, QSlider, QSpinBox, 
    QDoubleSpinBox, QHBoxLayout, QComboBox, QPushButton, QFrame,
    QFormLayout, QMessageBox, QDialog, QDialogButtonBox, QLineEdit,
    QTextEdit, QGroupBox
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QFont

from typing import Dict, Any, Optional, List

class ParameterEditor(QWidget):
    """Widget for editing model parameters."""
    
    # Signal emitted when parameters are updated
    ParametersUpdated = Signal(dict)
    
    def __init__(self, ModelManager, Config):
        """
        Initialize the parameter editor.
        
        Args:
            ModelManager: Model manager instance
            Config: Configuration manager instance
        """
        super().__init__()
        
        # Store references
        self.ModelManager = ModelManager
        self.Config = Config
        self.DB = getattr(Config, 'DB', None)
        self.CurrentModel = None
        self.Parameters = {}
        self.ParameterControls = {}
        
        # Set up UI
        self._SetupUI()
    
    def _SetupUI(self):
        """Set up the user interface."""
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add header layout
        HeaderLayout = QHBoxLayout()
        
        # Add header label
        HeaderLabel = QLabel("Model Parameters")
        HeaderLabel.setStyleSheet("font-weight: bold; font-size: 14px;")
        HeaderLayout.addWidget(HeaderLabel)
        
        # Add stretch to push preset controls to right
        HeaderLayout.addStretch()
        
        # Add preset selector
        PresetLabel = QLabel("Preset:")
        HeaderLayout.addWidget(PresetLabel)
        
        self.PresetCombo = QComboBox()
        self.PresetCombo.currentTextChanged.connect(self._OnPresetSelected)
        HeaderLayout.addWidget(self.PresetCombo)
        
        self.SavePresetButton = QPushButton("Save Preset")
        self.SavePresetButton.clicked.connect(self._OnSavePreset)
        HeaderLayout.addWidget(self.SavePresetButton)
        
        Layout.addLayout(HeaderLayout)
        
        # Add separator line
        Separator = QFrame()
        Separator.setFrameShape(QFrame.HLine)
        Separator.setFrameShadow(QFrame.Sunken)
        Layout.addWidget(Separator)
        
        # Create parameters frame with scrolling
        self.ParametersFrame = QFrame()
        
        # Create parameters layout
        self.ParametersLayout = QFormLayout(self.ParametersFrame)
        self.ParametersLayout.setVerticalSpacing(12)
        self.ParametersLayout.setFieldGrowthPolicy(QFormLayout.AllNonFixedFieldsGrow)
        
        # Add placeholder message
        self.PlaceholderLabel = QLabel("Select a model to edit parameters")
        self.PlaceholderLabel.setAlignment(Qt.AlignCenter)
        self.ParametersLayout.addRow(self.PlaceholderLabel)
        
        Layout.addWidget(self.ParametersFrame)
        
        # Create parameter description section
        DescriptionFrame = QFrame()
        DescriptionLayout = QVBoxLayout(DescriptionFrame)
        
        DescriptionLabel = QLabel("Parameter Description")
        DescriptionLabel.setStyleSheet("font-weight: bold;")
        DescriptionLayout.addWidget(DescriptionLabel)
        
        self.DescriptionText = QTextEdit()
        self.DescriptionText.setReadOnly(True)
        self.DescriptionText.setMaximumHeight(100)
        self.DescriptionText.setPlaceholderText("Select a parameter to see its description")
        DescriptionLayout.addWidget(self.DescriptionText)
        
        Layout.addWidget(DescriptionFrame)
        
        # Add buttons layout
        ButtonsLayout = QHBoxLayout()
        
        self.ApplyButton = QPushButton("Apply Changes")
        self.ApplyButton.clicked.connect(self._OnApplyChanges)
        self.ApplyButton.setEnabled(False)
        ButtonsLayout.addWidget(self.ApplyButton)
        
        self.ResetButton = QPushButton("Reset to Default")
        self.ResetButton.clicked.connect(self._OnResetToDefault)
        self.ResetButton.setEnabled(False)
        ButtonsLayout.addWidget(self.ResetButton)
        
        Layout.addLayout(ButtonsLayout)
        
        # Load presets
        self._LoadPresets()
    
    def _LoadPresets(self):
        """Load parameter presets."""
        # Clear combo box
        self.PresetCombo.clear()
        
        # Add standard presets
        self.PresetCombo.addItem("Custom")
        
        # Add standard presets from database or fallback to hardcoded
        if self.DB:
            # Load presets from database
            try:
                Presets = self.DB.GetPresets()
                for Preset in Presets:
                    self.PresetCombo.addItem(Preset["Name"])
            except Exception as Error:
                print(f"Error loading presets from database: {Error}")
                # Fall back to hardcoded presets
                self._AddHardcodedPresets()
        else:
            # Use hardcoded presets
            self._AddHardcodedPresets()
        
        # Add user presets
        try:
            if self.DB:
                UserPresets = self.ModelManager.GetUserPresets()
                if UserPresets:
                    # Add separator
                    self.PresetCombo.insertSeparator(self.PresetCombo.count())
                    
                    # Add user presets
                    for Preset in UserPresets:
                        self.PresetCombo.addItem(Preset["Name"] + " (User)")
        except Exception as Error:
            print(f"Error loading user presets: {Error}")
    
    def _AddHardcodedPresets(self):
        """Add hardcoded presets to combo box."""
        StandardPresets = ["Default", "Creative", "Precise", "Fast", "Balanced", "Deterministic"]
        for Preset in StandardPresets:
            self.PresetCombo.addItem(Preset)
    
    def LoadModel(self, ModelName):
        """
        Load a model for editing.
        
        Args:
            ModelName: Name of the model to load
        """
        # Store current model
        self.CurrentModel = ModelName
        
        # Hide placeholder
        self.PlaceholderLabel.setVisible(False)
        
        # Clear parameters layout
        self._ClearParametersLayout()
        
        # Get model parameters
        self.Parameters = self.Config.GetModelConfig(ModelName)
        
        # Enable buttons
        self.ApplyButton.setEnabled(True)
        self.ResetButton.setEnabled(True)
        
        # Get parameter definitions from database or fallback to hardcoded
        if self.DB:
            try:
                # Get parameter definitions from database
                ParameterDefs = self.DB.GetAllParameters()
                
                # Add parameter controls based on definitions
                if ParameterDefs:
                    for Param in ParameterDefs:
                        self._AddParameterControl(
                            Param["Name"],
                            Param["DisplayName"],
                            self.Parameters.get(Param["Name"], Param["DefaultValue"]),
                            Param["MinValue"],
                            Param["MaxValue"],
                            Param["StepSize"],
                            Param["IsInteger"],
                            Param["Description"]
                        )
                else:
                    # Fallback to hardcoded parameters
                    self._AddHardcodedParameters()
            except Exception as Error:
                print(f"Error loading parameter definitions: {Error}")
                # Fallback to hardcoded parameters
                self._AddHardcodedParameters()
        else:
            # Use hardcoded parameters
            self._AddHardcodedParameters()
    
    def _ClearParametersLayout(self):
        """Clear all parameter controls from layout."""
        # Clear parameter controls dictionary
        self.ParameterControls = {}
        
        # Remove all items from layout
        while self.ParametersLayout.count():
            Item = self.ParametersLayout.takeAt(0)
            if Item.widget():
                Item.widget().deleteLater()
    
    def _AddHardcodedParameters(self):
        """Add hardcoded parameter controls."""
        # Add basic parameters
        self._AddParameterControl(
            "Temperature",
            "Temperature",
            self.Parameters.get("Temperature", 0.7),
            0.0, 2.0, 0.1, False,
            "Controls randomness in text generation. Higher values (0.7-1.0) produce more creative outputs, "
            "while lower values (0.2-0.5) make output more focused and deterministic."
        )
        
        self._AddParameterControl(
            "TopP",
            "Top-P",
            self.Parameters.get("TopP", 0.9),
            0.0, 1.0, 0.01, False,
            "Controls diversity via nucleus sampling. Lower values make output more focused on likely tokens. "
            "0.9 is a good starting point."
        )
        
        self._AddParameterControl(
            "MaxTokens",
            "Max Tokens",
            self.Parameters.get("MaxTokens", 2048),
            1, 32000, 1, True,
            "The maximum length of the generated text. Higher values allow for longer responses "
            "but consume more resources."
        )
        
        # Add advanced parameters
        AdvancedGroup = QGroupBox("Advanced Parameters")
        AdvancedLayout = QFormLayout(AdvancedGroup)
        
        # Frequency penalty control
        FreqPenaltyLayout = QHBoxLayout()
        FreqPenaltySlider = QSlider(Qt.Horizontal)
        FreqPenaltySlider.setMinimum(0)
        FreqPenaltySlider.setMaximum(200)
        FreqPenaltySlider.setValue(int(self.Parameters.get("FrequencyPenalty",

================
File: docs/ProjectStructure.txt
================
OllamaModelEditor/
├── .github/
│   ├── workflows/
│   │   ├── ci.yml                    # Continuous Integration workflow
│   │   └── release.yml               # Release automation
│   ├── ISSUE_TEMPLATE/
│   │   ├── bug_report.md
│   │   └── feature_request.md
│   └── PULL_REQUEST_TEMPLATE.md
├── .gitignore
├── Core/
│   ├── __init__.py
│   ├── ConfigManager.py              # Configuration management
│   ├── ModelManager.py               # Ollama model operations
│   ├── ParameterManager.py           # Model parameter handling
│   ├── BenchmarkManager.py           # Performance testing
│   ├── LoggingUtils.py               # Centralized logging
│   └── README.md                     # Core components documentation
├── GUI/
│   ├── __init__.py
│   ├── Assets/
│   │   ├── icons/
│   │   ├── themes/
│   │   └── fonts/
│   ├── Components/
│   │   ├── __init__.py
│   │   ├── ModelSelector.py          # Model selection widget
│   │   ├── ParameterEditor.py        # Parameter editing interface
│   │   ├── BenchmarkView.py          # Performance comparison view
│   │   └── ConfigExporter.py         # Config export functionality
│   ├── Dialogs/
│   │   ├── __init__.py
│   │   ├── SettingsDialog.py         # Application settings
│   │   └── AboutDialog.py            # About information
│   ├── Windows/
│   │   ├── __init__.py
│   │   ├── MainWindow.py             # Main application window
│   │   └── SplashScreen.py           # Application splash screen
│   └── ThemeManager.py               # Application theming
├── Tests/
│   ├── __init__.py
│   ├── UnitTests/
│   │   ├── __init__.py
│   │   ├── TestConfigManager.py
│   │   ├── TestModelManager.py
│   │   └── TestParameterManager.py
│   ├── IntegrationTests/
│   │   ├── __init__.py
│   │   └── TestModelWorkflow.py
│   └── UITests/
│       ├── __init__.py
│       └── TestMainWindow.py
├── Utils/
│   ├── __init__.py
│   ├── OllamaUtils.py                # Ollama-specific utilities
│   ├── ValidationUtils.py            # Input validation helpers
│   └── FileUtils.py                  # File operations helpers
├── Features/
│   ├── __init__.py
│   ├── ChatIntegration.py            # Chat functionality
│   ├── SecurityMonitor.py            # Security monitoring
│   ├── TextToSpeech.py               # TTL functionality
│   ├── VoiceRecognition.py           # Voice recognition
│   └── RAGSupport.py                 # Retrieval Augmented Generation
├── docs/
│   ├── QuickStartGuide.md            # Getting started guide
│   ├── parameters.md                 # Parameter reference
│   ├── advanced_usage.md             # Advanced usage guide
│   └── screenshots/                  # Application screenshots
├── scripts/
│   ├── Setup.sh                      # Environment setup script
│   ├── Setup.bat                     # Windows setup script
│   └── UpdateDependencies.py         # Dependency update utility
├── .env.example                      # Example environment variables
├── LICENSE                           # MIT License
├── Main.py                           # Application entry point
├── README.md                         # Project README
├── requirements.txt                  # Python dependencies
└── pyproject.toml                    # Project metadata

================
File: GUI/Components/__init__.py
================
# File: __init__.py
# Path: OllamaModelEditor/GUI/Components/__init__.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Package initialization for GUI components

# This file is intentionally left empty to mark this directory as a Python package

================
File: GUI/Components/BenchmarkView.py
================
# File: BenchmarkView.py
# Path: OllamaModelEditor/GUI/Components/BenchmarkView.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-13
# Description: Enhanced benchmarking component with state tracking for the OllamaModelEditor application

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit, QPushButton, 
    QFormLayout, QSpinBox, QCheckBox, QTabWidget, QApplication, QFileDialog,
    QFrame, QGridLayout, QMessageBox, QComboBox, QTableWidget, QTableWidgetItem,
    QHeaderView, QDialog, QDialogButtonBox, QGroupBox
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QIcon, QFont, QColor
import json
import time
from datetime import datetime
from typing import Dict, Any, List, Optional

class ModelStateDialog(QDialog):
    """Dialog to show model state during benchmarking."""
    
    def __init__(self, ModelName, StateManager, Parent=None):
        """
        Initialize the model state dialog.
        
        Args:
            ModelName: Name of the model
            StateManager: Parameter state manager instance
            Parent: Parent widget
        """
        super().__init__(Parent)
        
        self.ModelName = ModelName
        self.StateManager = StateManager
        
        self.setWindowTitle(f"Model State - {ModelName}")
        self.setMinimumWidth(500)
        self.setMinimumHeight(400)
        
        self._SetupUI()
    
    def _SetupUI(self):
        """Set up the dialog UI."""
        Layout = QVBoxLayout(self)
        
        # Add state information
        StateLabel = QLabel(f"Current state for model: <b>{self.ModelName}</b>")
        Layout.addWidget(StateLabel)
        
        # Add state table
        self.StateTable = QTableWidget(0, 3)
        self.StateTable.setHorizontalHeaderLabels(["Parameter", "Original Value", "Current Value"])
        self.StateTable.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.StateTable.verticalHeader().setVisible(False)
        Layout.addWidget(self.StateTable)
        
        # Update state table
        self._UpdateStateTable()
        
        # Add button box
        ButtonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        ButtonBox.accepted.connect(self.accept)
        Layout.addWidget(ButtonBox)
    
    def _UpdateStateTable(self):
        """Update the state changes table."""
        # Get state differences
        Differences = self.StateManager.GetStateDifferences(self.ModelName)
        
        # Get all parameters
        AllParams = self.StateManager.GetAllModelParameters(self.ModelName)
        
        # Clear table
        self.StateTable.setRowCount(0)
        
        # Add all parameters to table
        Row = 0
        for Param, Value in AllParams.items():
            self.StateTable.insertRow(Row)
            
            # Add parameter name
            ParamItem = QTableWidgetItem(Param)
            ParamItem.setFlags(ParamItem.flags() & ~Qt.ItemIsEditable)
            self.StateTable.setItem(Row, 0, ParamItem)
            
            # Get original and current values
            OrigValue = self.StateManager.OriginalStates.get(self.ModelName, {}).get(Param, Value)
            CurrValue = self.StateManager.CurrentStates.get(self.ModelName, {}).get(Param, Value)
            
            # Add original value
            OrigItem = QTableWidgetItem(str(OrigValue))
            OrigItem.setFlags(OrigItem.flags() & ~Qt.ItemIsEditable)
            self.StateTable.setItem(Row, 1, OrigItem)
            
            # Add current value
            CurrItem = QTableWidgetItem(str(CurrValue))
            CurrItem.setFlags(CurrItem.flags() & ~Qt.ItemIsEditable)
            
            # Highlight if different from original
            if Param in Differences:
                CurrItem.setBackground(QColor(255, 255, 0, 100))  # Light yellow highlight
            
            self.StateTable.setItem(Row, 2, CurrItem)
            
            Row += 1

class BenchmarkView(QWidget):
    """Widget for benchmarking models with state tracking."""
    
    def __init__(self, ModelManager, Config, StateManager):
        """
        Initialize the benchmark view.
        
        Args:
            ModelManager: Model manager instance
            Config: Configuration manager instance
            StateManager: Parameter state manager instance
        """
        super().__init__()
        
        # Store references
        self.ModelManager = ModelManager
        self.Config = Config
        self.StateManager = StateManager
        
        # Current benchmark results
        self.CurrentResults = None
        
        # Running benchmark flag
        self.IsRunning = False
        
        # Set up UI
        self._SetupUI()
    
    def _SetupUI(self):
        """Set up the user interface."""
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add header label
        HeaderLabel = QLabel("Model Benchmark")
        HeaderLabel.setStyleSheet("font-weight: bold; font-size: 14px; margin-bottom: 10px;")
        Layout.addWidget(HeaderLabel)
        
        # Add description
        DescriptionLabel = QLabel(
            "Compare model performance with different configurations. "
            "Enter sample prompts below to test how the model responds with current settings."
        )
        DescriptionLabel.setWordWrap(True)
        Layout.addWidget(DescriptionLabel)
        
        # Add benchmark configuration section
        ConfigFrame = QFrame()
        ConfigFrame.setFrameShape(QFrame.StyledPanel)
        ConfigLayout = QFormLayout(ConfigFrame)
        
        # Add model state view button
        self.ViewStateButton = QPushButton("View Current Model State")
        self.ViewStateButton.clicked.connect(self._OnViewModelState)
        ConfigLayout.addRow(self.ViewStateButton)
        
        # Add benchmark type selector
        BenchmarkTypeLayout = QHBoxLayout()
        BenchmarkTypeLabel = QLabel("Benchmark Type:")
        self.BenchmarkTypeCombo = QComboBox()
        self.BenchmarkTypeCombo.addItems(["Standard", "Comparison", "Stress Test"])
        self.BenchmarkTypeCombo.currentTextChanged.connect(self._OnBenchmarkTypeChanged)
        BenchmarkTypeLayout.addWidget(BenchmarkTypeLabel)
        BenchmarkTypeLayout.addWidget(self.BenchmarkTypeCombo)
        ConfigLayout.addRow(BenchmarkTypeLayout)
        
        # Add model comparison selector
        self.CompareCheckbox = QCheckBox("Compare with another configuration")
        self.CompareCheckbox.toggled.connect(self._OnCompareToggled)
        ConfigLayout.addRow(self.CompareCheckbox)
        
        # Add comparison config selector (initially hidden)
        self.ComparisonConfigLayout = QHBoxLayout()
        self.ComparisonConfigLabel = QLabel("Comparison config:")
        self.ComparisonConfigLabel.setEnabled(False)
        self.ComparisonConfigCombo = QComboBox()
        self.ComparisonConfigCombo.setEnabled(False)
        self.ComparisonConfigCombo.addItems(["Default", "Creative", "Precise", "Fast", "Custom..."])
        self.ComparisonConfigLayout.addWidget(self.ComparisonConfigLabel)
        self.ComparisonConfigLayout.addWidget(self.ComparisonConfigCombo, 1)
        ConfigLayout.addRow(self.ComparisonConfigLayout)
        
        # Add repetition control
        RepetitionLayout = QHBoxLayout()
        self.RepetitionLabel = QLabel("Repetitions:")
        self.RepetitionSpinner = QSpinBox()
        self.RepetitionSpinner.setMinimum(1)
        self.RepetitionSpinner.setMaximum(10)
        self.RepetitionSpinner.setValue(3)
        self.RepetitionSpinner.setToolTip("Number of times to run each prompt for more accurate benchmarking")
        RepetitionLayout.addWidget(self.RepetitionLabel)
        RepetitionLayout.addWidget(self.RepetitionSpinner)
        RepetitionLayout.addStretch()
        ConfigLayout.addRow(RepetitionLayout)
        
        Layout.addWidget(ConfigFrame)
        
        # Add prompt input
        PromptLabel = QLabel("Enter benchmark prompts (one per line):")
        Layout.addWidget(PromptLabel)
        
        self.PromptsText = QTextEdit()
        self.PromptsText.setPlaceholderText("Enter benchmark prompts here...\n\nExample:\nSummarize the key features of neural networks.\nExplain the difference between supervised and unsupervised learning.\nWrite a short poem about artificial intelligence.")
        self.PromptsText.setMinimumHeight(100)
        Layout.addWidget(self.PromptsText)
        
        # Add buttons
        ButtonLayout = QHBoxLayout()
        
        self.RunButton = QPushButton("Run Benchmark")
        self.RunButton.setIcon(QIcon.fromTheme("media-playback-start"))
        self.RunButton.clicked.connect(self._OnRunBenchmark)
        ButtonLayout.addWidget(self.RunButton)
        
        self.StopButton = QPushButton("Stop")
        self.StopButton.setIcon(QIcon.fromTheme("media-playback-stop"))
        self.StopButton.clicked.connect(self._OnStopBenchmark)
        self.StopButton.setEnabled(False)
        ButtonLayout.addWidget(self.StopButton)
        
        self.SaveButton = QPushButton("Save Results")
        self.SaveButton.setIcon(QIcon.fromTheme("document-save"))
        self.SaveButton.clicked.connect(self._OnSaveResults)
        self.SaveButton.setEnabled(False)
        ButtonLayout.addWidget(self.SaveButton)
        
        Layout.addLayout(ButtonLayout)
        
        # Add results display with tabs
        self.ResultsTabs = QTabWidget()
        
        # Summary tab
        self.SummaryTab = QWidget()
        SummaryLayout = QVBoxLayout(self.SummaryTab)
        
        self.SummaryText = QTextEdit()
        self.SummaryText.setReadOnly(True)
        SummaryLayout.addWidget(self.SummaryText)
        
        # Charts tab
        self.ChartsTab = QWidget()
        ChartsLayout = QVBoxLayout(self.ChartsTab)
        
        self.ChartPlaceholder = QLabel("Charts will appear here after running benchmarks")
        self.ChartPlaceholder.setAlignment(Qt.AlignCenter)
        ChartsLayout.addWidget(self.ChartPlaceholder)
        
        # Detailed results tab
        self.DetailsTab = QWidget()
        DetailsLayout = QVBoxLayout(self.DetailsTab)
        
        self.DetailsText = QTextEdit()
        self.DetailsText.setReadOnly(True)
        DetailsLayout.addWidget(self.DetailsText)
        
        # Add tabs to tab widget
        self.ResultsTabs.addTab(self.SummaryTab, "Summary")
        self.ResultsTabs.addTab(self.ChartsTab, "Charts")
        self.ResultsTabs.addTab(self.DetailsTab, "Details")
        
        Layout.addWidget(self.ResultsTabs)
    
    def _OnBenchmarkTypeChanged(self, BenchmarkType):
        """
        Handle benchmark type change.
        
        Args:
            BenchmarkType: Selected benchmark type
        """
        # Enable/disable controls based on benchmark type
        if BenchmarkType == "Comparison":
            self.CompareCheckbox.setChecked(True)
            self.CompareCheckbox.setEnabled(False)
        elif BenchmarkType == "Stress Test":
            self.CompareCheckbox.setChecked(False)
            self.CompareCheckbox.setEnabled(False)
            
            # TODO: Add stress test specific controls
        else:  # Standard
            self.CompareCheckbox.setEnabled(True)
    
    def _OnViewModelState(self):
        """Handle view model state button click."""
        # Get current model
        CurrentModel = self.ModelManager.GetCurrentModel()
        if not CurrentModel:
            QMessageBox.warning(
                self,
                "No Model Selected",
                "Please select a model first."
            )
            return
        
        ModelName = CurrentModel.get('name')
        
        # Show model state dialog
        Dialog = ModelStateDialog(ModelName, self.StateManager, self)
        Dialog.exec()
    
    def _OnCompareToggled(self, Checked):
        """
        Handle compare checkbox toggle.
        
        Args:
            Checked: Whether the checkbox is checked
        """
        self.ComparisonConfigLabel.setEnabled(Checked)
        self.ComparisonConfigCombo.setEnabled(Checked)
    
    def _OnRunBenchmark(self):
        """Handle run benchmark button click."""
        # Get prompts
        PromptText = self.PromptsText.toPlainText()
        Prompts = [p.strip() for p in PromptText.split('\n') if p.strip()]
        
        if not Prompts:
            self.SummaryText.setText("Please enter at least one prompt.")
            return
        
        # Get current model
        CurrentModel = self.ModelManager.GetCurrentModel()
        if not CurrentModel:
            self.SummaryText.setText("Please select a model first.")
            return
        
        ModelName = CurrentModel.get('name')
        
        # Get benchmark repetitions
        Repetitions = self.RepetitionSpinner.value()
        
        # Get benchmark type
        BenchmarkType = self.BenchmarkTypeCombo.currentText()
        
        # Check if comparing configurations
        ComparisonConfig = None
        if BenchmarkType == "Comparison" or self.CompareCheckbox.isChecked():
            ComparisonConfigName = self.ComparisonConfigCombo.currentText()
            
            # Get configuration parameters
            if ComparisonConfigName == "Custom...":
                # TODO: Implement custom configuration dialog
                QMessageBox.information(
                    self,
                    "Not Implemented",
                    "Custom comparison configuration is not yet implemented."
                )
                return
            elif ComparisonConfigName in ["Default", "Creative", "Precise", "Fast"]:
                # Use built-in preset
                ComparisonConfig = self.ModelManager.GetPresetParameters(ComparisonConfigName)
        
        # Get current parameter state for reference
        CurrentState = self.StateManager.CurrentStates.get(ModelName, {})
        
        # Disable run button and enable stop button
        self.RunButton.setEnabled(False)
        self.StopButton.setEnabled(True)
        self.IsRunning = True
        
        # Update status
        self.SummaryText.setText(f"Running benchmark for {ModelName}...\n")
        self.SummaryText.append(f"Using the following parameters:\n")
        for Param, Value in CurrentState.items():
            self.SummaryText.append(f"  • {Param}: {Value}")
        self.SummaryText.append("\n")
        QApplication.processEvents()
        
        # Run benchmark
        Results = self.ModelManager.BenchmarkModel(ModelName, Prompts, Runs=Repetitions)
        
        # Set model state information in results
        Results["model_state"] = {
            "original": self.StateManager.OriginalStates.get(ModelName, {}),
            "current": CurrentState
        }
        
        # If comparing, run benchmark with comparison configuration
        if ComparisonConfig:
            self.SummaryText.append(f"Running comparison benchmark with {ComparisonConfigName} configuration...\n")
            self.SummaryText.append(f"Using the following parameters:\n")
            for Param, Value in ComparisonConfig.items():
                self.SummaryText.append(f"  • {Param}: {Value}")
            self.SummaryText.append("\n")
            QApplication.processEvents()
            
            ComparisonResults = self.ModelManager.BenchmarkModel(
                ModelName, 
                Prompts, 
                Parameters=ComparisonConfig,
                Runs=Repetitions
            )
            
            # Add comparison results
            Results["comparison"] = ComparisonResults
            Results["comparison_config_name"] = ComparisonConfigName
        
        # For stress test, add additional metrics
        if BenchmarkType == "Stress Test":
            # TODO: Implement stress test specific metrics
            pass
        
        # Enable run button and disable stop button
        self.RunButton.setEnabled(True)
        self.StopButton.setEnabled(False)
        self.IsRunning = False
        
        if "error" in Results:
            self.SummaryText.setText(f"Error running benchmark: {Results['error']}")
            return
        
        # Store current results
        self.CurrentResults = Results
        
        # Display summary results
        self._DisplayBenchmarkSummary(Results)
        
        # Create charts
        self._CreateBenchmarkCharts(Results)
        
        # Display detailed results
        self._DisplayBenchmarkDetails(Results)
        
        # Enable save button
        self.SaveButton.setEnabled(True)
    
    def _OnStopBenchmark(self):
        """Handle stop benchmark button click."""
        # Set flag to stop benchmark
        self.IsRunning = False
        
        # Update status
        self.SummaryText.append("Stopping benchmark...\n")
        
        # Enable run button and disable stop button
        self.RunButton.setEnabled(True)
        self.StopButton.setEnabled(False)
    
    def _DisplayBenchmarkSummary(self, Results):
        """
        Display benchmark summary.
        
        Args:
            Results: Benchmark results
        """
        Summary = Results.get('summary', {})
        Model = Results.get('model', 'Unknown')
        Parameters = Results.get('parameters', {})
        ModelState = Results.get('model_state', {})
        
        SummaryText = f"<h2>Benchmark Results for {Model}</h2>\n"
        
        # Add benchmark type
        BenchmarkType = self.BenchmarkTypeCombo.currentText()
        SummaryText += f"<p><b>Benchmark Type:</b> {BenchmarkType}</p>\n"
        
        # Add model state information
        SummaryText += "<h3>Model Parameters</h3>\n"
        
        # Create table for parameters with highlighting for changed values
        SummaryText += "<table border='1' cellpadding='4' cellspacing='0' style='border-collapse: collapse;'>\n"
        SummaryText += "<tr><th>Parameter</th><th>Original Value</th><th>Benchmark Value</th></tr>\n"
        
        # Get parameter differences
        OriginalState = ModelState.get('original', {})
        CurrentState = ModelState.get('current', {})
        
        # Show all parameters used in the benchmark
        for Param, Value in Parameters.items():
            OrigValue = OriginalState.get(Param, Value)
            
            # Check if value is different from original
            IsDifferent = OrigValue != Value
            
            # Create row with highlighting if different
            if IsDifferent:
                SummaryText += f"<tr><td>{Param}</td><td>{OrigValue}</td><td style='background-color: #FFFF99;'>{Value}</td></tr>\n"
            else:
                SummaryText += f"<tr><td>{Param}</td><td>{OrigValue}</td><td>{Value}</td></tr>\n"
        
        SummaryText += "</table>\n"
        
        # Add summary statistics
        SummaryText += "<h3>Summary Statistics</h3>\n<ul>"
        SummaryText += f"<li><b>Total Tests:</b> {Summary.get('total_tests', 0)}</li>"
        SummaryText += f"<li><b>Total Tokens:</b> {Summary.get('total_tokens', 0)}</li>"
        SummaryText += f"<li><b>Total Time:</b> {Summary.get('total_time', 0):.2f} seconds</li>"
        SummaryText += f"<li><b>Average Tokens/Second:</b> {Summary.get('average_tokens_per_second', 0):.2f}</li>"
        SummaryText += f"<li><b>Average Time/Test:</b> {Summary.get('average_time_per_test', 0):.2f} seconds</li>"
        SummaryText += f"<li><b>Benchmark Date:</b> {Summary.get('benchmark_date', 'Unknown')}</li>"
        SummaryText += "</ul>\n"
        
        # Add comparison results if available
        if "comparison" in Results:
            ComparisonResults = Results["comparison"]
            ComparisonSummary = ComparisonResults.get('summary', {})
            ComparisonParameters = ComparisonResults.get('parameters', {})
            ComparisonConfigName = Results.get('comparison_config_name', "Alternative Configuration")
            
            SummaryText += f"<h3>Comparison Configuration ({ComparisonConfigName})</h3>\n"
            
            # Create table for comparison parameters
            SummaryText += "<table border='1' cellpadding='4' cellspacing='0' style='border-collapse: collapse;'>\n"
            SummaryText += "<tr><th>Parameter</th><th>Original Value</th><th>Comparison Value</th></tr>\n"
            
            # Show all parameters used in the comparison benchmark
            for Param, Value in ComparisonParameters.items():
                OrigValue = Parameters.get(Param, Value)
                
                # Check if value is different from original benchmark
                IsDifferent = OrigValue != Value
                
                # Create row with highlighting if different
                if IsDifferent:
                    SummaryText += f"<tr><td>{Param}</td><td>{OrigValue}</td><td style='background-color: #FFFF99;'>{Value}</td></tr>\n"
                else:
                    SummaryText += f"<tr><td>{Param}</td><td>{OrigValue}</td><td>{Value}</td></tr>\n"
            
            SummaryText += "</table>\n"
            
            SummaryText += "<h3>Comparison Summary Statistics</h3>\n<ul>"
            SummaryText += f"<li><b>Total Tokens:</b> {ComparisonSummary.get('total_tokens', 0)}</li>"
            SummaryText += f"<li><b>Total Time:</b> {ComparisonSummary.get('total_time', 0):.2f} seconds</li>"
            SummaryText += f"<li><b>Average Tokens/Second:</b> {ComparisonSummary.get('average_tokens_per_second', 0):.2f}</li>"
            SummaryText += f"<li><b>Average Time/Test:</b> {ComparisonSummary.get('average_time_per_test', 0):.2f} seconds</li>"
            SummaryText += "</ul>\n"
            
            # Add performance comparison
            BaseTokensPerSecond = Summary.get('average_tokens_per_second', 0)
            CompTokensPerSecond = ComparisonSummary.get('average_tokens_per_second', 0)
            
            if BaseTokensPerSecond > 0 and CompTokensPerSecond > 0:
                Difference = ((CompTokensPerSecond - BaseTokensPerSecond) / BaseTokensPerSecond) * 100
                SummaryText += "<h3>Performance Comparison</h3>\n"
                if Difference > 0:
                    SummaryText += f"<p>The comparison configuration is <span style='color:green;'><b>{Difference:.2f}%</b> faster</span> than the base configuration.</p>\n"
                elif Difference < 0:
                    SummaryText += f"<p>The comparison configuration is <span style='color:red;'><b>{-Difference:.2f}%</b> slower</span> than the base configuration.</p>\n"
                else:
                    SummaryText += "<p>The comparison configuration has the same performance as the base configuration.</p>\n"
        
        # Update summary tab
        self.SummaryText.setHtml(SummaryText)
    
    def _CreateBenchmarkCharts(self, Results):
        """
        Create benchmark charts.
        
        Args:
            Results: Benchmark results
        """
        Tests = Results.get('tests', [])
        
        if not Tests:
            return
        
        # Clear charts tab
        self.ChartPlaceholder.setVisible(False)
        
        # Create a layout for the charts if it doesn't exist
        if not hasattr(self, 'ChartsLayout'):
            self.ChartsLayout = QVBoxLayout(self.ChartsTab)
        else:
            # Clear existing layout
            while self.ChartsLayout.count():
                Item = self.ChartsLayout.takeAt(0)
                if Item.widget():
                    Item.widget().deleteLater()
        
        # Create charts
        # This is a placeholder - in a real implementation, we would use a charting library
        # For now, we'll create a text-based chart
        ChartText = QTextEdit()
        ChartText.setReadOnly(True)
        
        ChartContent = "<h3>Tokens Per Second by Prompt</h3>\n"
        ChartContent += "<pre>\n"
        
        # Find max value for scaling
        MaxTokensPerSecond = max(test.get('tokens_per_second', 0) for test in Tests)
        ScaleFactor = 50 / (MaxTokensPerSecond if MaxTokensPerSecond > 0 else 1)
        
        for i, Test in enumerate(Tests):
            TokensPerSecond = Test.get('tokens_per_second', 0)
            BarLength = int(TokensPerSecond * ScaleFactor)
            Bar = "█" * BarLength
            
            ChartContent += f"Prompt {i+1}: {Bar} {TokensPerSecond:.2f} tokens/s\n"
        
        ChartContent += "</pre>\n"
        
        # Add comparison chart if available
        if "comparison" in Results:
            ComparisonResults = Results["comparison"]
            ComparisonTests = ComparisonResults.get('tests', [])
            
            if ComparisonTests:
                ChartContent += "<h3>Comparison: Tokens Per Second by Prompt</h3>\n"
                ChartContent += "<pre>\n"
                
                # Find max value for scaling
                CompMaxTokensPerSecond = max(test.get('tokens_per_second', 0) for test in ComparisonTests)
                MaxValue = max(MaxTokensPerSecond, CompMaxTokensPerSecond)
                CompScaleFactor = 50 / (MaxValue if MaxValue > 0 else 1)
                
                for i, Test in enumerate(ComparisonTests):
                    TokensPerSecond = Test.get('tokens_per_second', 0)
                    BarLength = int(TokensPerSecond * CompScaleFactor)
                    Bar = "█" * BarLength
                    
                    ChartContent += f"Prompt {i+1}: {Bar} {TokensPerSecond:.2f} tokens/s\n"
                
                ChartContent += "</pre>\n"
        
        ChartText.setHtml(ChartContent)
        self.ChartsLayout.addWidget(ChartText)
    
    def _DisplayBenchmarkDetails(self, Results):
        """
        Display detailed benchmark results.
        
        Args:
            Results: Benchmark results
        """
        Tests = Results.get('tests', [])
        
        if not Tests:
            return
        
        DetailsText = "<h3>Detailed Test Results</h3>\n"
        
        for i, Test in enumerate(Tests):
            DetailsText += f"<h4>Prompt {i+1}</h4>\n"
            DetailsText += f"<p><b>Prompt:</b> {Test.get('prompt', 'Unknown')}</p>\n"
            DetailsText += "<ul>\n"
            DetailsText += f"<li><b>Average Time:</b> {Test.get('average_time', 0):.2f} seconds</li>"
            DetailsText += f"<li><b>Average Tokens:</b> {Test.get('average_tokens', 0):.2f}</li>"
            DetailsText += f"<li><b>Average Output Tokens:</b> {Test.get('average_output_tokens', 0):.2f}</li>"
            DetailsText += f"<li><b>Tokens Per Second:</b> {Test.get('tokens_per_second', 0):.2f}</li>"
            DetailsText += f"<li><b>Successful Runs:</b> {Test.get('successful_runs', 0)}</li>"
            DetailsText += "</ul>\n"
        
        # Add comparison details if available
        if "comparison" in Results:
            ComparisonResults = Results["comparison"]
            ComparisonTests = ComparisonResults.get('tests', [])
            ComparisonConfigName = Results.get('comparison_config_name', "Alternative Configuration")
            
            if ComparisonTests:
                DetailsText += f"<h3>Comparison Detailed Results ({ComparisonConfigName})</h3>\n"
                
                for i, Test in enumerate(ComparisonTests):
                    DetailsText += f"<h4>Prompt {i+1}</h4>\n"
                    DetailsText += f"<p><b>Prompt:</b> {Test.get('prompt', 'Unknown')}</p>\n"
                    DetailsText += "<ul>\n"
                    DetailsText += f"<li><b>Average Time:</b> {Test.get('average_time', 0):.2f} seconds</li>"
                    DetailsText += f"<li><b>Average Tokens:</b> {Test.get('average_tokens', 0):.2f}</li>"
                    DetailsText += f"<li><b>Average Output Tokens:</b> {Test.get('average_output_tokens', 0):.2f}</li>"
                    DetailsText += f"<li><b>Tokens Per Second:</b> {Test.get('tokens_per_second', 0):.2f}</li>"
                    DetailsText += f"<li><b>Successful Runs:</b> {Test.get('successful_runs', 0)}</li>"
                    DetailsText += "</ul>\n"
        
        # Update details tab
        self.DetailsText.setHtml(DetailsText)
    
    def _OnSaveResults(self):
        """Handle save results button click."""
        if not self.CurrentResults:
            return
        
        # Get save file path
        FilePath, _ = QFileDialog.getSaveFileName(
            self,
            "Save Benchmark Results",
            f"benchmark_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
            "JSON Files (*.json);;All Files (*.*)"
        )
        
        if not FilePath:
            return
        
        try:
            # Save results to file
            with open(FilePath, 'w') as f:
                json.dump(self.CurrentResults, f, indent=2)
            
            # Show success message
            QMessageBox.information(
                self,
                "Save Successful",
                f"Benchmark results saved to {FilePath}"
            )
        except Exception as e:
            # Show error message
            QMessageBox.critical(
                self,
                "Save Error",
                f"Error saving benchmark results: {e}"
            )

================
File: GUI/Components/ModelSelector.py
================
# File: ModelSelector.py
# Path: OllamaModelEditor/GUI/Components/ModelSelector.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Model selection component for the OllamaModelEditor application

from PySide6.QtWidgets import QWidget, QVBoxLayout, QListWidget, QLabel
from PySide6.QtCore import Signal, Slot

class ModelSelector(QWidget):
    """Widget for selecting Ollama models."""
    
    # Signal emitted when a model is selected
    ModelSelected = Signal(str)
    
    def __init__(self, ModelManager, Config):
        """
        Initialize the model selector.
        
        Args:
            ModelManager: Model manager instance
            Config: Configuration manager instance
        """
        super().__init__()
        
        # Store references
        self.ModelManager = ModelManager
        self.Config = Config
        
        # Set up UI
        self._SetupUI()
    
    def _SetupUI(self):
        """Set up the user interface."""
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add header label
        HeaderLabel = QLabel("Available Models:")
        Layout.addWidget(HeaderLabel)
        
        # Add list widget
        self.ModelList = QListWidget()
        self.ModelList.currentTextChanged.connect(self._OnModelSelected)
        Layout.addWidget(self.ModelList)
        
        # Load models
        self._LoadModels()
    
    def _LoadModels(self):
        """Load available models."""
        # Clear list
        self.ModelList.clear()
        
        # Get available models
        Models = self.ModelManager.GetAvailableModels()
        
        # Add to list
        for Model in Models:
            self.ModelList.addItem(Model.get('name', 'Unknown'))
    
    @Slot(str)
    def _OnModelSelected(self, ModelName):
        """
        Handle model selection.
        
        Args:
            ModelName: Selected model name
        """
        if ModelName:
            # Emit signal
            self.ModelSelected.emit(ModelName)

================
File: GUI/Components/ParameterEditor.py
================
# File: ParameterEditor.py
# Path: OllamaModelEditor/GUI/Components/ParameterEditor.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-13
# Description: Parameter editing component with state tracking for the OllamaModelEditor application

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QSlider, QSpinBox, QDoubleSpinBox,
    QPushButton, QGridLayout, QGroupBox, QTextEdit, QComboBox, QMessageBox,
    QInputDialog, QLineEdit, QFrame, QTabWidget, QScrollArea, QTableWidget,
    QTableWidgetItem, QHeaderView
)
from PySide6.QtCore import Qt, QEvent, Signal, Slot
from PySide6.QtGui import QIcon, QColor, QFont
from typing import Dict, Any, Tuple, List, Optional

class ParameterEditor(QWidget):
    """Widget for editing model parameters with state tracking."""
    
    # Signal emitted when parameters are applied
    ParametersApplied = Signal(dict)
    
    def __init__(self, ModelManager, Config, StateManager):
        """
        Initialize the parameter editor.
        
        Args:
            ModelManager: Model manager instance
            Config: Configuration manager instance
            StateManager: Parameter state manager instance
        """
        super().__init__()
        
        # Store references
        self.ModelManager = ModelManager
        self.Config = Config
        self.StateManager = StateManager
        self.CurrentModel = None
        self.ParameterControls = {}
        
        # Access status bar from parent (will be set after initialization)
        self.StatusBar = None
        
        # Set up UI
        self._SetupUI()
    
    def _SetupUI(self):
        """Set up the user interface."""
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add header layout with labels and presets
        HeaderLayout = QHBoxLayout()
        
        # Add header label
        HeaderLabel = QLabel("Model Parameters")
        HeaderLabel.setStyleSheet("font-weight: bold; font-size: 14px;")
        HeaderLayout.addWidget(HeaderLabel)
        
        # Add spacer
        HeaderLayout.addStretch()
        
        # Add preset selector
        PresetLayout = QHBoxLayout()
        PresetLabel = QLabel("Preset:")
        self.PresetCombo = QComboBox()
        self.LoadPresets()  # Populate presets
        
        self.SavePresetButton = QPushButton("Save Preset")
        self.SavePresetButton.setIcon(QIcon.fromTheme("document-save"))
        self.SavePresetButton.clicked.connect(self._OnSavePreset)
        
        PresetLayout.addWidget(PresetLabel)
        PresetLayout.addWidget(self.PresetCombo)
        PresetLayout.addWidget(self.SavePresetButton)
        
        HeaderLayout.addLayout(PresetLayout)
        
        Layout.addLayout(HeaderLayout)
        
        # Add tab widget for parameter editing and model file view
        self.TabWidget = QTabWidget()
        
        # Parameters tab
        self.ParametersTab = QWidget()
        ParametersLayout = QVBoxLayout(self.ParametersTab)
        
        # Create parameters section
        ParametersGroupBox = QGroupBox("Basic Parameters")
        ParamLayout = QVBoxLayout(ParametersGroupBox)
        
        # Create parameters grid
        self.ParametersGrid = QGridLayout()
        ParamLayout.addLayout(self.ParametersGrid)
        
        ParametersLayout.addWidget(ParametersGroupBox)
        
        # Add advanced parameters section
        AdvancedGroupBox = QGroupBox("Advanced Parameters")
        AdvancedGroupBox.setCheckable(True)
        AdvancedGroupBox.setChecked(False)
        AdvancedLayout = QVBoxLayout(AdvancedGroupBox)
        
        # Create advanced parameters grid
        self.AdvancedParametersGrid = QGridLayout()
        AdvancedLayout.addLayout(self.AdvancedParametersGrid)
        
        ParametersLayout.addWidget(AdvancedGroupBox)
        
        # Add parameter description section
        DescriptionGroupBox = QGroupBox("Parameter Description")
        DescriptionLayout = QVBoxLayout(DescriptionGroupBox)
        
        self.DescriptionText = QTextEdit()
        self.DescriptionText.setReadOnly(True)
        self.DescriptionText.setMinimumHeight(100)
        self.DescriptionText.setPlaceholderText("Select a parameter to see its description")
        DescriptionLayout.addWidget(self.DescriptionText)
        
        ParametersLayout.addWidget(DescriptionGroupBox)
        
        # State changes tab
        self.StateTab = QWidget()
        StateLayout = QVBoxLayout(self.StateTab)
        
        # Add state changes table
        self.StateTable = QTableWidget(0, 3)  # Rows will be added dynamically
        self.StateTable.setHorizontalHeaderLabels(["Parameter", "Original Value", "Current Value"])
        self.StateTable.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.StateTable.verticalHeader().setVisible(False)
        StateLayout.addWidget(self.StateTable)
        
        # Model file tab
        self.ModelFileTab = QWidget()
        ModelFileLayout = QVBoxLayout(self.ModelFileTab)
        
        self.ModelFileText = QTextEdit()
        self.ModelFileText.setReadOnly(True)
        self.ModelFileText.setLineWrapMode(QTextEdit.NoWrap)
        self.ModelFileText.setFont(QFont("Courier New", 10))
        ModelFileLayout.addWidget(self.ModelFileText)
        
        # Add tabs to the tab widget
        self.TabWidget.addTab(self.ParametersTab, "Parameters")
        self.TabWidget.addTab(self.StateTab, "State Changes")
        self.TabWidget.addTab(self.ModelFileTab, "Model File")
        
        Layout.addWidget(self.TabWidget)
        
        # Add action buttons
        ButtonFrame = QFrame()
        ButtonLayout = QHBoxLayout(ButtonFrame)
        ButtonLayout.setContentsMargins(0, 10, 0, 0)
        
        self.ApplyButton = QPushButton("Apply Changes")
        self.ApplyButton.setIcon(QIcon.fromTheme("dialog-ok-apply"))
        self.ApplyButton.clicked.connect(self._OnApplyChanges)
        ButtonLayout.addWidget(self.ApplyButton)
        
        self.ResetButton = QPushButton("Reset to Original")
        self.ResetButton.setIcon(QIcon.fromTheme("edit-undo"))
        self.ResetButton.clicked.connect(self._OnResetToOriginal)
        ButtonLayout.addWidget(self.ResetButton)
        
        self.DefaultButton = QPushButton("Reset to Default")
        self.DefaultButton.setIcon(QIcon.fromTheme("edit-clear"))
        self.DefaultButton.clicked.connect(self._OnResetToDefault)
        ButtonLayout.addWidget(self.DefaultButton)
        
        Layout.addWidget(ButtonFrame)
        
        # Add placeholder message (hidden initially)
        self.PlaceholderLabel = QLabel("Select a model to edit parameters")
        self.PlaceholderLabel.setAlignment(Qt.AlignCenter)
        self.PlaceholderLabel.setVisible(False)
        Layout.addWidget(self.PlaceholderLabel)
    
    def SetStatusBar(self, StatusBar):
        """
        Set the status bar reference.
        
        Args:
            StatusBar: Status bar widget
        """
        self.StatusBar = StatusBar
    
    def LoadModel(self, ModelName: str):
        """
        Load a model for editing.
        
        Args:
            ModelName: Name of the model to load
        """
        # Store current model
        self.CurrentModel = ModelName
        
        # Hide placeholder
        self.PlaceholderLabel.setVisible(False)
        
        # Load model state
        OriginalState, CurrentState = self.StateManager.LoadModelState(ModelName)
        
        # Clear parameters grid
        self._ClearParameterGrids()
        
        # Clear parameter controls
        self.ParameterControls = {}
        
        # Get parameter descriptions from database if available
        ParameterDescriptions = {}
        if self.Config.DB:
            # Get all parameters
            Parameters = self.Config.DB.GetAllParameters()
            for Param in Parameters:
                ParameterDescriptions[Param['Name']] = Param['Description']
        
        # Add parameter controls
        self._CreateParameterControl(
            "Temperature", 
            CurrentState.get('Temperature', 0.7), 
            0.0, 2.0, 0.1, 
            False,
            ParameterDescriptions.get('Temperature', '')
        )
        
        self._CreateParameterControl(
            "TopP", 
            CurrentState.get('TopP', 0.9), 
            0.0, 1.0, 0.01, 
            False,
            ParameterDescriptions.get('TopP', '')
        )
        
        self._CreateParameterControl(
            "MaxTokens", 
            CurrentState.get('MaxTokens', 2048), 
            1, 32000, 1, 
            True,
            ParameterDescriptions.get('MaxTokens', '')
        )
        
        self._CreateParameterControl(
            "FrequencyPenalty", 
            CurrentState.get('FrequencyPenalty', 0.0), 
            0.0, 2.0, 0.1, 
            False,
            ParameterDescriptions.get('FrequencyPenalty', '')
        )
        
        self._CreateParameterControl(
            "PresencePenalty", 
            CurrentState.get('PresencePenalty', 0.0), 
            0.0, 2.0, 0.1, 
            False,
            ParameterDescriptions.get('PresencePenalty', '')
        )
        
        # Update state table
        self._UpdateStateTable()
        
        # Update model file view
        self._UpdateModelFileView()
        
        # Set preset to "Custom" (will be updated if it matches a preset)
        Index = self.PresetCombo.findText("Custom")
        if Index >= 0:
            self.PresetCombo.setCurrentIndex(Index)
        
        # Check if current state matches a preset
        self._CheckForMatchingPreset(CurrentState)
    
    def _ClearParameterGrids(self):
        """Clear parameter grid layouts."""
        # Clear basic parameters grid
        while self.ParametersGrid.count():
            Item = self.ParametersGrid.takeAt(0)
            if Item.widget():
                Item.widget().deleteLater()
        
        # Clear advanced parameters grid
        while self.AdvancedParametersGrid.count():
            Item = self.AdvancedParametersGrid.takeAt(0)
            if Item.widget():
                Item.widget().deleteLater()
    
    def _CreateParameterControl(self, Name, Value, Min, Max, Step, IsInteger=False, Description=""):
        """
        Add a parameter control to the grid.
        
        Args:
            Name: Parameter name
            Value: Current value
            Min: Minimum value
            Max: Maximum value
            Step: Step size
            IsInteger: Whether the parameter is an integer
            Description: Parameter description
        """
        # Determine which grid to use
        if Name in ["Temperature", "TopP", "MaxTokens"]:
            Grid = self.ParametersGrid
            Row = Grid.rowCount()
        else:
            Grid = self.AdvancedParametersGrid
            Row = Grid.rowCount()
        
        # Add label
        Label = QLabel(f"{Name}:")
        Grid.addWidget(Label, Row, 0)
        
        # Add slider
        Slider = QSlider(Qt.Horizontal)
        if IsInteger:
            Slider.setMinimum(int(Min))
            Slider.setMaximum(int(Max))
            Slider.setValue(int(Value))
        else:
            Slider.setMinimum(int(Min * 100))
            Slider.setMaximum(int(Max * 100))
            Slider.setValue(int(Value * 100))
        Grid.addWidget(Slider, Row, 1)
        
        # Add spin box
        if IsInteger:
            SpinBox = QSpinBox()
            SpinBox.setMinimum(int(Min))
            SpinBox.setMaximum(int(Max))
            SpinBox.setValue(int(Value))
        else:
            SpinBox = QDoubleSpinBox()
            SpinBox.setMinimum(Min)
            SpinBox.setMaximum(Max)
            SpinBox.setSingleStep(Step)
            SpinBox.setValue(Value)
            SpinBox.setDecimals(2)
        Grid.addWidget(SpinBox, Row, 2)
        
        # Store parameter description
        Slider.setProperty("ParameterName", Name)
        Slider.setProperty("ParameterDescription", Description)
        SpinBox.setProperty("ParameterName", Name)
        SpinBox.setProperty("ParameterDescription", Description)
        
        # Connect signals
        if IsInteger:
            Slider.valueChanged.connect(SpinBox.setValue)
            SpinBox.valueChanged.connect(Slider.setValue)
        else:
            Slider.valueChanged.connect(lambda v: SpinBox.setValue(v / 100))
            SpinBox.valueChanged.connect(lambda v: Slider.setValue(int(v * 100)))
        
        # Connect update signals
        Slider.valueChanged.connect(lambda: self._OnParameterChanged(Name))
        SpinBox.valueChanged.connect(lambda: self._OnParameterChanged(Name))
        
        # Connect description update signals
        Slider.sliderPressed.connect(lambda: self._UpdateDescription(Name, Description))
        SpinBox.installEventFilter(self)
        
        # Store controls for later access
        self.ParameterControls[Name] = (Slider, SpinBox)
    
    def eventFilter(self, obj, event):
        """Handle focus events for parameter controls."""
        if event.type() == QEvent.FocusIn:
            # If it's a parameter control, update description
            ParameterName = obj.property("ParameterName")
            if ParameterName:
                Description = obj.property("ParameterDescription")
                self._UpdateDescription(ParameterName, Description)
        
        return super().eventFilter(obj, event)
    
    def _UpdateDescription(self, ParameterName, Description):
        """
        Update the parameter description text.
        
        Args:
            ParameterName: Name of the parameter
            Description: Description text
        """
        # Get parameter descriptions from database if available
        if self.Config.DB:
            # Try to get from database
            Parameter = self.Config.DB.GetParameter(ParameterName)
            if Parameter and Parameter.get('Description'):
                Description = Parameter.get('Description')
        
        # If no description is available, use predefined descriptions
        if not Description:
            Descriptions = {
                "Temperature": "Controls randomness in text generation. Higher values (0.7-1.0) produce more creative outputs, while lower values (0.2-0.5) make output more focused and deterministic.",
                "TopP": "Controls diversity via nucleus sampling. Lower values make output more focused on likely tokens. 0.9 is a good starting point.",
                "MaxTokens": "The maximum length of the generated text. Higher values allow for longer responses but consume more resources.",
                "FrequencyPenalty": "Reduces repetition by penalizing tokens that have already appeared in the text. Higher values (0.5-1.0) strongly discourage repetition.",
                "PresencePenalty": "Penalizes tokens that have appeared at all, encouraging the model to discuss new topics. Useful for keeping responses diverse."
            }
            Description = Descriptions.get(ParameterName, f"No description available for {ParameterName}")
        
        # Update the description text
        self.DescriptionText.setHtml(f"<h3>{ParameterName}</h3>\n<p>{Description}</p>")
    
    def _OnParameterChanged(self, ParameterName):
        """
        Handle parameter value change.
        
        Args:
            ParameterName: Name of the changed parameter
        """
        if not self.CurrentModel:
            return
        
        # Get current parameter values
        Params = self._GetParametersFromControls()
        
        # Update state manager
        self.StateManager.UpdateCurrentState(self.CurrentModel, Params)
        
        # Update state table
        self._UpdateStateTable()
        
        # Check if current state matches a preset
        self._CheckForMatchingPreset(Params)
    
    def _UpdateStateTable(self):
        """Update the state changes table."""
        if not self.CurrentModel:
            return
        
        # Get state differences
        Differences = self.StateManager.GetStateDifferences(self.CurrentModel)
        
        # Clear table
        self.StateTable.setRowCount(0)
        
        # Add differences to table
        Row = 0
        for Param, (OrigValue, CurrValue) in Differences.items():
            self.StateTable.insertRow(Row)
            
            # Add parameter name
            ParamItem = QTableWidgetItem(Param)
            ParamItem.setFlags(ParamItem.flags() & ~Qt.ItemIsEditable)
            self.StateTable.setItem(Row, 0, ParamItem)
            
            # Add original value
            OrigItem = QTableWidgetItem(str(OrigValue))
            OrigItem.setFlags(OrigItem.flags() & ~Qt.ItemIsEditable)
            self.StateTable.setItem(Row, 1, OrigItem)
            
            # Add current value (highlighted)
            CurrItem = QTableWidgetItem(str(CurrValue))
            CurrItem.setFlags(CurrItem.flags() & ~Qt.ItemIsEditable)
            CurrItem.setBackground(QColor(255, 255, 0, 100))  # Light yellow highlight
            self.StateTable.setItem(Row, 2, CurrItem)
            
            Row += 1
    
    def _UpdateModelFileView(self):
        """Update the model file view."""
        if not self.CurrentModel:
            return
        
        # Get model file content
        ModelFile = self.StateManager.GetModelFile(self.CurrentModel)
        
        if ModelFile:
            # Format as pretty JSON
            ModelFileText = json.dumps(ModelFile, indent=2)
            self.ModelFileText.setText(ModelFileText)
        else:
            self.ModelFileText.setText("Model file not available")
    
    def LoadPresets(self):
        """Load available presets into the preset combo box."""
        self.PresetCombo.clear()
        
        # Add "Custom" option (for current state)
        self.PresetCombo.addItem("Custom")
        
        # Add built-in presets
        BuiltInPresets = ["Default", "Creative", "Precise", "Fast", "Balanced"]
        for Preset in BuiltInPresets:
            self.PresetCombo.addItem(Preset)
        
        # Add user presets from database if available
        if self.Config.DB:
            UserPresets = self.Config.DB.GetUserPresets()
            for Preset in UserPresets:
                self.PresetCombo.addItem(Preset.get('Name', 'Unknown'))
        
        # Connect signal
        self.PresetCombo.currentTextChanged.connect(self._OnPresetSelected)
    
    def _CheckForMatchingPreset(self, Params):
        """
        Check if current parameters match a preset.
        
        Args:
            Params: Current parameters
        """
        # Get all presets
        Presets = self.ModelManager.GetAllPresets()
        
        # Compare with each preset
        for Preset in Presets:
            PresetName = Preset.get('Name')
            if PresetName == "Custom":
                continue
            
            PresetParams = self.ModelManager.GetPresetParameters(PresetName)
            
            # Check if parameters match
            Matches = True
            for Key, Value in PresetParams.items():
                if Key in Params and abs(Params[Key] - Value) > 0.001:
                    Matches = False
                    break
            
            if Matches:
                # Set preset combo to matching preset
                Index = self.PresetCombo.findText(PresetName)
                if Index >= 0:
                    self.PresetCombo.blockSignals(True)
                    self.PresetCombo.setCurrentIndex(Index)
                    self.PresetCombo.blockSignals(False)
                return
        
        # If no match found, set to "Custom"
        Index = self.PresetCombo.findText("Custom")
        if Index >= 0:
            self.PresetCombo.blockSignals(True)
            self.PresetCombo.setCurrentIndex(Index)
            self.PresetCombo.blockSignals(False)
    
    def _OnPresetSelected(self, PresetName):
        """
        Handle preset selection.
        
        Args:
            PresetName: Name of the selected preset
        """
        if not self.CurrentModel or PresetName == "Custom":
            return
        
        # Get preset parameters
        PresetParams = self.ModelManager.GetPresetParameters(PresetName)
        
        if not PresetParams:
            return
        
        # Apply preset parameters to controls
        self._ApplyParametersToControls(PresetParams)
        
        # Update state manager
        self.StateManager.UpdateCurrentState(self.CurrentModel, PresetParams)
        
        # Update state table
        self._UpdateStateTable()
    
    def _OnSavePreset(self):
        """Handle save preset button click."""
        # Get current parameter values
        Params = self._GetParametersFromControls()
        
        # Prompt user for preset name
        PresetName, OK = QInputDialog.getText(
            self,
            "Save Preset",
            "Enter a name for this preset:",
            QLineEdit.Normal,
            ""
        )
        
        if not OK or not PresetName:
            return
        
        # Prompt for description
        Description, OK = QInputDialog.getText(
            self,
            "Preset Description",
            "Enter a description for this preset:",
            QLineEdit.Normal,
            ""
        )
        
        if not OK:
            Description = ""
        
        # Save preset
        Success = self.ModelManager.SaveUserPreset(PresetName, Description, Params)
        
        if Success:
            # Update preset list
            self.LoadPresets()
            
            # Select the new preset
            Index = self.PresetCombo.findText(PresetName)
            if Index >= 0:
                self.PresetCombo.setCurrentIndex(Index)
        else:
            # Show error message
            QMessageBox.warning(
                self,
                "Save Error",
                "Error saving preset. Please check the logs for details."
            )
    
    def _GetParametersFromControls(self):
        """
        Get parameter values from controls.
        
        Returns:
            Dict: Parameter values
        """
        Params = {}
        
        for Name, (Slider, SpinBox) in self.ParameterControls.items():
            Params[Name] = SpinBox.value()
        
        return Params
    
    def _ApplyParametersToControls(self, Params):
        """
        Apply parameter values to controls.
        
        Args:
            Params: Dictionary of parameter values
        """
        for Name, Value in Params.items():
            if Name in self.ParameterControls:
                Slider, SpinBox = self.ParameterControls[Name]
                
                # Block signals to prevent recursive updates
                SpinBox.blockSignals(True)
                Slider.blockSignals(True)
                
                SpinBox.setValue(Value)
                
                # Set slider value (scaled for non-integer values)
                if isinstance(SpinBox, QDoubleSpinBox):
                    Slider.setValue(int(Value * 100))
                else:
                    Slider.setValue(Value)
                
                # Unblock signals
                SpinBox.blockSignals(False)
                Slider.blockSignals(False)
        
        # Trigger parameter changed event for each parameter
        for Name in Params.keys():
            if Name in self.ParameterControls:
                self._OnParameterChanged(Name)
    
    def _OnApplyChanges(self):
        """Handle apply changes button click."""
        if not self.CurrentModel:
            return
        
        # Get parameter values
        Params = self._GetParametersFromControls()
        
        # Update model parameters
        Success = self.ModelManager.UpdateModelParameters(self.CurrentModel, Params)
        
        if Success:
            # Commit current state
            self.StateManager.CommitCurrentState(self.CurrentModel)
            
            # Update state table
            self._UpdateStateTable()
            
            # Show success message
            if self.StatusBar:
                self.StatusBar.showMessage(f"Parameters updated for {self.CurrentModel}", 3000)
            
            # Set preset to "Custom"
            Index = self.PresetCombo.findText("Custom")
            if Index >= 0:
                self.PresetCombo.setCurrentIndex(Index)
            
            # Check if now matches a preset
            self._CheckForMatchingPreset(Params)
            
            # Emit signal
            self.ParametersApplied.emit(Params)
        else:
            # Show error message
            QMessageBox.warning(
                self,
                "Update Error",
                f"Failed to update parameters for {self.CurrentModel}"
            )
    
    def _OnResetToOriginal(self):
        """Handle reset to original button click."""
        if not self.CurrentModel:
            return
        
        # Reset to original state
        OriginalParams = self.StateManager.ResetToOriginal(self.CurrentModel)
        
        if OriginalParams:
            # Apply original parameters to controls
            self._ApplyParametersToControls(OriginalParams)
            
            # Update state table
            self._UpdateStateTable()
            
            # Show message
            if self.StatusBar:
                self.StatusBar.showMessage("Parameters reset to original values", 3000)
    
    def _OnResetToDefault(self):
        """Handle reset to default button click."""
        if not self.CurrentModel:
            return
        
        # Get default parameters
        DefaultParams = self.Config.GetModelConfig('DefaultParameters')
        
        # Apply default parameters to controls
        self._ApplyParametersToControls(DefaultParams)
        
        # Update state manager
        self.StateManager.UpdateCurrentState(self.CurrentModel, DefaultParams)
        
        # Update state table
        self._UpdateStateTable()
        
        # Show message
        if self.StatusBar:
            self.StatusBar.showMessage("Parameters reset to default values", 3000)

================
File: GUI/Windows/MainWindow.py
================
# File: MainWindow.py
# Path: OllamaModelEditor/GUI/Windows/MainWindow.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-12
# Description: Main window for the OllamaModelEditor application

import sys
from pathlib import Path
import logging
from typing import Optional, Dict, Any

# Import PySide6 components
from PySide6.QtWidgets import (
    QMainWindow, QMenu, QToolBar, QStatusBar, 
    QVBoxLayout, QHBoxLayout, QWidget, QTabWidget,
    QComboBox, QLabel, QPushButton, QMessageBox,
    QSplitter, QDockWidget, QApplication, QFrame
)
from PySide6.QtCore import Qt, QSize, Slot, Signal, QTimer
from PySide6.QtGui import QIcon, QFont, QKeySequence, QAction  # QAction moved to QtGui

# Import project modules
from Core.ConfigManager import ConfigManager
from Core.ModelManager import ModelManager
from GUI.Components.ModelSelector import ModelSelector
from GUI.Components.ParameterEditor import ParameterEditor
from GUI.Components.BenchmarkView import BenchmarkView

class MainWindow(QMainWindow):
    """Main application window for OllamaModelEditor."""
    
    def __init__(self, Config: ConfigManager):
        """
        Initialize the main window.
        
        Args:
            Config: Configuration manager instance
        """
        super().__init__()
        
        # Initialize logging
        self.Logger = logging.getLogger('OllamaModelEditor.MainWindow')
        
        # Store configuration
        self.Config = Config
        
        # Create model manager
        self.ModelManager = ModelManager(Config)
        
        # Set up UI
        self._SetupWindow()
        self._CreateMenus()
        self._CreateToolbars()
        self._CreateStatusBar()
        self._CreateCentralWidget()
        self._CreateDockWidgets()
        
        # Load user preferences
        self._LoadPreferences()
        
        # Connect signals and slots
        self._ConnectSignals()
        
        # Load models
        self._LoadModels()
    
    def _SetupWindow(self) -> None:
        """Set up the main window properties."""
        # Set window title and icon
        self.setWindowTitle("Ollama Model Editor")
        # self.setWindowIcon(QIcon("GUI/Assets/icons/app_icon.png"))
        
        # Set window geometry
        WindowWidth = self.Config.GetUserPreference('WindowWidth', 1200)
        WindowHeight = self.Config.GetUserPreference('WindowHeight', 800)
        self.resize(WindowWidth, WindowHeight)
        
        # Get the screen size
        ScreenSize = self.screen().size()
        
        # Center window on screen
        self.move(
            (ScreenSize.width() - WindowWidth) // 2,
            (ScreenSize.height() - WindowHeight) // 2
        )
        
        # Apply application-wide stylesheet for better visual hierarchy
        self._ApplyAppStylesheet()
    
    def _ApplyAppStylesheet(self) -> None:
        """Apply application-wide stylesheet."""
        # Application-wide stylesheet for consistent dark theme and better visual separation
        AppStyleSheet = """
            /* Main application styling */
            QMainWindow, QDialog {
                background-color: #232323;
                color: #E0E0E0;
            }
            
            /* Menu and toolbar styling for better contrast */
            QMenuBar {
                background-color: #1A1A1A;
                color: #FFFFFF;
                border-bottom: 1px solid #3D3D3D;
                min-height: 28px;
                padding: 2px;
            }
            
            QMenuBar::item {
                background-color: transparent;
                padding: 4px 8px;
                margin: 2px 1px;
            }
            
            QMenuBar::item:selected {
                background-color: #3D3D3D;
                border-radius: 3px;
            }
            
            QToolBar {
                background-color: #2A2A2A;
                border-bottom: 1px solid #3D3D3D;
                padding: 2px;
                spacing: 2px;
            }
            
            /* Tab widget styling for better separation from menu */
            QTabWidget::pane {
                border-top: 1px solid #3D3D3D;
                background-color: #232323;
                top: -1px;
            }
            
            QTabBar::tab {
                background-color: #333333;
                color: #E0E0E0;
                padding: 8px 12px;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border: 1px solid #3D3D3D;
                border-bottom: none;
                min-width: 120px;
            }
            
            QTabBar::tab:selected {
                background-color: #404040;
                border-bottom-color: #404040;
            }
            
            QTabBar::tab:hover:!selected {
                background-color: #383838;
            }
            
            /* Dock widget styling */
            QDockWidget {
                titlebar-close-icon: url(close.png);
                titlebar-normal-icon: url(undock.png);
            }
            
            QDockWidget::title {
                background-color: #2A2A2A;
                padding-left: 10px;
                padding-top: 4px;
                border-bottom: 1px solid #3D3D3D;
            }
            
            /* Control styling */
            QSlider::groove:horizontal {
                border: 1px solid #5A5A5A;
                height: 8px;
                background: #3A3A3A;
                margin: 2px 0;
                border-radius: 4px;
            }
            
            QSlider::handle:horizontal {
                background: #0078D7;
                border: 1px solid #0078D7;
                width: 18px;
                margin: -2px 0;
                border-radius: 9px;
            }
            
            QSlider::handle:horizontal:hover {
                background: #1C86E0;
            }
            
            QComboBox {
                background-color: #3A3A3A;
                border: 1px solid #5A5A5A;
                border-radius: 3px;
                padding: 2px 8px;
                min-height: 24px;
            }
            
            QComboBox::drop-down {
                subcontrol-origin: padding;
                subcontrol-position: right;
                width: 20px;
                border-left: 1px solid #5A5A5A;
            }
            
            QPushButton {
                background-color: #3A3A3A;
                border: 1px solid #5A5A5A;
                border-radius: 3px;
                padding: 5px 15px;
                color: #E0E0E0;
                min-height: 24px;
            }
            
            QPushButton:hover {
                background-color: #4A4A4A;
            }
            
            QPushButton:pressed {
                background-color: #2A2A2A;
            }
            
            /* List and tree views */
            QListWidget, QTreeWidget {
                background-color: #2A2A2A;
                border: 1px solid #3D3D3D;
                alternate-background-color: #323232;
            }
            
            QListWidget::item, QTreeWidget::item {
                padding: 4px 2px;
            }
            
            QListWidget::item:selected, QTreeWidget::item:selected {
                background-color: #0078D7;
                color: white;
            }
            
            QListWidget::item:hover, QTreeWidget::item:hover {
                background-color: #383838;
            }
            
            /* Other elements */
            QLineEdit, QTextEdit, QSpinBox, QDoubleSpinBox {
                background-color: #2A2A2A;
                border: 1px solid #3D3D3D;
                border-radius: 3px;
                padding: 3px;
            }
            
            QStatusBar {
                background-color: #2A2A2A;
                color: #B0B0B0;
                border-top: 1px solid #3D3D3D;
            }
        """
        
        # Apply the stylesheet to the application
        app = QApplication.instance()
        if app:
            app.setStyleSheet(AppStyleSheet)
    
    def _CreateMenus(self) -> None:
        """Create the application menu bar."""
        self.MenuBar = self.menuBar()
        
        # File menu
        self.FileMenu = self.MenuBar.addMenu("&File")
        
        self.NewAction = QAction("&New Configuration", self)
        self.NewAction.setShortcut(QKeySequence.New)
        self.NewAction.triggered.connect(self._OnNewConfig)
        self.FileMenu.addAction(self.NewAction)
        
        self.OpenAction = QAction("&Open Configuration...", self)
        self.OpenAction.setShortcut(QKeySequence.Open)
        self.OpenAction.triggered.connect(self._OnOpenConfig)
        self.FileMenu.addAction(self.OpenAction)
        
        self.SaveAction = QAction("&Save Configuration", self)
        self.SaveAction.setShortcut(QKeySequence.Save)
        self.SaveAction.triggered.connect(self._OnSaveConfig)
        self.FileMenu.addAction(self.SaveAction)
        
        self.SaveAsAction = QAction("Save Configuration &As...", self)
        self.SaveAsAction.setShortcut(QKeySequence.SaveAs)
        self.SaveAsAction.triggered.connect(self._OnSaveConfigAs)
        self.FileMenu.addAction(self.SaveAsAction)
        
        self.FileMenu.addSeparator()
        
        self.ExitAction = QAction("E&xit", self)
        self.ExitAction.setShortcut(QKeySequence.Quit)
        self.ExitAction.triggered.connect(self.close)
        self.FileMenu.addAction(self.ExitAction)
        
        # Edit menu
        self.EditMenu = self.MenuBar.addMenu("&Edit")
        
        self.PreferencesAction = QAction("&Preferences...", self)
        self.PreferencesAction.triggered.connect(self._OnPreferences)
        self.EditMenu.addAction(self.PreferencesAction)
        
        # View menu
        self.ViewMenu = self.MenuBar.addMenu("&View")
        
        # Tools menu
        self.ToolsMenu = self.MenuBar.addMenu("&Tools")
        
        self.BenchmarkAction = QAction("&Benchmark Model...", self)
        self.BenchmarkAction.triggered.connect(self._OnBenchmark)
        self.ToolsMenu.addAction(self.BenchmarkAction)
        
        self.ExportAction = QAction("&Export Model Definition...", self)
        self.ExportAction.triggered.connect(self._OnExportModel)
        self.ToolsMenu.addAction(self.ExportAction)
        
        # Help menu
        self.HelpMenu = self.MenuBar.addMenu("&Help")
        
        self.DocumentationAction = QAction("&Documentation", self)
        self.DocumentationAction.triggered.connect(self._OnDocumentation)
        self.HelpMenu.addAction(self.DocumentationAction)
        
        self.HelpMenu.addSeparator()
        
        self.AboutAction = QAction("&About", self)
        self.AboutAction.triggered.connect(self._OnAbout)
        self.HelpMenu.addAction(self.AboutAction)
    
    def _CreateToolbars(self) -> None:
        """Create the application toolbars."""
        # Main toolbar
        self.MainToolbar = QToolBar("Main Toolbar")
        self.MainToolbar.setObjectName("MainToolbar")  # Add objectName to fix warning
        self.MainToolbar.setMovable(False)
        self.MainToolbar.setIconSize(QSize(24, 24))
        self.addToolBar(self.MainToolbar)
        
        # Add actions to toolbar
        self.MainToolbar.addAction(self.NewAction)
        self.MainToolbar.addAction(self.OpenAction)
        self.MainToolbar.addAction(self.SaveAction)
        self.MainToolbar.addSeparator()
        
        # Add model selector to toolbar
        self.ModelSelectorLabel = QLabel("Model:")
        self.MainToolbar.addWidget(self.ModelSelectorLabel)
        
        self.ModelSelectorCombo = QComboBox()
        self.ModelSelectorCombo.setMinimumWidth(200)
        self.MainToolbar.addWidget(self.ModelSelectorCombo)
        
        self.RefreshModelsButton = QPushButton("Refresh")
        self.RefreshModelsButton.clicked.connect(self._OnRefreshModels)
        self.MainToolbar.addWidget(self.RefreshModelsButton)
    
    def _CreateStatusBar(self) -> None:
        """Create the application status bar."""
        self.StatusBar = QStatusBar()
        self.setStatusBar(self.StatusBar)
        
        # Add status labels
        self.ModelStatusLabel = QLabel("No model selected")
        self.StatusBar.addWidget(self.ModelStatusLabel)
        
        self.APIStatusLabel = QLabel("API: Not connected")
        self.StatusBar.addPermanentWidget(self.APIStatusLabel)
    
    def _CreateCentralWidget(self) -> None:
        """Create the central widget."""
        # Create central widget
        self.CentralWidget = QWidget()
        self.setCentralWidget(self.CentralWidget)
        
        # Main layout
        self.MainLayout = QVBoxLayout()
        self.CentralWidget.setLayout(self.MainLayout)
        
        # Create tab widget
        self.TabWidget = QTabWidget()
        self.MainLayout.addWidget(self.TabWidget)
        
        # Add parameter editor tab
        self.ParameterEditorWidget = ParameterEditor(self.ModelManager, self.Config)
        self.TabWidget.addTab(self.ParameterEditorWidget, "Parameter Editor")
        
        # Add benchmark tab
        self.BenchmarkWidget = BenchmarkView(self.ModelManager, self.Config)
        self.TabWidget.addTab(self.BenchmarkWidget, "Benchmark")
        
        # Add analysis tab if available
        try:
            from GUI.Components.AnalysisView import AnalysisView
            self.AnalysisWidget = AnalysisView(self.ModelManager, self.Config)
            self.TabWidget.addTab(self.AnalysisWidget, "Analysis")
        except ImportError:
            # Analysis view not available, skip
            pass
    
    def _CreateDockWidgets(self) -> None:
        """Create dock widgets."""
        # Model selector dock
        self.ModelSelectorDock = QDockWidget("Model Library", self)
        self.ModelSelectorDock.setObjectName("ModelLibraryDock")  # Add objectName to fix warning
        self.ModelSelectorDock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        
        # Create a container widget with layout for the dock
        DockContainer = QWidget()
        DockLayout = QVBoxLayout(DockContainer)
        DockLayout.setContentsMargins(0, 0, 0, 0)
        
        # Add header with label and toolbar
        HeaderLayout = QHBoxLayout()
        HeaderLayout.setSpacing(2)
        HeaderLabel = QLabel("Available Models:")
        HeaderLabel.setStyleSheet("font-weight: bold;")
        HeaderLayout.addWidget(HeaderLabel)
        
        # Add spacer to push toolbar to right
        HeaderLayout.addStretch()
        
        # Add refresh button to dock header
        RefreshButton = QPushButton("↻")
        RefreshButton.setToolTip("Refresh Models")
        RefreshButton.setMaximumWidth(24)
        RefreshButton.clicked.connect(self._OnRefreshModels)
        HeaderLayout.addWidget(RefreshButton)
        
        DockLayout.addLayout(HeaderLayout)
        
        # Create model selector widget
        self.ModelSelectorWidget = ModelSelector(self.ModelManager, self.Config)
        DockLayout.addWidget(self.ModelSelectorWidget)
        
        # Set dock widget content
        self.ModelSelectorDock.setWidget(DockContainer)
        
        # Add dock to main window
        self.addDockWidget(Qt.LeftDockWidgetArea, self.ModelSelectorDock)
        self.ViewMenu.addAction(self.ModelSelectorDock.toggleViewAction())
    
    def _LoadPreferences(self) -> None:
        """Load user preferences."""
        # Load window state if saved
        WindowState = self.Config.GetUserPreference('WindowState')
        WindowGeometry = self.Config.GetUserPreference('WindowGeometry')
        
        if WindowState:
            self.restoreState(WindowState)
        
        if WindowGeometry:
            self.restoreGeometry(WindowGeometry)
        
        # Apply theme
        Theme = self.Config.GetUserPreference('Theme', 'system')
        self._ApplyTheme(Theme)
    
    def _ApplyTheme(self, Theme: str) -> None:
        """
        Apply the selected theme.
        
        Args:
            Theme: Theme name ('light', 'dark', or 'system')
        """
        # Theme implementation would go here
        pass
    
    def _ConnectSignals(self) -> None:
        """Connect signals and slots."""
        # Connect model selector combo box
        self.ModelSelectorCombo.currentTextChanged.connect(self._OnModelSelected)
        
        # Connect model selector widget
        self.ModelSelectorWidget.ModelSelected.connect(self._OnModelSelectedFromWidget)
    
    def _LoadModels(self) -> None:
        """Load available models."""
        # Update status
        self.StatusBar.showMessage("Loading models...", 2000)
        
        # Get available models
        Models = self.ModelManager.GetAvailableModels()
        
        # Update model selector combo box
        self.ModelSelectorCombo.clear()
        for Model in Models:
            self.ModelSelectorCombo.addItem(Model.get('name', 'Unknown'))
        
        # Update status
        if Models:
            self.APIStatusLabel.setText("API: Connected")
            self.StatusBar.showMessage(f"Loaded {len(Models)} models", 3000)
        else:
            self.APIStatusLabel.setText("API: Error")
            self.StatusBar.showMessage("Failed to load models", 3000)
    
    @Slot()
    def _OnRefreshModels(self) -> None:
        """Handle refresh models button click."""
        self._LoadModels()
    
    @Slot(str)
    def _OnModelSelected(self, ModelName: str) -> None:
        """
        Handle model selection from combo box.
        
        Args:
            ModelName: Selected model name
        """
        if not ModelName:
            return
        
        # Set current model
        if self.ModelManager.SetCurrentModel(ModelName):
            self.ModelStatusLabel.setText(f"Model: {ModelName}")
            self.StatusBar.showMessage(f"Model {ModelName} selected", 3000)
            
            # Update parameter editor
            self.ParameterEditorWidget.LoadModel(ModelName)
        else:
            self.StatusBar.showMessage(f"Failed to select model {ModelName}", 3000)
    
    @Slot(str)
    def _OnModelSelectedFromWidget(self, ModelName: str) -> None:
        """
        Handle model selection from model selector widget.
        
        Args:
            ModelName: Selected model name
        """
        # Update combo box
        Index = self.ModelSelectorCombo.findText(ModelName)
        if Index >= 0:
            self.ModelSelectorCombo.setCurrentIndex(Index)
    
    @Slot()
    def _OnNewConfig(self) -> None:
        """Handle new configuration action."""
        # Check if current configuration should be saved
        # Implementation would go here
        
        # Create new configuration
        pass
    
    @Slot()
    def _OnOpenConfig(self) -> None:
        """Handle open configuration action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnSaveConfig(self) -> None:
        """Handle save configuration action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnSaveConfigAs(self) -> None:
        """Handle save configuration as action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnPreferences(self) -> None:
        """Handle preferences action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnBenchmark(self) -> None:
        """Handle benchmark action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnExportModel(self) -> None:
        """Handle export model action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnDocumentation(self) -> None:
        """Handle documentation action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnAbout(self) -> None:
        """Handle about action."""
        AboutText = (
            "<h2>Ollama Model Editor</h2>"
            "<p>Version 1.0.0</p>"
            "<p>A powerful tool for customizing and optimizing Ollama AI models.</p>"
            "<p>This project is a collaboration between human developers and AI assistants.</p>"
            "<p>&copy; 2025 Herbert J. Bowers (Herb@BowersWorld.com)</p>"
        )
        
        QMessageBox.about(self, "About Ollama Model Editor", AboutText)
    
    def closeEvent(self, event) -> None:
        """
        Handle window close event.
        
        Save user preferences before closing.
        """
        # Save window state and geometry
        self.Config.SetUserPreference('WindowState', self.saveState())
        self.Config.SetUserPreference('WindowGeometry', self.saveGeometry())
        self.Config.SetUserPreference('WindowWidth', self.width())
        self.Config.SetUserPreference('WindowHeight', self.height())
        
        # Save configuration
        self.Config.SaveConfig()
        
        # Accept close event
        event.accept()

================
File: GUI/Windows/SplashScreen.py
================
# File: SplashScreen.py
# Path: OllamaModelEditor/GUI/Windows/SplashScreen.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-12
# Description: Splash screen for the OllamaModelEditor application

from PySide6.QtWidgets import QSplashScreen
from PySide6.QtCore import Qt, QTimer
from PySide6.QtGui import QPixmap, QFont, QColor, QPainter

class SplashScreen(QSplashScreen):
    """Splash screen displayed during application startup."""
    
    def __init__(self):
        """Initialize the splash screen."""
        # Create a pixmap for the splash screen
        self.BasePixmap = QPixmap(600, 400)
        self.BasePixmap.fill(Qt.white)
        
        # Initialize with the base pixmap
        super().__init__(self.BasePixmap)
        
        # Set window flags
        self.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint)
        
        # Initialize progress
        self.Progress = 0
        self.ProgressMax = 100
        
        # Draw initial content
        self._DrawContent()
        
        # Start progress timer
        self.ProgressTimer = QTimer(self)
        self.ProgressTimer.timeout.connect(self._UpdateProgress)
        self.ProgressTimer.start(50)
    
    def _DrawContent(self):
        """Draw splash screen content."""
        # Create a new pixmap based on the base pixmap for drawing
        CurrentPixmap = QPixmap(self.BasePixmap)
        
        # Create painter for the current pixmap
        Painter = QPainter(CurrentPixmap)
        
        # Draw application name
        Painter.setPen(QColor(40, 40, 40))
        TitleFont = QFont("Arial", 28, QFont.Bold)
        Painter.setFont(TitleFont)
        Painter.drawText(50, 100, "Ollama Model Editor")
        
        # Draw tagline
        TaglineFont = QFont("Arial", 14)
        Painter.setFont(TaglineFont)
        Painter.drawText(50, 140, "A powerful tool for customizing and optimizing Ollama AI models")
        
        # Draw version
        VersionFont = QFont("Arial", 10)
        Painter.setFont(VersionFont)
        Painter.drawText(50, 180, "Version 1.0.0")
        
        # Draw credits
        CreditsFont = QFont("Arial", 10)
        Painter.setFont(CreditsFont)
        Painter.setPen(QColor(100, 100, 100))
        Painter.drawText(50, 350, "© 2025 Herbert J. Bowers")
        Painter.drawText(50, 370, "A Human-AI Collaboration Project")
        
        # Draw progress bar frame
        Painter.setPen(QColor(200, 200, 200))
        Painter.setBrush(Qt.white)
        Painter.drawRect(50, 250, 500, 30)
        
        # Draw progress bar
        ProgressWidth = int(500 * (self.Progress / self.ProgressMax))
        Painter.setPen(Qt.NoPen)
        Painter.setBrush(QColor(0, 120, 212))
        Painter.drawRect(50, 250, ProgressWidth, 30)
        
        # Determine status message based on progress
        StatusMessage = "Initializing..."
        if self.Progress > 20:
            StatusMessage = "Loading configuration..."
        if self.Progress > 40:
            StatusMessage = "Connecting to Ollama API..."
        if self.Progress > 60:
            StatusMessage = "Loading model information..."
        if self.Progress > 80:
            StatusMessage = "Preparing UI components..."
        
        # Draw status text
        Painter.setPen(QColor(40, 40, 40))
        StatusFont = QFont("Arial", 10)
        Painter.setFont(StatusFont)
        Painter.drawText(50, 220, StatusMessage)
        
        # End painting
        Painter.end()
        
        # Set the updated pixmap to the splash screen
        self.setPixmap(CurrentPixmap)
    
    def _UpdateProgress(self):
        """Update progress bar display."""
        if self.Progress >= self.ProgressMax:
            self.ProgressTimer.stop()
            return
        
        # Increase progress
        self.Progress += 2
        
        # Update display
        self._DrawContent()
    
    def mousePressEvent(self, event):
        """
        Handle mouse press events.
        
        Mouse clicks will hide the splash screen.
        
        Args:
            event: Mouse event
        """
        self.hide()

================
File: scripts/GithubUpdate.sh
================
#!/bin/bash

# GitHub Update Script for OllamaModelEditor
# This script automates the process of committing and pushing changes to GitHub

# Color codes for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}========================================${NC}"
echo -e "${BLUE}  GitHub Update Script for OllamaModelEditor${NC}"
echo -e "${BLUE}========================================${NC}"

# Check if git is installed
if ! command -v git &> /dev/null; then
    echo -e "${RED}Error: git is not installed.${NC}"
    exit 1
fi

# Check if the current directory is a git repository
if [ ! -d ".git" ]; then
    echo -e "${RED}Error: This directory is not a git repository.${NC}"
    echo -e "${YELLOW}Run 'git init' to initialize a new repository.${NC}"
    exit 1
fi

# Check if remote origin exists
if ! git remote get-url origin &> /dev/null; then
    echo -e "${RED}Error: Remote 'origin' not configured.${NC}"
    echo -e "${YELLOW}Use 'git remote add origin <url>' to add a remote repository.${NC}"
    exit 1
fi

# Function to get commit message
get_commit_message() {
    # Default commit message
    default_message="Update OllamaModelEditor files"
    
    # If a message was provided as an argument, use it
    if [ -n "$1" ]; then
        echo "$1"
    else
        # Ask for commit message with default
        read -p "Enter commit message [$default_message]: " message
        echo "${message:-$default_message}"
    fi
}

# Check git status
echo -e "${BLUE}Checking repository status...${NC}"
git status

# Store current status output
status_output=$(git status --porcelain)

# If there are no changes, exit
if [ -z "$status_output" ]; then
    echo -e "${GREEN}No changes to commit. Repository is up to date.${NC}"
    exit 0
fi

# Show summary of changes
echo -e "${YELLOW}Changes detected:${NC}"
echo -e "${YELLOW}-------------------${NC}"
modified_files=$(echo "$status_output" | grep '^ M\|^M ' | wc -l)
untracked_files=$(echo "$status_output" | grep '^??' | wc -l)
deleted_files=$(echo "$status_output" | grep '^ D\|^D ' | wc -l)

echo -e "${YELLOW}Modified files: ${NC}$modified_files"
echo -e "${YELLOW}New files: ${NC}$untracked_files"
echo -e "${YELLOW}Deleted files: ${NC}$deleted_files"
echo -e "${YELLOW}-------------------${NC}"

# Prompt to continue
read -p "Continue with update? (y/n): " continue_update
if [[ ! "$continue_update" =~ ^[Yy]$ ]]; then
    echo -e "${YELLOW}Update canceled.${NC}"
    exit 0
fi

# Stage all changes
echo -e "${BLUE}Staging all changes...${NC}"
git add .

# Show what's staged
echo -e "${BLUE}Files staged for commit:${NC}"
git status

# Get commit message (from argument or prompt)
commit_message=$(get_commit_message "$1")

# Commit changes
echo -e "${BLUE}Committing changes...${NC}"
git commit -m "$commit_message"

# Check if commit was successful
if [ $? -ne 0 ]; then
    echo -e "${RED}Commit failed. Exiting.${NC}"
    exit 1
fi

# Prompt before pushing
read -p "Push changes to GitHub? (y/n): " push_changes
if [[ ! "$push_changes" =~ ^[Yy]$ ]]; then
    echo -e "${YELLOW}Changes committed but not pushed.${NC}"
    echo -e "${YELLOW}Run 'git push origin main' to push changes when ready.${NC}"
    exit 0
fi

# Push changes
echo -e "${BLUE}Pushing changes to GitHub...${NC}"
git push origin main

# Check if push was successful
if [ $? -eq 0 ]; then
    echo -e "${GREEN}Success! All changes have been pushed to GitHub.${NC}"
else
    echo -e "${RED}Push failed. You may need to pull changes first with 'git pull origin main'.${NC}"
    exit 1
fi

echo -e "${BLUE}========================================${NC}"
echo -e "${GREEN}GitHub update complete!${NC}"
echo -e "${BLUE}========================================${NC}"

================
File: scripts/MigrateDBToPascalCase.py
================
#!/usr/bin/env python3
# File: MigrateDBToPascalCase.py
# Path: OllamaModelEditor/scripts/MigrateDBToPascalCase.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-12
# Last Modified: 2025-03-12 09:00PM
# Description: Migrates the database schema from snake_case to PascalCase

import os
import sys
import sqlite3
import json
import time
import argparse
from pathlib import Path
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, 
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
Logger = logging.getLogger('DatabaseMigration')

# Add project root to path
ProjectRoot = Path(__file__).resolve().parents[1]
sys.path.append(str(ProjectRoot))

def ParseCommandLine():
    """
    Parse command line arguments.
    
    Returns:
        Namespace with parsed arguments
    """
    Parser = argparse.ArgumentParser(description="OllamaModelEditor - Database Schema Migration")
    Parser.add_argument("--db", help="Path to database file", required=True)
    Parser.add_argument("--backup", action="store_true", help="Create a backup before migration")
    Parser.add_argument("--force", action="store_true", help="Force migration even if errors occur")
    return Parser.parse_args()

def BackupDatabase(SourcePath: str) -> str:
    """
    Create a backup of the database.
    
    Args:
        SourcePath: Path to the database file
        
    Returns:
        Path to the backup file
    """
    Logger.info(f"Creating database backup...")
    
    # Define backup path
    BackupPath = f"{SourcePath}.backup_{int(time.time())}"
    
    try:
        # Connect to source database
        SourceConn = sqlite3.connect(SourcePath)
        
        # Connect to backup database
        BackupConn = sqlite3.connect(BackupPath)
        
        # Copy database content
        SourceConn.backup(BackupConn)
        
        # Close connections
        SourceConn.close()
        BackupConn.close()
        
        Logger.info(f"Database backed up to: {BackupPath}")
        return BackupPath
        
    except sqlite3.Error as Error:
        Logger.error(f"Error backing up database: {Error}")
        raise

def GetTableNames(Conn: sqlite3.Connection) -> list:
    """
    Get a list of all tables in the database.
    
    Args:
        Conn: Database connection
        
    Returns:
        List of table names
    """
    Cursor = Conn.cursor()
    Cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
    return [Row[0] for Row in Cursor.fetchall()]

def GetColumnInfo(Conn: sqlite3.Connection, TableName: str) -> list:
    """
    Get column information for a table.
    
    Args:
        Conn: Database connection
        TableName: Name of the table
        
    Returns:
        List of column information (name, type, etc.)
    """
    Cursor = Conn.cursor()
    Cursor.execute(f"PRAGMA table_info({TableName})")
    return Cursor.fetchall()

def ConvertSnakeToPascalCase(SnakeCase: str) -> str:
    """
    Convert snake_case to PascalCase.
    
    Args:
        SnakeCase: String in snake_case
        
    Returns:
        String in PascalCase
    """
    # Special case for ID
    if SnakeCase.lower() == "id":
        return "ID"
    
    # Handle special terms
    SpecialTerms = {
        "api": "API",
        "db": "DB",
        "gui": "GUI",
        "url": "URL",
        "uri": "URI",
        "json": "JSON",
        "xml": "XML",
        "html": "HTML",
        "css": "CSS",
        "sql": "SQL"
    }
    
    # Split by underscore and convert each word
    Words = SnakeCase.split("_")
    
    # Process each word
    for i, Word in enumerate(Words):
        # Check if the word is a special term
        if Word.lower() in SpecialTerms:
            Words[i] = SpecialTerms[Word.lower()]
        else:
            # Capitalize the first letter of each word
            Words[i] = Word.capitalize()
    
    # Join words together
    return "".join(Words)

def CreateMigrationScript(SourceTables: dict) -> list:
    """
    Create SQL migration script.
    
    Args:
        SourceTables: Dictionary of table names and their columns
        
    Returns:
        List of SQL statements for migration
    """
    MigrationScript = []
    
    # Create temporary tables, copy data, drop original tables, rename temp tables
    for TableName, Columns in SourceTables.items():
        # Skip tables that already use PascalCase
        if TableName == "DBVersion" or TableName.startswith("sqlite_"):
            continue
            
        # Create PascalCase table name
        NewTableName = TableName
        if "_" in TableName:
            NewTableName = ConvertSnakeToPascalCase(TableName)
        
        # Get column definitions with PascalCase names
        ColumnDefs = []
        OldColumns = []
        NewColumns = []
        
        for Column in Columns:
            CID, Name, Type, NotNull, DefaultValue, PK = Column
            
            # Convert column name to PascalCase
            NewName = Name
            if "_" in Name:
                NewName = ConvertSnakeToPascalCase(Name)
            
            # Build column definition
            ColumnDef = f"{NewName} {Type}"
            if NotNull:
                ColumnDef += " NOT NULL"
            if DefaultValue is not None:
                ColumnDef += f" DEFAULT {DefaultValue}"
            if PK:
                ColumnDef += " PRIMARY KEY"
            
            ColumnDefs.append(ColumnDef)
            OldColumns.append(Name)
            NewColumns.append(NewName)
        
        # Create temporary table
        TempTableName = f"temp_{TableName}"
        CreateTableSQL = f"CREATE TABLE {TempTableName} ({', '.join(ColumnDefs)})"
        MigrationScript.append(CreateTableSQL)
        
        # Copy data
        OldColumnsStr = ', '.join(OldColumns)
        NewColumnsStr = ', '.join(NewColumns)
        CopyDataSQL = f"INSERT INTO {TempTableName} ({NewColumnsStr}) SELECT {OldColumnsStr} FROM {TableName}"
        MigrationScript.append(CopyDataSQL)
        
        # Drop original table
        DropTableSQL = f"DROP TABLE {TableName}"
        MigrationScript.append(DropTableSQL)
        
        # Rename temporary table
        RenameTableSQL = f"ALTER TABLE {TempTableName} RENAME TO {NewTableName}"
        MigrationScript.append(RenameTableSQL)
    
    return MigrationScript

def MigrateDatabase(DBPath: str, Force: bool = False) -> bool:
    """
    Migrate database from snake_case to PascalCase.
    
    Args:
        DBPath: Path to the database file
        Force: Whether to force migration even if errors occur
        
    Returns:
        True if successful, False otherwise
    """
    try:
        # Connect to the database
        Conn = sqlite3.connect(DBPath)
        
        # Get table names
        TableNames = GetTableNames(Conn)
        Logger.info(f"Found {len(TableNames)} tables in the database")
        
        # Get column information for each table
        SourceTables = {}
        for TableName in TableNames:
            if not TableName.startswith("sqlite_"):  # Skip SQLite internal tables
                SourceTables[TableName] = GetColumnInfo(Conn, TableName)
        
        # Create migration script
        MigrationScript = CreateMigrationScript(SourceTables)
        Logger.info(f"Generated {len(MigrationScript)} SQL statements for migration")
        
        # Execute migration script
        Cursor = Conn.cursor()
        for SQL in MigrationScript:
            try:
                Logger.debug(f"Executing: {SQL}")
                Cursor.execute(SQL)
            except sqlite3.Error as Error:
                Logger.error(f"Error executing SQL: {Error}")
                Logger.error(f"SQL: {SQL}")
                if not Force:
                    raise
        
        # Commit changes
        Conn.commit()
        Logger.info("Migration completed successfully")
        
        # Close connection
        Conn.close()
        
        return True
    
    except Exception as Error:
        Logger.error(f"Error migrating database: {Error}")
        return False

def main():
    """Main function."""
    # Parse command line arguments
    Args = ParseCommandLine()
    
    try:
        Logger.info(f"Starting database migration from snake_case to PascalCase")
        Logger.info(f"Database path: {Args.db}")
        
        # Check if database exists
        if not os.path.exists(Args.db):
            Logger.error(f"Database file not found: {Args.db}")
            return 1
        
        # Create backup if requested
        if Args.backup:
            try:
                BackupPath = BackupDatabase(Args.db)
                Logger.info(f"Backup created at: {BackupPath}")
            except Exception as Error:
                Logger.error(f"Failed to create backup: {Error}")
                return 1
        
        # Migrate database
        Success = MigrateDatabase(Args.db, Args.force)
        
        if Success:
            Logger.info("Database migration completed successfully")
            return 0
        else:
            Logger.error("Database migration failed")
            return 1
    
    except Exception as Error:
        Logger.error(f"Error: {Error}")
        return 1

if __name__ == "__main__":
    sys.exit(main())

================
File: scripts/MigrateToDatabase.py
================
#!/usr/bin/env python3
# File: MigrateToDatabase.py
# Path: OllamaModelEditor/scripts/MigrateToDatabase.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-12
# Last Modified: 2025-03-12 06:30PM
# Description: Migrates configuration from files to SQLite database

import os
import sys
import json
import yaml
import argparse
from pathlib import Path

# Add project root to path
ProjectRoot = Path(__file__).resolve().parents[1]
sys.path.append(str(ProjectRoot))

try:
    from Core.DBManager import DBManager
    from Core.ConfigManager import ConfigManager
except ImportError as Error:
    print(f"Error importing required modules: {Error}")
    print("Make sure you're running this script from the OllamaModelEditor directory")
    sys.exit(1)

def MigrateToDatabase(ConfigPath=None, DBPath=None):
    """
    Migrate configuration from files to database.
    
    Args:
        ConfigPath: Optional path to configuration file
        DBPath: Optional path to database file
    """
    print("\nOllamaModelEditor - Configuration Migration Tool")
    print("==============================================\n")
    print("This tool will migrate your configuration from files to the SQLite database.")
    print("Your existing configuration files will not be modified.")
    
    # Initialize database
    try:
        print("\nInitializing database...")
        DB = DBManager(DBPath)
        print(f"Database initialized: {DB.DBPath}")
    except Exception as Error:
        print(f"Error initializing database: {Error}")
        sys.exit(1)
    
    # Initialize file-based configuration
    try:
        print("\nLoading configuration files...")
        Config = ConfigManager(ConfigPath)
        Success = Config.LoadConfig()
        
        if Success:
            print("Configuration loaded successfully.")
        else:
            print("Warning: Configuration loaded with default values.")
    except Exception as Error:
        print(f"Error loading configuration: {Error}")
        sys.exit(1)
    
    # Start migration
    print("\nStarting migration...")
    
    print("\nMigrating application settings...")
    SuccessCount = 0
    TotalCount = len(Config.AppConfig)
    
    # Migrate application settings
    for Key, Value in Config.AppConfig.items():
        try:
            DB.SetAppSetting(Key, Value)
            SuccessCount += 1
            print(f"  • Setting migrated: {Key}")
        except Exception as Error:
            print(f"  × Error migrating setting {Key}: {Error}")
    
    print(f"Migrated {SuccessCount} of {TotalCount} application settings.")
    
    print("\nMigrating user preferences...")
    SuccessCount = 0
    TotalCount = len(Config.UserPreferences)
    
    # Migrate user preferences
    for Key, Value in Config.UserPreferences.items():
        try:
            DB.SetUserPreference(Key, Value)
            SuccessCount += 1
            print(f"  • Preference migrated: {Key}")
        except Exception as Error:
            print(f"  × Error migrating preference {Key}: {Error}")
    
    print(f"Migrated {SuccessCount} of {TotalCount} user preferences.")
    
    print("\nMigrating model configurations...")
    SuccessCount = 0
    TotalCount = 0
    
    # Count total configurations
    for ModelName, ModelConfig in Config.ModelConfigs.items():
        if isinstance(ModelConfig, dict) and not isinstance(list(ModelConfig.values())[0], dict):
            TotalCount += 1
        else:
            TotalCount += len(ModelConfig)
    
    # Migrate model configurations
    for ModelName, ModelConfig in Config.ModelConfigs.items():
        try:
            if isinstance(ModelConfig, dict) and not isinstance(list(ModelConfig.values())[0], dict):
                # This is a single configuration (not a dict of configs)
                DB.SaveModelConfig(ModelName, "Default", ModelConfig)
                SuccessCount += 1
                print(f"  • Model configuration migrated: {ModelName}")
            else:
                # This is a dict of configurations
                for ConfigName, ConfigParams in ModelConfig.items():
                    DB.SaveModelConfig(ModelName, ConfigName, ConfigParams)
                    SuccessCount += 1
                    print(f"  • Model configuration migrated: {ModelName}/{ConfigName}")
        except Exception as Error:
            print(f"  × Error migrating model configuration {ModelName}: {Error}")
    
    print(f"Migrated {SuccessCount} of {TotalCount} model configurations.")
    
    print("\nMigration completed successfully!")
    print(f"Database path: {DB.DBPath}")
    print("\nYou can now use the database for configuration storage.")
    print("To use the database, run the application with the --db flag:")
    print(f"  python Main.py --db {DB.DBPath}")

def ParseCommandLine():
    """
    Parse command line arguments.
    
    Returns:
        Namespace with parsed arguments
    """
    Parser = argparse.ArgumentParser(description="OllamaModelEditor - Configuration Migration Tool")
    Parser.add_argument("--config", help="Path to configuration file")
    Parser.add_argument("--db", help="Path to database file")
    return Parser.parse_args()

if __name__ == "__main__":
    Args = ParseCommandLine()
    MigrateToDatabase(Args.config, Args.db)

================
File: scripts/rename_report.py
================
#!/usr/bin/env python3
import os
import datetime
import shutil

# Get the base directory (project root)
base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Get project name from the base directory
project_name = os.path.basename(base_dir)

# Generate timestamp in a file-friendly format
timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")

# Define source and target files
source_file = os.path.join(base_dir, "repomix-output.txt")
target_file = os.path.join(base_dir, f"CodeBase_{project_name}-{timestamp}.txt")

# Check if source file exists
if os.path.exists(source_file):
    # Copy the file (original remains intact)
    shutil.copy2(source_file, target_file)
    print(f"File copied successfully: {target_file}")
else:
    print(f"Error: Source file {source_file} not found")

================
File: scripts/Setup.bat
================
@echo off
REM File: Setup.bat
REM Path: OllamaModelEditor/scripts/Setup.bat
REM Standard: AIDEV-PascalCase-1.2
REM Created: 2025-03-11
REM Last Modified: 2025-03-11
REM Description: Windows setup script for OllamaModelEditor project

echo === Setting Up Python Virtual Environment ===
python -m venv .venv
call .venv\Scripts\activate.bat

echo === Installing Dependencies ===
pip install -r requirements.txt

echo === Setup Complete ===
echo.
echo Virtual environment created and dependencies installed.
echo To activate the virtual environment in the future, run:
echo   .venv\Scripts\activate.bat
echo.
pause

================
File: scripts/Setup.sh
================
#!/bin/bash
# File: Setup.sh
# Path: OllamaModelEditor/scripts/Setup.sh
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Setup script for OllamaModelEditor project

# Text colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Function to print section headers
PrintHeader() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

# Function to check command existence
CheckCommand() {
    if ! command -v $1 &> /dev/null; then
        echo -e "${RED}Error: $1 is required but not installed.${NC}"
        echo -e "Please install $1 and try again."
        exit 1
    fi
}

# Function to create directories from project structure
CreateDirectories() {
    PrintHeader "Creating Project Structure"
    
    # Main directories
    mkdir -p OllamaModelEditor
    cd OllamaModelEditor
    
    # Create directory structure
    mkdir -p .github/workflows
    mkdir -p .github/ISSUE_TEMPLATE
    mkdir -p Core
    mkdir -p GUI/Assets/{icons,themes,fonts}
    mkdir -p GUI/Components
    mkdir -p GUI/Dialogs
    mkdir -p GUI/Windows
    mkdir -p Tests/{UnitTests,IntegrationTests,UITests}
    mkdir -p Utils
    mkdir -p Features
    mkdir -p docs/screenshots
    mkdir -p scripts
    
    echo -e "${GREEN}Directory structure created successfully.${NC}"
}

# Function to set up virtual environment
SetupVirtualEnv() {
    PrintHeader "Setting Up Python Virtual Environment"
    
    # Create virtual environment
    python3 -m venv .venv
    
    # Activate virtual environment
    source .venv/bin/activate
    
    # Create initial requirements.txt
    cat > requirements.txt << EOF
PySide6>=6.5.0
pytest>=7.3.1
pytest-qt>=4.2.0
requests>=2.28.2
pyyaml>=6.0
loguru>=0.7.0
EOF
    
    # Install requirements
    pip install -r requirements.txt
    
    echo -e "${GREEN}Virtual environment created and dependencies installed.${NC}"
}

# Function to initialize Git repository
SetupGit() {
    PrintHeader "Setting Up Git Repository"
    
    # Initialize git repository
    git init
    
    # Create .gitignore
    cat > .gitignore << EOF
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
.venv/
venv/
ENV/
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# IDE
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Project specific
*.log
.env
EOF
    
    # Create GitHub workflow for CI
    mkdir -p .github/workflows
    cat > .github/workflows/ci.yml << EOF
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Run tests
      run: |
        pytest
EOF
    
    # Create PR template
    cat > .github/PULL_REQUEST_TEMPLATE.md << EOF
## Description
<!-- Provide a brief description of the changes in this PR -->

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Documentation update
- [ ] Code refactoring
- [ ] Other (please describe):

## Testing Performed
<!-- Describe the testing done to verify your changes -->

## Checklist
- [ ] My code follows the AIDEV-PascalCase standards of this project
- [ ] I have performed a self-review of my own code
- [ ] I have added tests that prove my fix is effective or that my feature works
- [ ] New and existing unit tests pass locally with my changes
- [ ] I have updated the documentation accordingly
EOF
    
    # Create issue templates
    cat > .github/ISSUE_TEMPLATE/bug_report.md << EOF
---
name: Bug report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '...'
3. Scroll down to '...'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Environment:**
 - OS: [e.g. Windows, macOS, Linux]
 - Python Version: [e.g. 3.8, 3.9]
 - Application Version: [e.g. 1.0.0]

**Additional context**
Add any other context about the problem here.
EOF
    
    cat > .github/ISSUE_TEMPLATE/feature_request.md << EOF
---
name: Feature request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is.

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
EOF
    
    # Initial commit
    git add .
    git commit -m "Initial project structure"
    
    echo -e "${GREEN}Git repository initialized successfully.${NC}"
}

# Function to set up GitHub remote (if credentials available)
SetupGitHubRemote() {
    PrintHeader "Setting Up GitHub Remote"
    
    echo -e "${YELLOW}Would you like to set up the GitHub remote now? (y/n)${NC}"
    read answer
    
    if [ "$answer" != "${answer#[Yy]}" ]; then
        echo -e "Enter your GitHub username (default: CallMeChewy):"
        read username
        username=${username:-CallMeChewy}
        
        echo -e "Enter the repository name (default: OllamaModelEditor):"
        read repo
        repo=${repo:-OllamaModelEditor}
        
        echo -e "Setting up remote repository..."
        git remote add origin https://github.com/$username/$repo.git
        
        echo -e "${YELLOW}Would you like to push the initial commit to GitHub? (y/n)${NC}"
        read push
        
        if [ "$push" != "${push#[Yy]}" ]; then
            echo -e "Pushing to GitHub..."
            git push -u origin main
            echo -e "${GREEN}Repository pushed to GitHub successfully.${NC}"
        else
            echo -e "${BLUE}Skipping push to GitHub. You can push later with:${NC}"
            echo -e "  git push -u origin main"
        fi
    else
        echo -e "${BLUE}Skipping GitHub remote setup. You can set up later with:${NC}"
        echo -e "  git remote add origin https://github.com/CallMeChewy/OllamaModelEditor.git"
    fi
}

# Function to create Windows setup script
CreateWindowsScript() {
    PrintHeader "Creating Windows Setup Script"
    
    cat > scripts/Setup.bat << EOF
@echo off
REM File: Setup.bat
REM Path: OllamaModelEditor/scripts/Setup.bat
REM Standard: AIDEV-PascalCase-1.2
REM Created: 2025-03-11
REM Last Modified: 2025-03-11
REM Description: Windows setup script for OllamaModelEditor project

echo === Setting Up Python Virtual Environment ===
python -m venv .venv
call .venv\Scripts\activate.bat

echo === Installing Dependencies ===
pip install -r requirements.txt

echo === Setup Complete ===
echo.
echo Virtual environment created and dependencies installed.
echo To activate the virtual environment in the future, run:
echo   .venv\Scripts\activate.bat
echo.
pause
EOF
    
    chmod +x scripts/Setup.bat
    echo -e "${GREEN}Windows setup script created.${NC}"
}

# Function to create initial Main.py
CreateMainPy() {
    PrintHeader "Creating Main.py"
    
    cat > Main.py << EOF
# File: Main.py
# Path: OllamaModelEditor/Main.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Entry point for the OllamaModelEditor application

import sys
from pathlib import Path

# Add project root to path
ProjectRoot = Path(__file__).resolve().parent
sys.path.append(str(ProjectRoot))

# Import GUI components
try:
    from PySide6.QtWidgets import QApplication
    from PySide6.QtCore import QTimer
    from GUI.Windows.MainWindow import MainWindow
    from GUI.Windows.SplashScreen import SplashScreen
except ImportError:
    print("Error: PySide6 is required but not installed.")
    print("Please install dependencies with: pip install -r requirements.txt")
    sys.exit(1)

# Import core components
from Core.LoggingUtils import SetupLogging
from Core.ConfigManager import ConfigManager

def Main():
    """Application entry point."""
    # Initialize logging
    SetupLogging()
    
    # Create application
    App = QApplication(sys.argv)
    App.setApplicationName("OllamaModelEditor")
    App.setOrganizationName("CallMeChewy")
    
    # Initialize configuration
    Config = ConfigManager()
    Config.LoadConfig()
    
    # Create and display splash screen
    Splash = SplashScreen()
    Splash.show()
    
    # Initialize main window
    MainWin = MainWindow(Config)
    
    # Close splash and show main window after delay
    QTimer.singleShot(2000, lambda: ShowMainWindow(Splash, MainWin))
    
    # Start event loop
    return App.exec()

def ShowMainWindow(Splash, MainWin):
    """Close splash screen and show main window."""
    Splash.finish(MainWin)
    MainWin.show()

if __name__ == "__main__":
    sys.exit(Main())
EOF
    
    echo -e "${GREEN}Main.py created successfully.${NC}"
}

# Function to create README.md
CreateReadme() {
    PrintHeader "Creating README.md"
    
    cat > README.md << EOF
# OLLAMA MODEL EDITOR

**A powerful tool for customizing and optimizing Ollama AI models**

[Features](#features) • [Installation](#installation) • [Usage](#usage) • [Documentation](#documentation) • [Contributing](#contributing) • [License](#license)

## About

Ollama Model Editor is a comprehensive GUI application that allows you to customize, optimize, and manage your Ollama AI models. This tool provides an intuitive interface for adjusting model parameters, comparing performance across different configurations, and streamlining your AI workflow.

**This project is a collaboration between human developers and AI assistants, demonstrating the power of human-AI teamwork in software development.**

## Features

- 🎛️ **Parameter Customization**: Fine-tune model parameters through an intuitive GUI
- 📊 **Performance Benchmarking**: Compare different model configurations side-by-side
- 🔄 **Model Management**: Easily manage multiple Ollama models in one interface
- 🎯 **Optimization Presets**: Apply pre-configured optimization settings for specific use cases
- 📝 **Detailed Analysis**: Get insights into how parameter changes affect model performance
- 🌓 **Theming Support**: Choose between light and dark themes for comfortable usage
- 💾 **Configuration Export**: Share your optimized model configurations with others

## Installation

### Prerequisites

- Python 3.8 or higher
- Ollama installed and running on your system
- Git (for cloning the repository)

### Setup

```bash
# Clone the repository
git clone https://github.com/CallMeChewy/OllamaModelEditor.git
cd OllamaModelEditor

# Create a virtual environment
python -m venv .venv
source .venv/bin/activate # On Windows: .venv\\Scripts\\activate

# Install dependencies
pip install -r requirements.txt

# Run the application
python Main.py
```

## Usage

1. Launch the application with **python Main.py**
2. Select an Ollama model from the dropdown menu
3. Adjust parameters using the intuitive interface
4. Compare performance with different settings
5. Save your optimized configuration
6. Export settings to share with the community

For more detailed instructions, see the [Quick Start Guide](docs/QuickStartGuide.md).

## Documentation

- [Quick Start Guide](docs/QuickStartGuide.md)
- [Core Components](Core/README.md)
- [Parameter Reference](docs/parameters.md)
- [Advanced Usage](docs/advanced_usage.md)

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (**git checkout -b feature/amazing-feature**)
3. Commit your changes (**git commit -m 'Add some amazing feature'**)
4. Push to the branch (**git push origin feature/amazing-feature**)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgements

- This project is a collaboration between human developers and AI assistants
- Special thanks to the Ollama project for making powerful AI models accessible
- Developed by Herbert J. Bowers (Herb@BowersWorld.com)
EOF
    
    echo -e "${GREEN}README.md created successfully.${NC}"
}

# Function to create MIT license
CreateLicense() {
    PrintHeader "Creating LICENSE"
    
    cat > LICENSE << EOF
MIT License

Copyright (c) 2025 Herbert J. Bowers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
EOF
    
    echo -e "${GREEN}LICENSE created successfully.${NC}"
}

# Main execution
PrintHeader "OllamaModelEditor Project Setup"

# Check for required commands
CheckCommand "python3"
CheckCommand "git"

# Create project structure
CreateDirectories

# Setup tasks
SetupVirtualEnv
SetupGit
CreateWindowsScript
CreateMainPy
CreateReadme
CreateLicense
SetupGitHubRemote

PrintHeader "Setup Complete"
echo -e "${GREEN}OllamaModelEditor project has been successfully set up!${NC}"
echo -e "\nTo activate the virtual environment:"
echo -e "  ${BLUE}source .venv/bin/activate${NC}"
echo -e "\nTo start the application:"
echo -e "  ${BLUE}python Main.py${NC}"
echo -e "\nHappy coding! 🚀"

================
File: scripts/SimpleGitHubSetup.sh
================
#!/bin/bash
# File: SimpleGitHubSetup.sh
# Path: OllamaModelEditor/scripts/SimpleGitHubSetup.sh
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Simple script to reset and initialize GitHub repository

# Text colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Function to print section headers
PrintHeader() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

# Check if git is installed
if ! command -v git &> /dev/null; then
    echo -e "${RED}Error: git is required but not installed.${NC}"
    echo -e "Please install git and try again."
    exit 1
fi

PrintHeader "GitHub Repository Setup"

# GitHub username and repository name
GITHUB_USERNAME="CallMeChewy"
REPO_NAME="OllamaModelEditor"

echo -e "This script will set up your GitHub repository for:"
echo -e "  ${GREEN}$GITHUB_USERNAME/$REPO_NAME${NC}"
echo -e "\n${YELLOW}Is this correct? (y/n)${NC}"
read answer

if [ "$answer" != "${answer#[Yy]}" ]; then
    # Make sure we're in the project root directory (where Main.py is)
    if [ ! -f "Main.py" ]; then
        echo -e "${RED}Error: Main.py not found. Please run this script from the project root directory.${NC}"
        exit 1
    fi

    PrintHeader "Initializing Git Repository"
    
    # Remove any existing git directory
    echo -e "Removing any existing Git data..."
    rm -rf .git
    
    # Initialize new git repository
    echo -e "Initializing new Git repository..."
    git init
    
    # Create .gitignore file
    echo -e "Creating .gitignore file..."
    cat > .gitignore << EOF
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
.venv/
venv/
ENV/
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# IDE
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Project specific
*.log
.env

# Custom exclusions
..Exclude/
..Scripts/
..Next/
..Vision/
EOF
    
    # Add all files
    echo -e "Adding files to Git..."
    git add .
    
    # Make initial commit
    echo -e "Creating initial commit..."
    git commit -m "Initial commit of OllamaModelEditor project"
    
    PrintHeader "Connecting to GitHub"
    
    # Add GitHub as remote origin
    echo -e "Adding GitHub remote..."
    git remote add origin https://github.com/$GITHUB_USERNAME/$REPO_NAME.git
    
    echo -e "${YELLOW}Do you want to push to GitHub now? (y/n)${NC}"
    echo -e "${YELLOW}Note: This will overwrite any existing content in your GitHub repository.${NC}"
    read push_now
    
    if [ "$push_now" != "${push_now#[Yy]}" ]; then
        PrintHeader "Pushing to GitHub"
        
        echo -e "Enter your GitHub username: $GITHUB_USERNAME"
        
        # Force push to overwrite any existing content
        echo -e "Pushing to GitHub (you'll be prompted for your password or access token)..."
        git push -f origin master
        
        # Check if push was successful
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Successfully pushed to GitHub!${NC}"
            echo -e "Your repository is now available at: ${BLUE}https://github.com/$GITHUB_USERNAME/$REPO_NAME${NC}"
        else
            echo -e "${RED}Push failed.${NC}"
            echo -e "You may need to:"
            echo -e "1. Create a personal access token on GitHub:"
            echo -e "   ${BLUE}https://github.com/settings/tokens${NC}"
            echo -e "2. Use that token as your password when prompted"
            echo -e "\nOr push manually with:"
            echo -e "  git push -f origin master"
        fi
    else
        echo -e "${BLUE}Skipping push to GitHub. You can push later with:${NC}"
        echo -e "  git push -f origin master"
    fi
    
    PrintHeader "Setup Complete"
    echo -e "${GREEN}Your repository has been set up successfully!${NC}"
    
else
    echo -e "${RED}Operation cancelled.${NC}"
    exit 1
fi

================
File: scripts/UpdateGitHub.sh
================
#!/bin/bash
# File: UpdateGitHub.sh
# Path: OllamaModelEditor/scripts/UpdateGitHub.sh
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Updates existing GitHub repository with new project structure

# Text colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Function to print section headers
PrintHeader() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

# Check if git is installed
if ! command -v git &> /dev/null; then
    echo -e "${RED}Error: git is required but not installed.${NC}"
    echo -e "Please install git and try again."
    exit 1
fi

# Check if we're in a git repository
if ! git rev-parse --is-inside-work-tree &> /dev/null; then
    echo -e "${RED}Error: Not in a git repository.${NC}"
    echo -e "Please run this script from within your OllamaModelEditor git repository."
    exit 1
fi

PrintHeader "Updating GitHub Repository"

# Define repository details
GITHUB_USERNAME="CallMeChewy"
PROJECT_NAME="OllamaModelEditor"
EXPECTED_REPO_URL="https://github.com/$GITHUB_USERNAME/$PROJECT_NAME.git"

# Verify repository
echo -e "${YELLOW}Current repository:${NC}"
ACTUAL_REPO_URL=$(git config --get remote.origin.url)
echo -e "Expected repository: ${GREEN}$GITHUB_USERNAME/$PROJECT_NAME${NC}"
echo -e "Expected URL: ${GREEN}$EXPECTED_REPO_URL${NC}"
echo -e "\nActual repository URL: ${BLUE}$ACTUAL_REPO_URL${NC}"
echo -e "\nRemote details:"
git remote -v

# Check if this is the expected repository
if [[ "$ACTUAL_REPO_URL" == "$EXPECTED_REPO_URL" || "$ACTUAL_REPO_URL" == "git@github.com:$GITHUB_USERNAME/$PROJECT_NAME.git" ]]; then
    echo -e "\n${GREEN}✓ This is the correct repository.${NC}"
else
    echo -e "\n${YELLOW}⚠️ Warning: The current repository does not match the expected repository.${NC}"
fi

echo -e "\n${YELLOW}Is this the correct repository you want to update? (y/n)${NC}"
read answer
if [ "$answer" != "${answer#[Yy]}" ]; then
    # Proceed with update
    PrintHeader "Backing up any existing changes"
    
    # Check if there are uncommitted changes
    if ! git diff --quiet HEAD; then
        # Create backup branch with timestamp
        BACKUP_BRANCH="backup_$(date +%Y%m%d_%H%M%S)"
        echo -e "Creating backup branch: ${BACKUP_BRANCH}"
        git checkout -b $BACKUP_BRANCH
        git add .
        git commit -m "Backup before repository update"
        echo -e "${GREEN}Backup created on branch: ${BACKUP_BRANCH}${NC}"
        
        # Switch back to main branch
        git checkout main || git checkout master
    else
        echo -e "No uncommitted changes to backup."
    fi
    
    PrintHeader "Preparing for update"
    
    # Ask if user wants to keep any specific files
    echo -e "${YELLOW}Do you want to keep any specific files from the current repository? (y/n)${NC}"
    read keep_files
    if [ "$keep_files" != "${keep_files#[Yy]}" ]; then
        echo -e "Please enter file/directory patterns to keep, separated by spaces:"
        echo -e "(For example: README.md LICENSE .github/workflows)"
        read -a files_to_keep
        
        # Create a temporary directory to store files
        TEMP_DIR=$(mktemp -d)
        echo -e "Temporarily storing files in: ${TEMP_DIR}"
        
        # Copy files to keep to temp directory
        for file in "${files_to_keep[@]}"; do
            if [ -e "$file" ]; then
                # Create directory structure in temp
                mkdir -p "$TEMP_DIR/$(dirname "$file")"
                cp -r "$file" "$TEMP_DIR/$(dirname "$file")/"
                echo -e "Saved: $file"
            else
                echo -e "${YELLOW}Warning: $file not found${NC}"
            fi
        done
    fi
    
    PrintHeader "Removing existing files"
    
    # Get root directory of the git repository
    REPO_ROOT=$(git rev-parse --show-toplevel)
    
    # Remove all files except .git directory and temporary script
    find "$REPO_ROOT" -mindepth 1 -not -path "$REPO_ROOT/.git*" -not -path "$0" | xargs rm -rf
    
    echo -e "${GREEN}Repository cleaned successfully.${NC}"
    
    # Restore kept files if any
    if [ "$keep_files" != "${keep_files#[Yy]}" ] && [ -d "$TEMP_DIR" ]; then
        echo -e "Restoring files you chose to keep..."
        cp -r "$TEMP_DIR"/* "$REPO_ROOT"/ 2>/dev/null || true
        rm -rf "$TEMP_DIR"
    fi
    
    PrintHeader "Adding new project files"
    
    # Assuming we're in the OllamaModelEditor directory
    echo -e "Copying new files to repository..."
    
    # Get the current directory
    CURRENT_DIR=$(pwd)
    
    # Copy all project files to the repository root
    rsync -av --exclude='.git/' --exclude='scripts/UpdateGitHub.sh' "$CURRENT_DIR"/* "$REPO_ROOT"/
    
    echo -e "${GREEN}New files copied successfully.${NC}"
    
    PrintHeader "Committing changes"
    
    # Add all new files
    git add .
    
    # Commit changes
    git commit -m "Complete project restructure to AIDEV-PascalCase standards"
    
    echo -e "${GREEN}Changes committed successfully.${NC}"
    
    PrintHeader "Push to GitHub"
    
    echo -e "${YELLOW}Do you want to push these changes to GitHub now? (y/n)${NC}"
    read push_now
    if [ "$push_now" != "${push_now#[Yy]}" ]; then
        # Determine default branch name
        DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
        
        echo -e "Pushing to ${DEFAULT_BRANCH} branch..."
        git push origin $DEFAULT_BRANCH
        
        echo -e "${GREEN}Changes pushed to GitHub successfully.${NC}"
    else
        echo -e "${BLUE}Changes were not pushed. You can push manually with:${NC}"
        echo -e "  git push origin main  # or 'master' depending on your default branch"
    fi
    
    PrintHeader "Update Complete"
    echo -e "${GREEN}Your GitHub repository has been updated successfully!${NC}"
    
else
    echo -e "${RED}Operation cancelled.${NC}"
    exit 1
fi

================
File: Tests/UnitTests/TestConfigManager.py
================
# File: TestConfigManager.py
# Path: OllamaModelEditor/Tests/UnitTests/TestConfigManager.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Unit tests for the ConfigManager module

import os
import sys
import json
import yaml
import tempfile
import unittest
from pathlib import Path
from typing import Dict, Any

# Add project root to path for imports
ProjectRoot = Path(__file__).resolve().parents[2]
sys.path.append(str(ProjectRoot))

# Import the module to test
from Core.ConfigManager import ConfigManager

class TestConfigManager(unittest.TestCase):
    """Test case for the ConfigManager class."""
    
    def setUp(self):
        """Set up test fixtures."""
        # Create a temporary directory for test files
        self.TempDir = tempfile.TemporaryDirectory()
        self.ConfigPath = os.path.join(self.TempDir.name, "test_config.yaml")
        
        # Create a ConfigManager instance with the test path
        self.ConfigManager = ConfigManager(self.ConfigPath)
    
    def tearDown(self):
        """Tear down test fixtures."""
        # Clean up temporary directory
        self.TempDir.cleanup()
    
    def test_InitialState(self):
        """Test initial state of ConfigManager."""
        # Check that ConfigPath is set correctly
        self.assertEqual(self.ConfigManager.ConfigPath, self.ConfigPath)
        
        # Check that initial dictionaries are empty
        self.assertEqual(self.ConfigManager.AppConfig, {})
        self.assertEqual(self.ConfigManager.ModelConfigs, {})
        self.assertEqual(self.ConfigManager.UserPreferences, {})
    
    def test_CreateDefaultConfig(self):
        """Test creation of default configuration."""
        # Call method to create default configuration
        self.ConfigManager._CreateDefaultConfig()
        
        # Check that AppConfig contains expected default values
        self.assertIn('Version', self.ConfigManager.AppConfig)
        self.assertIn('APIEndpoint', self.ConfigManager.AppConfig)
        self.assertIn('LogLevel', self.ConfigManager.AppConfig)
        
        # Check that ModelConfigs contains DefaultParameters
        self.assertIn('DefaultParameters', self.ConfigManager.ModelConfigs)
        
        # Check that UserPreferences contains expected default values
        self.assertIn('UIFontSize', self.ConfigManager.UserPreferences)
        self.assertIn('EditorFontFamily', self.ConfigManager.UserPreferences)
    
    def test_SaveAndLoadConfig(self):
        """Test saving and loading configuration."""
        # Set test values
        TestAppConfig = {
            'Version': '1.0.0-test',
            'APIEndpoint': 'http://test-endpoint:11434',
            'LogLevel': 'DEBUG'
        }
        
        TestModelConfigs = {
            'DefaultParameters': {
                'Temperature': 0.5,
                'TopP': 0.8,
                'MaxTokens': 1000
            },
            'TestModel': {
                'Temperature': 0.7,
                'TopP': 0.9,
                'MaxTokens': 2000
            }
        }
        
        TestUserPreferences = {
            'UIFontSize': 14,
            'EditorFontFamily': 'Test Font',
            'ShowWelcomeOnStartup': False
        }
        
        # Set values in ConfigManager
        self.ConfigManager.AppConfig = TestAppConfig
        self.ConfigManager.ModelConfigs = TestModelConfigs
        self.ConfigManager.UserPreferences = TestUserPreferences
        
        # Save configuration
        SaveResult = self.ConfigManager.SaveConfig()
        self.assertTrue(SaveResult, "SaveConfig should return True")
        
        # Check that file was created
        self.assertTrue(os.path.exists(self.ConfigPath), "Config file should exist")
        
        # Create a new ConfigManager instance to load the saved configuration
        NewConfigManager = ConfigManager(self.ConfigPath)
        
        # Load configuration
        LoadResult = NewConfigManager.LoadConfig()
        self.assertTrue(LoadResult, "LoadConfig should return True")
        
        # Check that loaded values match original values
        self.assertEqual(NewConfigManager.AppConfig, TestAppConfig)
        self.assertEqual(NewConfigManager.ModelConfigs, TestModelConfigs)
        self.assertEqual(NewConfigManager.UserPreferences, TestUserPreferences)
    
    def test_GetSetAppConfig(self):
        """Test get and set methods for AppConfig."""
        # Set test values
        self.ConfigManager.SetAppConfig('TestKey', 'TestValue')
        self.ConfigManager.SetAppConfig('AnotherKey', 123)
        
        # Get values
        TestValue = self.ConfigManager.GetAppConfig('TestKey')
        AnotherValue = self.ConfigManager.GetAppConfig('AnotherKey')
        
        # Check values
        self.assertEqual(TestValue, 'TestValue')
        self.assertEqual(AnotherValue, 123)
        
        # Get default value for non-existent key
        NonExistentValue = self.ConfigManager.GetAppConfig('NonExistentKey', 'DefaultValue')
        self.assertEqual(NonExistentValue, 'DefaultValue')
        
        # Get entire AppConfig
        EntireConfig = self.ConfigManager.GetAppConfig()
        self.assertEqual(EntireConfig, {
            'TestKey': 'TestValue',
            'AnotherKey': 123
        })
    
    def test_GetSetModelConfig(self):
        """Test get and set methods for ModelConfigs."""
        # Define test model configuration
        TestModelConfig = {
            'Temperature': 0.8,
            'TopP': 0.95,
            'MaxTokens': 1500
        }
        
        # Set model configuration
        self.ConfigManager.SetModelConfig('TestModel', TestModelConfig)
        
        # Get model configuration
        ModelConfig = self.ConfigManager.GetModelConfig('TestModel')
        
        # Check that retrieved configuration matches
        self.assertEqual(ModelConfig, TestModelConfig)
        
        # Get configuration for non-existent model (should return DefaultParameters)
        # First set DefaultParameters
        DefaultConfig = {
            'Temperature': 0.7,
            'TopP': 0.9,
            'MaxTokens': 2000
        }
        self.ConfigManager.SetModelConfig('DefaultParameters', DefaultConfig)
        
        # Get non-existent model
        NonExistentModel = self.ConfigManager.GetModelConfig('NonExistentModel')
        
        # Should return DefaultParameters
        self.assertEqual(NonExistentModel, DefaultConfig)
    
    def test_GetSetUserPreference(self):
        """Test get and set methods for UserPreferences."""
        # Set test values
        self.ConfigManager.SetUserPreference('TestPref', 'TestValue')
        self.ConfigManager.SetUserPreference('AnotherPref', 456)
        
        # Get values
        TestValue = self.ConfigManager.GetUserPreference('TestPref')
        AnotherValue = self.ConfigManager.GetUserPreference('AnotherPref')
        
        # Check values
        self.assertEqual(TestValue, 'TestValue')
        self.assertEqual(AnotherValue, 456)
        
        # Get default value for non-existent key
        NonExistentValue = self.ConfigManager.GetUserPreference('NonExistentPref', 'DefaultValue')
        self.assertEqual(NonExistentValue, 'DefaultValue')
    
    def test_AddRecentModel(self):
        """Test adding models to recent models list."""
        # Initially recent models should be empty
        RecentModels = self.ConfigManager.GetUserPreference('RecentModels', [])
        self.assertEqual(RecentModels, [])
        
        # Add a model
        self.ConfigManager.AddRecentModel('Model1')
        RecentModels = self.ConfigManager.GetUserPreference('RecentModels', [])
        self.assertEqual(RecentModels, ['Model1'])
        
        # Add another model
        self.ConfigManager.AddRecentModel('Model2')
        RecentModels = self.ConfigManager.GetUserPreference('RecentModels', [])
        self.assertEqual(RecentModels, ['Model2', 'Model1'])
        
        # Add the first model again (should move to front)
        self.ConfigManager.AddRecentModel('Model1')
        RecentModels = self.ConfigManager.GetUserPreference('RecentModels', [])
        self.assertEqual(RecentModels, ['Model1', 'Model2'])
        
        # Add models until we exceed the limit of 10
        for i in range(3, 12):
            self.ConfigManager.AddRecentModel(f'Model{i}')
        
        # Check that we only have 10 models and the oldest is removed
        RecentModels = self.ConfigManager.GetUserPreference('RecentModels', [])
        self.assertEqual(len(RecentModels), 10)
        self.assertEqual(RecentModels[0], 'Model11')
        self.assertNotIn('Model2', RecentModels)
    
    def test_ExportModelConfig(self):
        """Test exporting model configuration to a file."""
        # Define test model configuration
        TestModelConfig = {
            'Temperature': 0.8,
            'TopP': 0.95,
            'MaxTokens': 1500
        }
        
        # Set model configuration
        self.ConfigManager.SetModelConfig('TestModel', TestModelConfig)
        
        # Export to JSON
        JsonPath = os.path.join(self.TempDir.name, "test_export.json")
        JsonResult = self.ConfigManager.ExportModelConfig('TestModel', JsonPath)
        self.assertTrue(JsonResult, "ExportModelConfig should return True for JSON")
        self.assertTrue(os.path.exists(JsonPath), "JSON export file should exist")
        
        # Read exported JSON and verify
        with open(JsonPath, 'r') as JsonFile:
            ExportedJson = json.load(JsonFile)
        self.assertEqual(ExportedJson, TestModelConfig)
        
        # Export to YAML
        YamlPath = os.path.join(self.TempDir.name, "test_export.yaml")
        YamlResult = self.ConfigManager.ExportModelConfig('TestModel', YamlPath)
        self.assertTrue(YamlResult, "ExportModelConfig should return True for YAML")
        self.assertTrue(os.path.exists(YamlPath), "YAML export file should exist")
        
        # Read exported YAML and verify
        with open(YamlPath, 'r') as YamlFile:
            ExportedYaml = yaml.safe_load(YamlFile)
        self.assertEqual(ExportedYaml, TestModelConfig)
        
        # Test export for non-existent model
        NonExistentResult = self.ConfigManager.ExportModelConfig('NonExistentModel', JsonPath)
        self.assertFalse(NonExistentResult, "ExportModelConfig should return False for non-existent model")
        
        # Test export with unsupported format
        BadFormatPath = os.path.join(self.TempDir.name, "test_export.txt")
        BadFormatResult = self.ConfigManager.ExportModelConfig('TestModel', BadFormatPath)
        self.assertFalse(BadFormatResult, "ExportModelConfig should return False for unsupported format")
    
    def test_ValidateModelConfig(self):
        """Test validation of model configuration."""
        # Valid configuration
        ValidConfig = {
            'Temperature': 0.8,
            'TopP': 0.9,
            'MaxTokens': 2000
        }
        self.assertTrue(self.ConfigManager._ValidateModelConfig(ValidConfig))
        
        # Missing required parameter
        MissingParam = {
            'Temperature': 0.8,
            'TopP': 0.9
            # Missing MaxTokens
        }
        self.assertFalse(self.ConfigManager._ValidateModelConfig(MissingParam))
        
        # Invalid Temperature (too high)
        InvalidTemp = {
            'Temperature': 3.0,  # Should be between 0 and 2
            'TopP': 0.9,
            'MaxTokens': 2000
        }
        self.assertFalse(self.ConfigManager._ValidateModelConfig(InvalidTemp))
        
        # Invalid TopP (too high)
        InvalidTopP = {
            'Temperature': 0.8,
            'TopP': 1.5,  # Should be between 0 and 1
            'MaxTokens': 2000
        }
        self.assertFalse(self.ConfigManager._ValidateModelConfig(InvalidTopP))
        
        # Invalid MaxTokens (negative)
        InvalidTokens = {
            'Temperature': 0.8,
            'TopP': 0.9,
            'MaxTokens': -100  # Should be positive
        }
        self.assertFalse(self.ConfigManager._ValidateModelConfig(InvalidTokens))

if __name__ == '__main__':
    unittest.main()

================
File:  test_pyside.py
================
# test_pyside.py
import sys
print(f"Python version: {sys.version}")
print(f"Python path: {sys.path}")

try:
    from PySide6.QtWidgets import QApplication
    from PySide6.QtCore import QTimer
    print("Basic PySide6 imports successful")
    
    # Now try to import your custom modules
    print("Trying to import custom modules...")
    from GUI.Windows.MainWindow import MainWindow
    from GUI.Windows.SplashScreen import SplashScreen
    print("GUI modules imported successfully")
    
    from Core.LoggingUtils import SetupLogging
    from Core.ConfigManager import ConfigManager
    print("Core modules imported successfully")
    
except ImportError as e:
    print(f"Import error: {e}")

================
File: .gitignore
================
# Python
__pycache__/
*.py[cod]
*.class
*.so
.Python
.venv/
venv/
ENV/
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# IDE
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Project specific
*.log
.env

# Custom exclusions
..Exclude/
..Scripts/
..Next/
..Vision/

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Herbert J. Bowers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: Main.py
================
# File: Main.py
# Path: OllamaModelEditor/Main.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-13 15:30PM
# Description: Entry point for the OllamaModelEditor application

import sys
import logging
import os
from pathlib import Path
import argparse
import time

# Add project root to path
ProjectRoot = Path(__file__).resolve().parent
sys.path.append(str(ProjectRoot))

# Set up basic logging
logging.basicConfig(level=logging.INFO, 
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
RootLogger = logging.getLogger('OllamaModelEditor')
RootLogger.info("Starting OllamaModelEditor")

def ParseCommandLine():
    """
    Parse command line arguments.
    
    Returns:
        Namespace with parsed arguments
    """
    Parser = argparse.ArgumentParser(description="OllamaModelEditor - A tool for managing Ollama AI models")
    Parser.add_argument("--config", help="Path to configuration file")
    Parser.add_argument("--db", help="Path to database file")
    Parser.add_argument("--migrate", action="store_true", help="Migrate from file config to database")
    Parser.add_argument("--migrate-schema", action="store_true", help="Migrate database schema to PascalCase")
    Parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    return Parser.parse_args()

def ShowErrorAndExit(Message, Error=None):
    """
    Show error message and exit.
    
    Args:
        Message: Error message to display
        Error: Optional exception object
    """
    ErrorText = f"{Message}"
    if Error:
        ErrorText += f"\nError: {Error}"
    
    RootLogger.error(ErrorText)
    
    # Try to show GUI error message if PySide6 is available
    try:
        from PySide6.QtWidgets import QApplication, QMessageBox
        App = QApplication([])
        QMessageBox.critical(None, "Error", ErrorText)
    except ImportError:
        # Fall back to console error
        print(f"ERROR: {ErrorText}")
    
    sys.exit(1)

def MigrateDBSchema(DBPath):
    """
    Migrate database schema to PascalCase.
    
    Args:
        DBPath: Path to database file
    
    Returns:
        True if successful, False otherwise
    """
    try:
        # Check if the migration script exists
        MigrationScriptPath = str(ProjectRoot / "scripts" / "MigrateDBToPascalCase.py")
        if not os.path.exists(MigrationScriptPath):
            RootLogger.error(f"Migration script not found: {MigrationScriptPath}")
            return False
        
        # Import and run migration script
        from scripts.MigrateDBToPascalCase import MigrateDatabase
        
        # Create backup first
        BackupPath = f"{DBPath}.backup_{int(time.time())}"
        RootLogger.info(f"Creating database backup at {BackupPath}")
        
        import shutil
        shutil.copy2(DBPath, BackupPath)
        
        # Run migration
        RootLogger.info("Starting database schema migration to PascalCase...")
        Success = MigrateDatabase(DBPath)
        
        if Success:
            RootLogger.info("Database schema migration completed successfully")
            return True
        else:
            RootLogger.error("Database schema migration failed")
            return False
    except Exception as Error:
        RootLogger.error(f"Error migrating database schema: {Error}")
        return False

def Main():
    """Application entry point."""
    # Parse command line arguments
    Args = ParseCommandLine()
    
    # Set log level based on arguments
    LogLevel = logging.DEBUG if Args.debug else logging.INFO
    
    # Import Core modules
    try:
        from Core.LoggingUtils import SetupLogging
        Logger = SetupLogging(LogLevel=LogLevel, LogToFile=True)
        Logger.info("Logging initialized")
        
        from Core.DBManager import DBManager
        from Core.ConfigManager import ConfigManager
        Logger.info("Core modules imported")
    except ImportError as Error:
        ShowErrorAndExit("Failed to import Core modules", Error)
    
    # Import PySide6 components
    try:
        from PySide6.QtWidgets import QApplication, QMainWindow, QMessageBox, QSplashScreen
        from PySide6.QtCore import QTimer
        Logger.info("PySide6 modules imported")
    except ImportError as Error:
        ShowErrorAndExit("PySide6 is required but not installed.\nPlease install dependencies with: pip install -r requirements.txt", Error)
    
    # Import GUI components
    try:
        from GUI.Windows.MainWindow import MainWindow
        from GUI.Windows.SplashScreen import SplashScreen
        Logger.info("GUI modules imported")
    except ImportError as Error:
        ShowErrorAndExit("Failed to import GUI modules", Error)
    
    # Initialize database if path provided
    DBInstance = None
    if Args.db:
        try:
            # Check if schema migration is requested
            if Args.migrate_schema and os.path.exists(Args.db):
                MigrateResult = MigrateDBSchema(Args.db)
                if not MigrateResult:
                    Logger.warning("Database schema migration failed, proceeding with existing schema")
            
            # Initialize database
            DBInstance = DBManager(Args.db)
            Logger.info(f"Database initialized: {DBInstance.DBPath}")
        except Exception as Error:
            ShowErrorAndExit(f"Failed to initialize database: {Args.db}", Error)
    
    # Create application
    App = QApplication(sys.argv)
    App.setApplicationName("OllamaModelEditor")
    App.setOrganizationName("OllamaModelEditor")
    
    # Initialize configuration
    try:
        Config = ConfigManager(Args.config, DBInstance)
        
        # Migrate from file to database if requested
        if Args.migrate and DBInstance:
            try:
                Logger.info("Migrating configuration from file to database...")
                Success = Config.MigrateToDatabase(DBInstance)
                if Success:
                    Logger.info("Configuration migrated successfully")
                else:
                    Logger.warning("Configuration migration failed")
            except Exception as Error:
                Logger.error(f"Error migrating configuration: {Error}")
        
        # Load configuration
        Config.LoadConfig()
        Logger.info("Configuration loaded")
    except Exception as Error:
        ShowErrorAndExit("Failed to load configuration", Error)
    
    # Create and display splash screen
    try:
        Splash = SplashScreen()
        Splash.show()
        Logger.info("Splash screen displayed")
    except Exception as Error:
        Logger.error(f"Error creating splash screen: {Error}")
        # Continue without splash screen
        Splash = None
    
    # Initialize main window
    try:
        MainWin = MainWindow(Config)
        Logger.info("Main window created")
        
        # Close splash and show main window after delay
        if Splash:
            QTimer.singleShot(2000, lambda: ShowMainWindow(Splash, MainWin))
        else:
            MainWin.show()
    except Exception as Error:
        ShowErrorAndExit("Failed to create main window", Error)
    
    # Start event loop
    Logger.info("Starting application event loop")
    return App.exec()

def ShowMainWindow(Splash, MainWin):
    """Close splash screen and show main window."""
    try:
        Splash.finish(MainWin)
        MainWin.show()
    except Exception as Error:
        RootLogger.error(f"Error showing main window: {Error}")
        MainWin.show()

if __name__ == "__main__":
    sys.exit(Main())

================
File: README.md
================
# OLLAMA MODEL EDITOR

**A powerful tool for customizing and optimizing Ollama AI models**

[Features](#features) • [Installation](#installation) • [Usage](#usage) • [Documentation](#documentation) • [Contributing](#contributing) • [License](#license)

## About

Ollama Model Editor is a comprehensive GUI application that allows you to customize, optimize, and manage your Ollama AI models. This tool provides an intuitive interface for adjusting model parameters, comparing performance across different configurations, and streamlining your AI workflow.

**This project is a collaboration between human developers and AI assistants, demonstrating the power of human-AI teamwork in software development.**

## Features

- 🎛️ **Parameter Customization**: Fine-tune model parameters through an intuitive GUI
- 📊 **Performance Benchmarking**: Compare different model configurations side-by-side
- 🔄 **Model Management**: Easily manage multiple Ollama models in one interface
- 🎯 **Optimization Presets**: Apply pre-configured optimization settings for specific use cases
- 📝 **Detailed Analysis**: Get insights into how parameter changes affect model performance
- 🌓 **Theming Support**: Choose between light and dark themes for comfortable usage
- 💾 **Configuration Export**: Share your optimized model configurations with others

## Installation

### Prerequisites

- Python 3.8 or higher
- Ollama installed and running on your system
- Git (for cloning the repository)

### Setup

Collecting PySide6>=6.5.0 (from -r requirements.txt (line 1))
  Using cached PySide6-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl.metadata (5.3 kB)
Collecting pytest>=7.3.1 (from -r requirements.txt (line 2))
  Using cached pytest-8.3.5-py3-none-any.whl.metadata (7.6 kB)
Collecting pytest-qt>=4.2.0 (from -r requirements.txt (line 3))
  Using cached pytest_qt-4.4.0-py3-none-any.whl.metadata (7.7 kB)
Collecting requests>=2.28.2 (from -r requirements.txt (line 4))
  Using cached requests-2.32.3-py3-none-any.whl.metadata (4.6 kB)
Collecting pyyaml>=6.0 (from -r requirements.txt (line 5))
  Using cached PyYAML-6.0.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.1 kB)
Collecting loguru>=0.7.0 (from -r requirements.txt (line 6))
  Using cached loguru-0.7.3-py3-none-any.whl.metadata (22 kB)
Collecting shiboken6==6.8.2.1 (from PySide6>=6.5.0->-r requirements.txt (line 1))
  Using cached shiboken6-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl.metadata (2.5 kB)
Collecting PySide6-Essentials==6.8.2.1 (from PySide6>=6.5.0->-r requirements.txt (line 1))
  Using cached PySide6_Essentials-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl.metadata (3.7 kB)
Collecting PySide6-Addons==6.8.2.1 (from PySide6>=6.5.0->-r requirements.txt (line 1))
  Using cached PySide6_Addons-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl.metadata (4.0 kB)
Collecting iniconfig (from pytest>=7.3.1->-r requirements.txt (line 2))
  Using cached iniconfig-2.0.0-py3-none-any.whl.metadata (2.6 kB)
Collecting packaging (from pytest>=7.3.1->-r requirements.txt (line 2))
  Using cached packaging-24.2-py3-none-any.whl.metadata (3.2 kB)
Collecting pluggy<2,>=1.5 (from pytest>=7.3.1->-r requirements.txt (line 2))
  Using cached pluggy-1.5.0-py3-none-any.whl.metadata (4.8 kB)
Collecting charset-normalizer<4,>=2 (from requests>=2.28.2->-r requirements.txt (line 4))
  Using cached charset_normalizer-3.4.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (35 kB)
Collecting idna<4,>=2.5 (from requests>=2.28.2->-r requirements.txt (line 4))
  Using cached idna-3.10-py3-none-any.whl.metadata (10 kB)
Collecting urllib3<3,>=1.21.1 (from requests>=2.28.2->-r requirements.txt (line 4))
  Using cached urllib3-2.3.0-py3-none-any.whl.metadata (6.5 kB)
Collecting certifi>=2017.4.17 (from requests>=2.28.2->-r requirements.txt (line 4))
  Using cached certifi-2025.1.31-py3-none-any.whl.metadata (2.5 kB)
Using cached PySide6-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl (550 kB)
Using cached PySide6_Addons-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl (160.6 MB)
Using cached PySide6_Essentials-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl (95.3 MB)
Using cached shiboken6-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl (204 kB)
Using cached pytest-8.3.5-py3-none-any.whl (343 kB)
Using cached pytest_qt-4.4.0-py3-none-any.whl (36 kB)
Using cached requests-2.32.3-py3-none-any.whl (64 kB)
Using cached PyYAML-6.0.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (767 kB)
Using cached loguru-0.7.3-py3-none-any.whl (61 kB)
Using cached certifi-2025.1.31-py3-none-any.whl (166 kB)
Using cached charset_normalizer-3.4.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (145 kB)
Using cached idna-3.10-py3-none-any.whl (70 kB)
Using cached pluggy-1.5.0-py3-none-any.whl (20 kB)
Using cached urllib3-2.3.0-py3-none-any.whl (128 kB)
Using cached iniconfig-2.0.0-py3-none-any.whl (5.9 kB)
Using cached packaging-24.2-py3-none-any.whl (65 kB)
Installing collected packages: urllib3, shiboken6, pyyaml, pluggy, packaging, loguru, iniconfig, idna, charset-normalizer, certifi, requests, pytest, PySide6-Essentials, pytest-qt, PySide6-Addons, PySide6
Successfully installed PySide6-6.8.2.1 PySide6-Addons-6.8.2.1 PySide6-Essentials-6.8.2.1 certifi-2025.1.31 charset-normalizer-3.4.1 idna-3.10 iniconfig-2.0.0 loguru-0.7.3 packaging-24.2 pluggy-1.5.0 pytest-8.3.5 pytest-qt-4.4.0 pyyaml-6.0.2 requests-2.32.3 shiboken6-6.8.2.1 urllib3-2.3.0

## Usage

1. Launch the application with **python Main.py**
2. Select an Ollama model from the dropdown menu
3. Adjust parameters using the intuitive interface
4. Compare performance with different settings
5. Save your optimized configuration
6. Export settings to share with the community

For more detailed instructions, see the [Quick Start Guide](docs/QuickStartGuide.md).

## Documentation

- [Quick Start Guide](docs/QuickStartGuide.md)
- [Core Components](Core/README.md)
- [Parameter Reference](docs/parameters.md)
- [Advanced Usage](docs/advanced_usage.md)

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (**git checkout -b feature/amazing-feature**)
3. Commit your changes (**git commit -m 'Add some amazing feature'**)
4. Push to the branch (**git push origin feature/amazing-feature**)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgements

- This project is a collaboration between human developers and AI assistants
- Special thanks to the Ollama project for making powerful AI models accessible
- Developed by Herbert J. Bowers (Herb@BowersWorld.com)

================
File: rename_report.sh
================
#!/bin/bash

# Get the project directory name (basename of current directory)
PROJECT_NAME=$(basename "$(pwd)")

# Generate timestamp in a file-friendly format
TIMESTAMP=$(date +"%Y%m%d-%H%M%S")

# Define source and target files
SOURCE_FILE="repomix-output.txt"
TARGET_FILE="CodeBase_${PROJECT_NAME}-${TIMESTAMP}.txt"

# Check if source file exists
if [ -f "$SOURCE_FILE" ]; then
    # Copy the file (original remains intact)
    cp "$SOURCE_FILE" "$TARGET_FILE"
    echo "File copied successfully: $TARGET_FILE"
else
    echo "Error: Source file $SOURCE_FILE not found"
fi

================
File: requirements.txt
================
PySide6>=6.5.0
pytest>=7.3.1
pytest-qt>=4.2.0
requests>=2.28.2
pyyaml>=6.0
loguru>=0.7.0

================
File: SimpleTest.py
================
# File: SimpleTest.py
# Path: OllamaModelEditor/SimpleTest.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Simple test application to verify PySide6 is working

import sys
print(f"Python version: {sys.version}")
print(f"Python executable: {sys.executable}")

try:
    from PySide6.QtWidgets import QApplication, QWidget, QVBoxLayout, QLabel, QPushButton
    from PySide6.QtCore import Qt
    print("PySide6 imported successfully")
except ImportError as e:
    print(f"Error importing PySide6: {e}")
    sys.exit(1)

class SimpleTestWindow(QWidget):
    """Simple window to test PySide6 functionality."""
    
    def __init__(self):
        """Initialize the test window."""
        super().__init__()
        
        # Set window properties
        self.setWindowTitle("OllamaModelEditor - PySide6 Test")
        self.setGeometry(100, 100, 400, 300)
        
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add widgets
        HeaderLabel = QLabel("PySide6 Test Application")
        HeaderLabel.setAlignment(Qt.AlignCenter)
        HeaderLabel.setStyleSheet("font-size: 18px; font-weight: bold; margin-bottom: 20px;")
        Layout.addWidget(HeaderLabel)
        
        SuccessLabel = QLabel("If you can see this window, PySide6 is working correctly!")
        SuccessLabel.setAlignment(Qt.AlignCenter)
        SuccessLabel.setStyleSheet("font-size: 14px; color: green;")
        Layout.addWidget(SuccessLabel)
        
        InfoLabel = QLabel(f"Python version: {sys.version}")
        InfoLabel.setAlignment(Qt.AlignCenter)
        Layout.addWidget(InfoLabel)
        
        # Add close button
        CloseButton = QPushButton("Close")
        CloseButton.clicked.connect(self.close)
        Layout.addWidget(CloseButton)

if __name__ == "__main__":
    print("Starting PySide6 test application...")
    
    # Create application
    App = QApplication(sys.argv)
    
    # Create and show window
    Window = SimpleTestWindow()
    Window.show()
    
    # Start event loop
    sys.exit(App.exec())



================================================================
End of Codebase
================================================================
