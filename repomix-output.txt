This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
  workflows/
    ci.yml
  PULL_REQUEST_TEMPLATE.md
Core/
  ConfigManager.py
  DatabaseSchema.sql
  DBManager.py
  LoggingUtils.py
  ModelManager.py
docs/
  Notes/
    Additional Features from Original Design and Brainstorming.md
    AIDEV-PascalCase Implementation Plan.md
    ConfigManager Update for PascalCase DB Schema.md
    Database Migration to PascalCase Standard.md
    implementation-plan.md
    OllamaModelEditor - Database Integration Guide.md
    OllamaModelEditor UI and Feature Implementation Plan.md
  ProjectStructure.txt
GUI/
  Components/
    __init__.py
    BenchmarkView.py
    ModelSelector.py
    ParameterEditor.py
  Windows/
    MainWindow.py
    SplashScreen.py
scripts/
  GithubUpdate.sh
  MigrateDBToPascalCase.py
  MigrateToDatabase.py
  Setup.bat
  Setup.sh
  SimpleGitHubSetup.sh
  UpdateGitHub.sh
Tests/
  UnitTests/
    TestConfigManager.py
 test_pyside.py
.gitignore
LICENSE
Main.py
README.md
requirements.txt
SimpleTest.py

================================================================
Files
================================================================

================
File: .github/ISSUE_TEMPLATE/bug_report.md
================
---
name: Bug report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '...'
3. Scroll down to '...'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Environment:**
 - OS: [e.g. Windows, macOS, Linux]
 - Python Version: [e.g. 3.8, 3.9]
 - Application Version: [e.g. 1.0.0]

**Additional context**
Add any other context about the problem here.

================
File: .github/ISSUE_TEMPLATE/feature_request.md
================
---
name: Feature request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is.

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

================
File: .github/workflows/ci.yml
================
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Run tests
      run: |
        pytest

================
File: .github/PULL_REQUEST_TEMPLATE.md
================
## Description
<!-- Provide a brief description of the changes in this PR -->

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Documentation update
- [ ] Code refactoring
- [ ] Other (please describe):

## Testing Performed
<!-- Describe the testing done to verify your changes -->

## Checklist
- [ ] My code follows the AIDEV-PascalCase standards of this project
- [ ] I have performed a self-review of my own code
- [ ] I have added tests that prove my fix is effective or that my feature works
- [ ] New and existing unit tests pass locally with my changes
- [ ] I have updated the documentation accordingly

================
File: Core/ConfigManager.py
================
# File: ConfigManager.py
# Path: OllamaModelEditor/Core/ConfigManager.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-12 09:30PM
# Description: Configuration management for the OllamaModelEditor application

import os
import json
import yaml
from pathlib import Path
from typing import Dict, Any, Optional, Union
import logging

# Import DBManager if available
try:
    from Core.DBManager import DBManager
except ImportError:
    DBManager = None

class ConfigManager:
    """Manages application configuration settings and model parameters."""
    
    def __init__(self, ConfigPath: Optional[str] = None, DB: Optional['DBManager'] = None):
        """
        Initialize the configuration manager.
        
        Args:
            ConfigPath: Optional path to configuration file
            DB: Optional database manager instance
        """
        self.Logger = logging.getLogger('OllamaModelEditor.ConfigManager')
        self.ConfigPath = ConfigPath
        self.DB = DB
        self.AppConfig = {}
        self.ModelConfigs = {}
        self.UserPreferences = {}
        
        # Set default configuration path if not provided
        if not self.ConfigPath:
            self.ConfigPath = self._GetDefaultConfigPath()
    
    def _GetDefaultConfigPath(self) -> str:
        """
        Determine the default configuration path based on the operating system.
        
        Returns:
            str: Path to the default configuration directory
        """
        # Get user's home directory
        HomeDir = Path.home()
        
        # Determine configuration directory based on platform
        if os.name == 'nt':  # Windows
            ConfigDir = HomeDir / 'AppData' / 'Local' / 'OllamaModelEditor'
        else:  # macOS and Linux
            ConfigDir = HomeDir / '.config' / 'OllamaModelEditor'
        
        # Create directory if it doesn't exist
        ConfigDir.mkdir(parents=True, exist_ok=True)
        
        return str(ConfigDir / 'Config.yaml')
    
    def LoadConfig(self) -> bool:
        """
        Load configuration from file.
        
        Returns:
            bool: True if configuration loaded successfully, False otherwise
        """
        # If using database, populate from there
        if self.DB:
            try:
                # Load app config from database
                self._LoadAppConfigFromDB()
                
                # Load user preferences from database
                self._LoadUserPreferencesFromDB()
                
                # Load model configs from database
                self._LoadModelConfigsFromDB()
                
                self.Logger.info("Configuration loaded from database")
                return True
            
            except Exception as Error:
                self.Logger.error(f"Error loading configuration from database: {Error}")
                # Fall back to file-based configuration
        
        # File-based configuration loading
        try:
            ConfigPath = Path(self.ConfigPath)
            
            # Create default configuration if file doesn't exist
            if not ConfigPath.exists():
                self._CreateDefaultConfig()
                return True
            
            # Load configuration based on file extension
            if ConfigPath.suffix.lower() == '.json':
                with open(ConfigPath, 'r') as ConfigFile:
                    ConfigData = json.load(ConfigFile)
            elif ConfigPath.suffix.lower() in ['.yaml', '.yml']:
                with open(ConfigPath, 'r') as ConfigFile:
                    ConfigData = yaml.safe_load(ConfigFile)
            else:
                self.Logger.error(f"Unsupported configuration file format: {ConfigPath.suffix}")
                return False
            
            # Parse configuration sections
            self.AppConfig = ConfigData.get('AppConfig', {})
            self.ModelConfigs = ConfigData.get('ModelConfigs', {})
            self.UserPreferences = ConfigData.get('UserPreferences', {})
            
            self.Logger.info(f"Configuration loaded from file: {ConfigPath}")
            return True
            
        except Exception as Error:
            self.Logger.error(f"Error loading configuration: {Error}")
            # Create default configuration on error
            self._CreateDefaultConfig()
            return False
    
    def _LoadAppConfigFromDB(self) -> None:
        """Load application configuration from database."""
        # Get all app settings
        Settings = self.DB.ExecuteQuery(
            "SELECT Key, Value, ValueType FROM AppSettings"
        )
        
        # Clear existing app config
        self.AppConfig = {}
        
        # Convert settings to appropriate types and add to AppConfig
        for Key, Value, ValueType in Settings:
            if ValueType == "int":
                self.AppConfig[Key] = int(Value)
            elif ValueType == "float":
                self.AppConfig[Key] = float(Value)
            elif ValueType == "bool":
                self.AppConfig[Key] = Value.lower() in ("true", "1", "yes")
            elif ValueType == "json":
                self.AppConfig[Key] = json.loads(Value)
            else:
                self.AppConfig[Key] = Value
    
    def _LoadUserPreferencesFromDB(self) -> None:
        """Load user preferences from database."""
        # Get all user preferences
        Preferences = self.DB.ExecuteQuery(
            "SELECT Key, Value, ValueType FROM UserPreferences"
        )
        
        # Clear existing preferences
        self.UserPreferences = {}
        
        # Convert preferences to appropriate types and add to UserPreferences
        for Key, Value, ValueType in Preferences:
            if ValueType == "int":
                self.UserPreferences[Key] = int(Value)
            elif ValueType == "float":
                self.UserPreferences[Key] = float(Value)
            elif ValueType == "bool":
                self.UserPreferences[Key] = Value.lower() in ("true", "1", "yes")
            elif ValueType == "json":
                self.UserPreferences[Key] = json.loads(Value)
            else:
                self.UserPreferences[Key] = Value
    
    def _LoadModelConfigsFromDB(self) -> None:
        """Load model configurations from database."""
        # Get all model configurations
        ModelConfigs = self.DB.ExecuteQuery(
            """
            SELECT ModelName, ConfigName, Temperature, TopP, MaxTokens,
                   FrequencyPenalty, PresencePenalty
            FROM ModelConfigs
            """
        )
        
        # Clear existing model configs
        self.ModelConfigs = {}
        
        # Group configurations by model
        for ModelName, ConfigName, Temperature, TopP, MaxTokens, FrequencyPenalty, PresencePenalty in ModelConfigs:
            # Create model entry if it doesn't exist
            if ModelName not in self.ModelConfigs:
                self.ModelConfigs[ModelName] = {}
            
            # Add configuration
            self.ModelConfigs[ModelName][ConfigName] = {
                'Temperature': Temperature,
                'TopP': TopP,
                'MaxTokens': MaxTokens,
                'FrequencyPenalty': FrequencyPenalty,
                'PresencePenalty': PresencePenalty
            }
    
    def SaveConfig(self) -> bool:
        """
        Save current configuration to file or database.
        
        Returns:
            bool: True if configuration saved successfully, False otherwise
        """
        # If using database, save there
        if self.DB:
            try:
                # Save app config to database
                for Key, Value in self.AppConfig.items():
                    self.DB.SetAppSetting(Key, Value)
                
                # Save user preferences to database
                for Key, Value in self.UserPreferences.items():
                    self.DB.SetUserPreference(Key, Value)
                
                # Save model configs to database (handled by ModelManager)
                # We don't save model configs here to avoid overwriting changes
                
                self.Logger.info("Configuration saved to database")
                return True
            
            except Exception as Error:
                self.Logger.error(f"Error saving configuration to database: {Error}")
                # Fall back to file-based saving
        
        # File-based configuration saving
        try:
            ConfigPath = Path(self.ConfigPath)
            
            # Prepare configuration data
            ConfigData = {
                'AppConfig': self.AppConfig,
                'ModelConfigs': self.ModelConfigs,
                'UserPreferences': self.UserPreferences
            }
            
            # Create directory if it doesn't exist
            ConfigPath.parent.mkdir(parents=True, exist_ok=True)
            
            # Save configuration based on file extension
            if ConfigPath.suffix.lower() == '.json':
                with open(ConfigPath, 'w') as ConfigFile:
                    json.dump(ConfigData, ConfigFile, indent=2)
            elif ConfigPath.suffix.lower() in ['.yaml', '.yml']:
                with open(ConfigPath, 'w') as ConfigFile:
                    yaml.dump(ConfigData, ConfigFile, default_flow_style=False)
            else:
                self.Logger.error(f"Unsupported configuration file format: {ConfigPath.suffix}")
                return False
            
            self.Logger.info(f"Configuration saved to file: {ConfigPath}")
            return True
            
        except Exception as Error:
            self.Logger.error(f"Error saving configuration: {Error}")
            return False
    
    def _CreateDefaultConfig(self) -> None:
        """Create default configuration settings."""
        # Default application configuration
        self.AppConfig = {
            'Version': '1.0.0',
            'APIEndpoint': 'http://localhost:11434/api',
            'LogLevel': 'INFO',
            'MaxConcurrentRequests': 3,
            'Theme': 'system'
        }
        
        # Default model configurations
        self.ModelConfigs = {
            'DefaultParameters': {
                'Temperature': 0.7,
                'TopP': 0.9,
                'MaxTokens': 2048,
                'FrequencyPenalty': 0.0,
                'PresencePenalty': 0.0
            }
        }
        
        # Default user preferences
        self.UserPreferences = {
            'UIFontSize': 12,
            'EditorFontFamily': 'Consolas, Menlo, monospace',
            'ShowWelcomeOnStartup': True,
            'AutoSaveInterval': 300,  # seconds
            'RecentModels': []
        }
        
        # Save default configuration
        if self.DB:
            # Save to database
            for Key, Value in self.AppConfig.items():
                self.DB.SetAppSetting(Key, Value)
            
            for Key, Value in self.UserPreferences.items():
                self.DB.SetUserPreference(Key, Value)
            
            # Save default parameters
            DefaultParams = self.ModelConfigs['DefaultParameters']
            self.DB.SaveModelConfig('DefaultParameters', 'Default', DefaultParams)
            
            self.Logger.info("Default configuration created and saved to database")
        else:
            # Save to file
            self.SaveConfig()
            self.Logger.info("Default configuration created and saved to file")
    
    def GetAppConfig(self, Key: Optional[str] = None, Default: Any = None) -> Any:
        """
        Get application configuration.
        
        Args:
            Key: Optional configuration key to retrieve
            Default: Default value if key not found
            
        Returns:
            Configuration value or entire configuration dictionary
        """
        if self.DB and Key:
            # Try to get from database first
            Value = self.DB.GetAppSetting(Key, None)
            if Value is not None:
                return Value
        
        # Fall back to memory cache
        if Key:
            return self.AppConfig.get(Key, Default)
        return self.AppConfig
    
    def SetAppConfig(self, Key: str, Value: Any) -> None:
        """
        Set application configuration.
        
        Args:
            Key: Configuration key to set
            Value: Configuration value
        """
        self.AppConfig[Key] = Value
        
        # Save to database if available
        if self.DB:
            self.DB.SetAppSetting(Key, Value)
    
    def GetModelConfig(self, ModelName: str) -> Dict[str, Any]:
        """
        Get configuration for a specific model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dict: Model configuration
        """
        if self.DB:
            # Try to get from database first
            Config = self.DB.GetModelConfig(ModelName)
            if Config:
                return {
                    'Temperature': Config['Temperature'],
                    'TopP': Config['TopP'],
                    'MaxTokens': Config['MaxTokens'],
                    'FrequencyPenalty': Config['FrequencyPenalty'],
                    'PresencePenalty': Config['PresencePenalty']
                }
        
        # Fall back to memory cache
        return self.ModelConfigs.get(ModelName, self.ModelConfigs.get('DefaultParameters', {}))
    
    def SetModelConfig(self, ModelName: str, Config: Dict[str, Any]) -> None:
        """
        Set configuration for a specific model.
        
        Args:
            ModelName: Name of the model
            Config: Model configuration
        """
        self.ModelConfigs[ModelName] = Config
        
        # Save to database if available
        if self.DB:
            self.DB.SaveModelConfig(ModelName, 'Default', Config)
    
    def GetUserPreference(self, Key: str, Default: Any = None) -> Any:
        """
        Get user preference.
        
        Args:
            Key: Preference key
            Default: Default value if preference not found
            
        Returns:
            User preference value
        """
        if self.DB:
            # Try to get from database first
            Value = self.DB.GetUserPreference(Key, None)
            if Value is not None:
                return Value
        
        # Fall back to memory cache
        return self.UserPreferences.get(Key, Default)
    
    def SetUserPreference(self, Key: str, Value: Any) -> None:
        """
        Set user preference.
        
        Args:
            Key: Preference key
            Value: Preference value
        """
        self.UserPreferences[Key] = Value
        
        # Save to database if available
        if self.DB:
            self.DB.SetUserPreference(Key, Value)
    
    def AddRecentModel(self, ModelName: str) -> None:
        """
        Add model to recent models list.
        
        Args:
            ModelName: Name of the model
        """
        # Get current recent models list
        RecentModels = self.GetUserPreference('RecentModels', [])
        
        # Remove model if it already exists in the list
        if ModelName in RecentModels:
            RecentModels.remove(ModelName)
        
        # Add model to the beginning of the list
        RecentModels.insert(0, ModelName)
        
        # Keep only the 10 most recent models
        RecentModels = RecentModels[:10]
        
        # Update preference
        self.SetUserPreference('RecentModels', RecentModels)
    
    def ExportModelConfig(self, ModelName: str, FilePath: str) -> bool:
        """
        Export model configuration to a file.
        
        Args:
            ModelName: Name of the model
            FilePath: Path to save the configuration
            
        Returns:
            bool: True if export successful, False otherwise
        """
        try:
            # Get model configuration
            ModelConfig = self.GetModelConfig(ModelName)
            
            if not ModelConfig:
                self.Logger.error(f"No configuration found for model: {ModelName}")
                return False
            
            # Ensure export directory exists
            Path(FilePath).parent.mkdir(parents=True, exist_ok=True)
            
            # Export based on file extension
            FileExt = Path(FilePath).suffix.lower()
            
            if FileExt == '.json':
                with open(FilePath, 'w') as ExportFile:
                    json.dump(ModelConfig, ExportFile, indent=2)
            elif FileExt in ['.yaml', '.yml']:
                with open(FilePath, 'w') as ExportFile:
                    yaml.dump(ModelConfig, ExportFile, default_flow_style=False)
            else:
                self.Logger.error(f"Unsupported export format: {FileExt}")
                return False
            
            self.Logger.info(f"Model configuration exported to: {FilePath}")
            return True
            
        except Exception as Error:
            self.Logger.error(f"Error exporting model configuration: {Error}")
            return False
    
    def ImportModelConfig(self, ModelName: str, FilePath: str) -> bool:
        """
        Import model configuration from a file.
        
        Args:
            ModelName: Name of the model
            FilePath: Path to the configuration file
            
        Returns:
            bool: True if import successful, False otherwise
        """
        try:
            # Check if file exists
            ConfigFile = Path(FilePath)
            if not ConfigFile.exists():
                self.Logger.error(f"Configuration file not found: {FilePath}")
                return False
            
            # Import based on file extension
            FileExt = ConfigFile.suffix.lower()
            
            if FileExt == '.json':
                with open(FilePath, 'r') as ImportFile:
                    ModelConfig = json.load(ImportFile)
            elif FileExt in ['.yaml', '.yml']:
                with open(FilePath, 'r') as ImportFile:
                    ModelConfig = yaml.safe_load(ImportFile)
            else:
                self.Logger.error(f"Unsupported import format: {FileExt}")
                return False
            
            # Validate imported configuration
            if not self._ValidateModelConfig(ModelConfig):
                self.Logger.error("Invalid model configuration format")
                return False
            
            # Set model configuration
            self.SetModelConfig(ModelName, ModelConfig)
            
            # Add to recent models
            self.AddRecentModel(ModelName)
            
            self.Logger.info(f"Model configuration imported from: {FilePath}")
            return True
            
        except Exception as Error:
            self.Logger.error(f"Error importing model configuration: {Error}")
            return False
    
    def _ValidateModelConfig(self, Config: Dict[str, Any]) -> bool:
        """
        Validate model configuration format.
        
        Args:
            Config: Model configuration to validate
            
        Returns:
            bool: True if configuration is valid, False otherwise
        """
        # Required parameters for valid model configuration
        RequiredParams = ['Temperature', 'TopP', 'MaxTokens']
        
        # Check if all required parameters exist
        for Param in RequiredParams:
            if Param not in Config:
                self.Logger.error(f"Missing required parameter: {Param}")
                return False
        
        # Validate parameter types and ranges
        if not isinstance(Config.get('Temperature'), (int, float)) or not 0 <= Config.get('Temperature') <= 2:
            self.Logger.error("Temperature must be a number between 0 and 2")
            return False
        
        if not isinstance(Config.get('TopP'), (int, float)) or not 0 <= Config.get('TopP') <= 1:
            self.Logger.error("TopP must be a number between 0 and 1")
            return False
        
        if not isinstance(Config.get('MaxTokens'), int) or Config.get('MaxTokens') <= 0:
            self.Logger.error("MaxTokens must be a positive integer")
            return False
        
        return True
    
    def MigrateToDatabase(self, DB: 'DBManager') -> bool:
        """
        Migrate file-based configuration to database.
        
        Args:
            DB: Database manager instance
            
        Returns:
            bool: True if migration successful, False otherwise
        """
        if not DB:
            self.Logger.error("No database manager provided")
            return False
        
        try:
            # Make sure configuration is loaded
            self.LoadConfig()
            
            # Set database reference
            self.DB = DB
            
            # Migrate application settings
            self.Logger.info("Migrating application settings...")
            for Key, Value in self.AppConfig.items():
                DB.SetAppSetting(Key, Value)
            
            # Migrate user preferences
            self.Logger.info("Migrating user preferences...")
            for Key, Value in self.UserPreferences.items():
                DB.SetUserPreference(Key, Value)
            
            # Migrate model configurations
            self.Logger.info("Migrating model configurations...")
            for ModelName, ModelConfig in self.ModelConfigs.items():
                if isinstance(ModelConfig, dict) and not isinstance(list(ModelConfig.values())[0], dict):
                    # This is a single configuration (not a dict of configs)
                    DB.SaveModelConfig(ModelName, "Default", ModelConfig)
                else:
                    # This is a dict of configurations
                    for ConfigName, ConfigParams in ModelConfig.items():
                        DB.SaveModelConfig(ModelName, ConfigName, ConfigParams)
            
            self.Logger.info("Migration to database completed successfully")
            return True
            
        except Exception as Error:
            self.Logger.error(f"Error migrating to database: {Error}")
            return False

================
File: Core/DatabaseSchema.sql
================
-- File: DatabaseSchema.sql
-- Path: OllamaModelEditor/Core/DatabaseSchema.sql
-- Standard: AIDEV-PascalCase-1.2
-- Created: 2025-03-12
-- Last Modified: 2025-03-12 08:45PM
-- Description: SQL schema for the OllamaModelEditor database

-- Database version
CREATE TABLE IF NOT EXISTS DBVersion (
    Version INTEGER PRIMARY KEY,
    AppliedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Model configurations
CREATE TABLE IF NOT EXISTS ModelConfigs (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    ModelName TEXT NOT NULL,
    ConfigName TEXT NOT NULL,
    Temperature REAL DEFAULT 0.7,
    TopP REAL DEFAULT 0.9,
    MaxTokens INTEGER DEFAULT 2048,
    FrequencyPenalty REAL DEFAULT 0.0,
    PresencePenalty REAL DEFAULT 0.0,
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    LastUsed TIMESTAMP,
    IsDefault BOOLEAN DEFAULT 0,
    UNIQUE(ModelName, ConfigName)
);

-- Preset configurations
CREATE TABLE IF NOT EXISTS Presets (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    Name TEXT UNIQUE NOT NULL,
    Description TEXT,
    Temperature REAL DEFAULT 0.7,
    TopP REAL DEFAULT 0.9,
    MaxTokens INTEGER DEFAULT 2048,
    FrequencyPenalty REAL DEFAULT 0.0,
    PresencePenalty REAL DEFAULT 0.0,
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    LastUsed TIMESTAMP
);

-- User-defined presets
CREATE TABLE IF NOT EXISTS UserPresets (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    Name TEXT UNIQUE NOT NULL,
    Description TEXT,
    Temperature REAL DEFAULT 0.7,
    TopP REAL DEFAULT 0.9,
    MaxTokens INTEGER DEFAULT 2048,
    FrequencyPenalty REAL DEFAULT 0.0,
    PresencePenalty REAL DEFAULT 0.0,
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    LastUsed TIMESTAMP
);

-- User preferences
CREATE TABLE IF NOT EXISTS UserPreferences (
    Key TEXT PRIMARY KEY,
    Value TEXT,
    ValueType TEXT,  -- For type conversion: "string", "int", "float", "bool", "json"
    UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Application settings
CREATE TABLE IF NOT EXISTS AppSettings (
    Key TEXT PRIMARY KEY,
    Value TEXT,
    ValueType TEXT,  -- For type conversion
    Description TEXT,
    UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Parameter definitions and descriptions
CREATE TABLE IF NOT EXISTS Parameters (
    Name TEXT PRIMARY KEY,
    DisplayName TEXT NOT NULL,
    Description TEXT,
    MinValue REAL,
    MaxValue REAL,
    DefaultValue REAL,
    StepSize REAL,
    IsInteger BOOLEAN DEFAULT 0,
    Category TEXT,  -- e.g., "basic", "advanced"
    OrderIndex INTEGER  -- For display ordering
);

-- Generation history
CREATE TABLE IF NOT EXISTS GenerationHistory (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    ModelName TEXT NOT NULL,
    Prompt TEXT NOT NULL,
    Response TEXT,
    Temperature REAL,
    TopP REAL,
    MaxTokens INTEGER,
    FrequencyPenalty REAL,
    PresencePenalty REAL,
    InputTokens INTEGER,
    OutputTokens INTEGER,
    TotalTokens INTEGER,
    GenerationTime REAL,  -- in seconds
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Benchmark results
CREATE TABLE IF NOT EXISTS BenchmarkResults (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    BenchmarkName TEXT,
    ModelName TEXT NOT NULL,
    ConfigID INTEGER,
    Prompt TEXT,
    AverageTime REAL,  -- Average generation time in seconds
    AverageTokens INTEGER,
    AverageTokensPerSecond REAL,
    Runs INTEGER,  -- Number of benchmark runs
    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(ConfigID) REFERENCES ModelConfigs(ID)
);

-- Messages for UI elements
CREATE TABLE IF NOT EXISTS UIMessages (
    Key TEXT PRIMARY KEY,
    Message TEXT NOT NULL,
    Context TEXT,  -- e.g., "error", "info", "tooltip"
    UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- UI strings for internationalization
CREATE TABLE IF NOT EXISTS UIStrings (
    Key TEXT PRIMARY KEY,
    EnText TEXT NOT NULL,  -- English text
    Description TEXT,
    Context TEXT   -- Where this string is used
);

================
File: Core/DBManager.py
================
# File: DBManager.py
# Path: OllamaModelEditor/Core/DBManager.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-12
# Last Modified: 2025-03-12 08:30PM
# Description: Database management for the OllamaModelEditor application

import os
import sqlite3
import json
import time
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple
import logging

class DBManager:
    """Manages the SQLite database for OllamaModelEditor."""
    
    def __init__(self, DBPath: Optional[str] = None):
        """
        Initialize the database manager.
        
        Args:
            DBPath: Optional path to database file
        """
        self.Logger = logging.getLogger('OllamaModelEditor.DBManager')
        
        # Set default database path if not provided
        if not DBPath:
            self.DBPath = self._GetDefaultDBPath()
        else:
            self.DBPath = DBPath
        
        # Ensure directory exists
        os.makedirs(os.path.dirname(self.DBPath), exist_ok=True)
        
        # Initialize database
        self._InitializeDB()
    
    def _GetDefaultDBPath(self) -> str:
        """
        Determine the default database path based on the operating system.
        
        Returns:
            str: Path to the default database file
        """
        # Get user's home directory
        HomeDir = Path.home()
        
        # Determine configuration directory based on platform
        if os.name == 'nt':  # Windows
            ConfigDir = HomeDir / 'AppData' / 'Local' / 'OllamaModelEditor'
        else:  # macOS and Linux
            ConfigDir = HomeDir / '.config' / 'OllamaModelEditor'
        
        # Create directory if it doesn't exist
        ConfigDir.mkdir(parents=True, exist_ok=True)
        
        return str(ConfigDir / 'OllamaModelEditor.db')
    
    def _InitializeDB(self) -> None:
        """Initialize the database with required tables and default data."""
        try:
            # Create schema definition
            Schema = """
            -- Database version
            CREATE TABLE IF NOT EXISTS DBVersion (
                Version INTEGER PRIMARY KEY,
                AppliedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- Model configurations
            CREATE TABLE IF NOT EXISTS ModelConfigs (
                ID INTEGER PRIMARY KEY AUTOINCREMENT,
                ModelName TEXT NOT NULL,
                ConfigName TEXT NOT NULL,
                Temperature REAL DEFAULT 0.7,
                TopP REAL DEFAULT 0.9,
                MaxTokens INTEGER DEFAULT 2048,
                FrequencyPenalty REAL DEFAULT 0.0,
                PresencePenalty REAL DEFAULT 0.0,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                LastUsed TIMESTAMP,
                IsDefault BOOLEAN DEFAULT 0,
                UNIQUE(ModelName, ConfigName)
            );

            -- Preset configurations
            CREATE TABLE IF NOT EXISTS Presets (
                ID INTEGER PRIMARY KEY AUTOINCREMENT,
                Name TEXT UNIQUE NOT NULL,
                Description TEXT,
                Temperature REAL DEFAULT 0.7,
                TopP REAL DEFAULT 0.9,
                MaxTokens INTEGER DEFAULT 2048,
                FrequencyPenalty REAL DEFAULT 0.0,
                PresencePenalty REAL DEFAULT 0.0,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                LastUsed TIMESTAMP
            );
            
            -- User-defined presets
            CREATE TABLE IF NOT EXISTS UserPresets (
                ID INTEGER PRIMARY KEY AUTOINCREMENT,
                Name TEXT UNIQUE NOT NULL,
                Description TEXT,
                Temperature REAL DEFAULT 0.7,
                TopP REAL DEFAULT 0.9,
                MaxTokens INTEGER DEFAULT 2048,
                FrequencyPenalty REAL DEFAULT 0.0,
                PresencePenalty REAL DEFAULT 0.0,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                LastUsed TIMESTAMP
            );
            
            -- User preferences
            CREATE TABLE IF NOT EXISTS UserPreferences (
                Key TEXT PRIMARY KEY,
                Value TEXT,
                ValueType TEXT,
                UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- Application settings
            CREATE TABLE IF NOT EXISTS AppSettings (
                Key TEXT PRIMARY KEY,
                Value TEXT,
                ValueType TEXT,
                Description TEXT,
                UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- Parameter definitions and descriptions
            CREATE TABLE IF NOT EXISTS Parameters (
                Name TEXT PRIMARY KEY,
                DisplayName TEXT NOT NULL,
                Description TEXT,
                MinValue REAL,
                MaxValue REAL,
                DefaultValue REAL,
                StepSize REAL,
                IsInteger BOOLEAN DEFAULT 0,
                Category TEXT,
                OrderIndex INTEGER
            );
            
            -- Generation history
            CREATE TABLE IF NOT EXISTS GenerationHistory (
                ID INTEGER PRIMARY KEY AUTOINCREMENT,
                ModelName TEXT NOT NULL,
                Prompt TEXT NOT NULL,
                Response TEXT,
                Temperature REAL,
                TopP REAL,
                MaxTokens INTEGER,
                FrequencyPenalty REAL,
                PresencePenalty REAL,
                InputTokens INTEGER,
                OutputTokens INTEGER,
                TotalTokens INTEGER,
                GenerationTime REAL,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- Benchmark results
            CREATE TABLE IF NOT EXISTS BenchmarkResults (
                ID INTEGER PRIMARY KEY AUTOINCREMENT,
                BenchmarkName TEXT,
                ModelName TEXT NOT NULL,
                ConfigID INTEGER,
                Prompt TEXT,
                AverageTime REAL,
                AverageTokens INTEGER,
                AverageTokensPerSecond REAL,
                Runs INTEGER,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(ConfigID) REFERENCES ModelConfigs(ID)
            );
            
            -- Messages for UI elements
            CREATE TABLE IF NOT EXISTS UIMessages (
                Key TEXT PRIMARY KEY,
                Message TEXT NOT NULL,
                Context TEXT,
                UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- UI strings for internationalization
            CREATE TABLE IF NOT EXISTS UIStrings (
                Key TEXT PRIMARY KEY,
                EnText TEXT NOT NULL,
                Description TEXT,
                Context TEXT
            );
            """
            
            # Connect to database
            with sqlite3.connect(self.DBPath) as Conn:
                Cursor = Conn.cursor()
                
                # Execute schema script
                Cursor.executescript(Schema)
                
                # Check current database version
                Cursor.execute("SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='DBVersion'")
                if Cursor.fetchone()[0] > 0:
                    Cursor.execute("SELECT MAX(Version) FROM DBVersion")
                    Result = Cursor.fetchone()
                    CurrentVersion = Result[0] if Result[0] is not None else 0
                else:
                    CurrentVersion = 0
                
                # Set initial version if it doesn't exist
                if CurrentVersion == 0:
                    Cursor.execute("INSERT INTO DBVersion (Version) VALUES (1)")
                    CurrentVersion = 1
                
                # Check if presets need to be initialized
                Cursor.execute("SELECT COUNT(*) FROM Presets")
                PresetCount = Cursor.fetchone()[0]
                
                if PresetCount == 0:
                    self._InitializePresets(Cursor)
                
                # Check if parameters need to be initialized
                Cursor.execute("SELECT COUNT(*) FROM Parameters")
                ParameterCount = Cursor.fetchone()[0]
                
                if ParameterCount == 0:
                    self._InitializeParameters(Cursor)
                
                # Check if UI strings need to be initialized
                Cursor.execute("SELECT COUNT(*) FROM UIStrings")
                UIStringCount = Cursor.fetchone()[0]
                
                if UIStringCount == 0:
                    self._InitializeUIStrings(Cursor)
                
                Conn.commit()
                
            self.Logger.info(f"Database initialized: {self.DBPath}")
                
        except sqlite3.Error as Error:
            self.Logger.error(f"Error initializing database: {Error}")
            raise
    
    def _InitializePresets(self, Cursor) -> None:
        """
        Initialize default presets.
        
        Args:
            Cursor: Database cursor
        """
        Presets = [
            (
                "Default", 
                "Balanced settings suitable for most tasks.", 
                0.7, 0.9, 2048, 0.0, 0.0
            ),
            (
                "Creative", 
                "Higher temperature and diversity for more creative, varied outputs.", 
                1.0, 0.95, 4096, 0.0, 0.0
            ),
            (
                "Precise", 
                "Lower temperature for more focused, deterministic responses.", 
                0.3, 0.7, 2048, 0.5, 0.0
            ),
            (
                "Fast", 
                "Optimized for speed with shorter outputs.", 
                0.7, 0.9, 1024, 0.0, 0.0
            ),
            (
                "Balanced", 
                "Moderate settings with some repetition control for well-rounded responses.", 
                0.6, 0.85, 2048, 0.3, 0.3
            ),
            (
                "Deterministic", 
                "Minimal randomness for highly predictable, consistent outputs.", 
                0.0, 0.5, 2048, 0.0, 0.0
            )
        ]
        
        Cursor.executemany(
            """
            INSERT INTO Presets (Name, Description, Temperature, TopP, MaxTokens, 
                               FrequencyPenalty, PresencePenalty)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """, 
            Presets
        )
    
    def _InitializeParameters(self, Cursor) -> None:
        """
        Initialize parameter definitions.
        
        Args:
            Cursor: Database cursor
        """
        Parameters = [
            (
                "Temperature", "Temperature", 
                "Controls randomness in text generation. Higher values (0.7-1.0) produce more creative outputs, while lower values (0.2-0.5) make output more focused and deterministic.",
                0.0, 2.0, 0.7, 0.1, 0, "basic", 1
            ),
            (
                "TopP", "Top-P",
                "Controls diversity via nucleus sampling. Lower values make output more focused on likely tokens. 0.9 is a good starting point.",
                0.0, 1.0, 0.9, 0.01, 0, "basic", 2
            ),
            (
                "MaxTokens", "Max Tokens",
                "The maximum length of the generated text. Higher values allow for longer responses but consume more resources.",
                1, 32000, 2048, 1, 1, "basic", 3
            ),
            (
                "FrequencyPenalty", "Frequency Penalty",
                "Reduces repetition by penalizing tokens that have already appeared in the text. Higher values (0.5-1.0) strongly discourage repetition.",
                0.0, 2.0, 0.0, 0.1, 0, "advanced", 4
            ),
            (
                "PresencePenalty", "Presence Penalty",
                "Penalizes tokens that have appeared at all, encouraging the model to discuss new topics. Useful for keeping responses diverse.",
                0.0, 2.0, 0.0, 0.1, 0, "advanced", 5
            )
        ]
        
        Cursor.executemany(
            """
            INSERT INTO Parameters (Name, DisplayName, Description, MinValue, MaxValue, 
                                 DefaultValue, StepSize, IsInteger, Category, OrderIndex)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, 
            Parameters
        )
    
    def _InitializeUIStrings(self, Cursor) -> None:
        """
        Initialize UI strings.
        
        Args:
            Cursor: Database cursor
        """
        # Example UI strings initialization
        UIStrings = [
            ("app.title", "Ollama Model Editor", "Main window title", "window"),
            ("menu.file", "File", "File menu", "menu"),
            ("menu.edit", "Edit", "Edit menu", "menu"),
            ("menu.view", "View", "View menu", "menu"),
            ("menu.tools", "Tools", "Tools menu", "menu"),
            ("menu.help", "Help", "Help menu", "menu"),
            ("button.apply", "Apply Changes", "Apply button", "button"),
            ("button.reset", "Reset to Default", "Reset button", "button"),
            ("error.no_model", "Please select a model first.", "Error message", "error"),
            ("label.parameter_editor", "Parameter Editor", "Tab label", "tab"),
            ("label.benchmark", "Benchmark", "Tab label", "tab"),
            ("label.analysis", "Analysis", "Tab label", "tab"),
            ("label.temperature", "Temperature:", "Parameter label", "parameter"),
            ("label.top_p", "Top-P:", "Parameter label", "parameter"),
            ("label.max_tokens", "Max Tokens:", "Parameter label", "parameter"),
            ("label.frequency_penalty", "Frequency Penalty:", "Parameter label", "parameter"),
            ("label.presence_penalty", "Presence Penalty:", "Parameter label", "parameter"),
            ("label.model_library", "Model Library", "Dock title", "dock"),
            ("label.presets", "Preset:", "Presets label", "parameter"),
            ("label.available_models", "Available Models:", "Model list label", "label"),
            ("status.loading_models", "Loading models...", "Status message", "status"),
            ("status.models_loaded", "Loaded {0} models", "Status message", "status"),
            ("status.model_selected", "Model {0} selected", "Status message", "status"),
            ("status.api_connected", "API: Connected", "Status message", "status"),
            ("status.api_error", "API: Error", "Status message", "status"),
            ("status.no_connection", "API: Not connected", "Status message", "status")
        ]
        
        Cursor.executemany(
            """
            INSERT INTO UIStrings (Key, EnText, Description, Context)
            VALUES (?, ?, ?, ?)
            """, 
            UIStrings
        )
    
    def GetConnection(self) -> sqlite3.Connection:
        """
        Get a database connection.
        
        Returns:
            sqlite3.Connection: Database connection
        """
        return sqlite3.connect(self.DBPath)
    
    def ExecuteQuery(self, Query: str, Params: tuple = ()) -> List[tuple]:
        """
        Execute a query and return results.
        
        Args:
            Query: SQL query
            Params: Query parameters
            
        Returns:
            List of result tuples
        """
        try:
            with self.GetConnection() as Conn:
                Cursor = Conn.cursor()
                Cursor.execute(Query, Params)
                return Cursor.fetchall()
        except sqlite3.Error as Error:
            self.Logger.error(f"Error executing query: {Error}")
            self.Logger.debug(f"Query: {Query}, Params: {Params}")
            raise
    
    def ExecuteNonQuery(self, Query: str, Params: tuple = ()) -> int:
        """
        Execute a non-query statement.
        
        Args:
            Query: SQL statement
            Params: Statement parameters
            
        Returns:
            Row count or last row ID
        """
        try:
            with self.GetConnection() as Conn:
                Cursor = Conn.cursor()
                Cursor.execute(Query, Params)
                Conn.commit()
                return Cursor.lastrowid or Cursor.rowcount
        except sqlite3.Error as Error:
            self.Logger.error(f"Error executing non-query: {Error}")
            self.Logger.debug(f"Query: {Query}, Params: {Params}")
            raise
    
    # Model Configuration Methods
    
    def GetModelConfigs(self, ModelName: str) -> List[Dict[str, Any]]:
        """
        Get all configurations for a model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            List of configuration dictionaries
        """
        Results = self.ExecuteQuery(
            "SELECT * FROM ModelConfigs WHERE ModelName = ?",
            (ModelName,)
        )
        
        Columns = [
            "ID", "ModelName", "ConfigName", "Temperature", "TopP", 
            "MaxTokens", "FrequencyPenalty", "PresencePenalty", 
            "CreatedAt", "LastUsed", "IsDefault"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def GetModelConfig(self, ModelName: str, ConfigName: str = "Default") -> Optional[Dict[str, Any]]:
        """
        Get a specific configuration for a model.
        
        Args:
            ModelName: Name of the model
            ConfigName: Name of the configuration
            
        Returns:
            Configuration dictionary or None if not found
        """
        Results = self.ExecuteQuery(
            "SELECT * FROM ModelConfigs WHERE ModelName = ? AND ConfigName = ?",
            (ModelName, ConfigName)
        )
        
        if not Results:
            return None
        
        Columns = [
            "ID", "ModelName", "ConfigName", "Temperature", "TopP", 
            "MaxTokens", "FrequencyPenalty", "PresencePenalty", 
            "CreatedAt", "LastUsed", "IsDefault"
        ]
        
        return dict(zip(Columns, Results[0]))
    
    def SaveModelConfig(self, ModelName: str, ConfigName: str, Params: Dict[str, Any]) -> int:
        """
        Save a model configuration.
        
        Args:
            ModelName: Name of the model
            ConfigName: Name of the configuration
            Params: Configuration parameters
            
        Returns:
            Row ID of the saved configuration
        """
        # Check if configuration exists
        ExistingConfig = self.GetModelConfig(ModelName, ConfigName)
        
        if ExistingConfig:
            # Update existing configuration
            Query = """
            UPDATE ModelConfigs
            SET Temperature = ?, TopP = ?, MaxTokens = ?, 
                FrequencyPenalty = ?, PresencePenalty = ?,
                LastUsed = CURRENT_TIMESTAMP
            WHERE ModelName = ? AND ConfigName = ?
            """
            
            self.ExecuteNonQuery(
                Query,
                (
                    Params.get('Temperature', 0.7),
                    Params.get('TopP', 0.9),
                    Params.get('MaxTokens', 2048),
                    Params.get('FrequencyPenalty', 0.0),
                    Params.get('PresencePenalty', 0.0),
                    ModelName,
                    ConfigName
                )
            )
            
            return ExistingConfig["ID"]
        else:
            # Insert new configuration
            Query = """
            INSERT INTO ModelConfigs
            (ModelName, ConfigName, Temperature, TopP, MaxTokens, 
             FrequencyPenalty, PresencePenalty)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """
            
            return self.ExecuteNonQuery(
                Query,
                (
                    ModelName,
                    ConfigName,
                    Params.get('Temperature', 0.7),
                    Params.get('TopP', 0.9),
                    Params.get('MaxTokens', 2048),
                    Params.get('FrequencyPenalty', 0.0),
                    Params.get('PresencePenalty', 0.0)
                )
            )
    
    def DeleteModelConfig(self, ModelName: str, ConfigName: str) -> bool:
        """
        Delete a model configuration.
        
        Args:
            ModelName: Name of the model
            ConfigName: Name of the configuration
            
        Returns:
            True if deleted, False if not found
        """
        Result = self.ExecuteNonQuery(
            "DELETE FROM ModelConfigs WHERE ModelName = ? AND ConfigName = ?",
            (ModelName, ConfigName)
        )
        
        return Result > 0
    
    # Preset Methods
    
    def GetPresets(self) -> List[Dict[str, Any]]:
        """
        Get all preset configurations.
        
        Returns:
            List of preset dictionaries
        """
        Results = self.ExecuteQuery("SELECT * FROM Presets ORDER BY Name")
        
        Columns = [
            "ID", "Name", "Description", "Temperature", "TopP", 
            "MaxTokens", "FrequencyPenalty", "PresencePenalty", 
            "CreatedAt", "LastUsed"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def GetPreset(self, PresetName: str) -> Optional[Dict[str, Any]]:
        """
        Get a specific preset configuration.
        
        Args:
            PresetName: Name of the preset
            
        Returns:
            Preset dictionary or None if not found
        """
        Results = self.ExecuteQuery(
            "SELECT * FROM Presets WHERE Name = ?",
            (PresetName,)
        )
        
        if not Results:
            return None
        
        Columns = [
            "ID", "Name", "Description", "Temperature", "TopP", 
            "MaxTokens", "FrequencyPenalty", "PresencePenalty", 
            "CreatedAt", "LastUsed"
        ]
        
        return dict(zip(Columns, Results[0]))
    
    def UpdatePresetUsage(self, PresetName: str) -> bool:
        """
        Update the LastUsed timestamp for a preset.
        
        Args:
            PresetName: Name of the preset
            
        Returns:
            True if updated, False if not found
        """
        Result = self.ExecuteNonQuery(
            "UPDATE Presets SET LastUsed = CURRENT_TIMESTAMP WHERE Name = ?",
            (PresetName,)
        )
        
        return Result > 0
    
    # User-defined Preset Methods
    
    def GetUserPresets(self) -> List[Dict[str, Any]]:
        """
        Get all user-defined presets.
        
        Returns:
            List of user preset dictionaries
        """
        Results = self.ExecuteQuery("SELECT * FROM UserPresets ORDER BY Name")
        
        Columns = [
            "ID", "Name", "Description", "Temperature", "TopP", 
            "MaxTokens", "FrequencyPenalty", "PresencePenalty", 
            "CreatedAt", "LastUsed"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def SaveUserPreset(self, PresetName: str, Description: str, Params: Dict[str, Any]) -> int:
        """
        Save a user-defined preset.
        
        Args:
            PresetName: Name of the preset
            Description: Preset description
            Params: Preset parameters
            
        Returns:
            Row ID of the saved preset
        """
        # Check if preset exists
        ExistingPreset = self.ExecuteQuery(
            "SELECT ID FROM UserPresets WHERE Name = ?",
            (PresetName,)
        )
        
        if ExistingPreset:
            # Update existing preset
            Query = """
            UPDATE UserPresets
            SET Description = ?, Temperature = ?, TopP = ?, MaxTokens = ?, 
                FrequencyPenalty = ?, PresencePenalty = ?,
                LastUsed = CURRENT_TIMESTAMP
            WHERE Name = ?
            """
            
            self.ExecuteNonQuery(
                Query,
                (
                    Description,
                    Params.get('Temperature', 0.7),
                    Params.get('TopP', 0.9),
                    Params.get('MaxTokens', 2048),
                    Params.get('FrequencyPenalty', 0.0),
                    Params.get('PresencePenalty', 0.0),
                    PresetName
                )
            )
            
            return ExistingPreset[0][0]
        else:
            # Insert new preset
            Query = """
            INSERT INTO UserPresets
            (Name, Description, Temperature, TopP, MaxTokens, 
             FrequencyPenalty, PresencePenalty)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """
            
            return self.ExecuteNonQuery(
                Query,
                (
                    PresetName,
                    Description,
                    Params.get('Temperature', 0.7),
                    Params.get('TopP', 0.9),
                    Params.get('MaxTokens', 2048),
                    Params.get('FrequencyPenalty', 0.0),
                    Params.get('PresencePenalty', 0.0)
                )
            )
    
    def DeleteUserPreset(self, PresetName: str) -> bool:
        """
        Delete a user-defined preset.
        
        Args:
            PresetName: Name of the preset
            
        Returns:
            True if deleted, False if not found
        """
        Result = self.ExecuteNonQuery(
            "DELETE FROM UserPresets WHERE Name = ?",
            (PresetName,)
        )
        
        return Result > 0
    
    # User Preference Methods
    
    def GetUserPreference(self, Key: str, Default: Any = None) -> Any:
        """
        Get a user preference.
        
        Args:
            Key: Preference key
            Default: Default value if preference not found
            
        Returns:
            Preference value
        """
        Results = self.ExecuteQuery(
            "SELECT Value, ValueType FROM UserPreferences WHERE Key = ?",
            (Key,)
        )
        
        if not Results:
            return Default
        
        Value, ValueType = Results[0]
        
        # Convert value based on type
        if ValueType == "int":
            return int(Value)
        elif ValueType == "float":
            return float(Value)
        elif ValueType == "bool":
            return Value.lower() in ("true", "1", "yes")
        elif ValueType == "json":
            return json.loads(Value)
        else:
            return Value
    
    def SetUserPreference(self, Key: str, Value: Any) -> None:
        """
        Set a user preference.
        
        Args:
            Key: Preference key
            Value: Preference value
        """
        # Determine value type
        if isinstance(Value, bool):
            ValueStr = "true" if Value else "false"
            ValueType = "bool"
        elif isinstance(Value, int):
            ValueStr = str(Value)
            ValueType = "int"
        elif isinstance(Value, float):
            ValueStr = str(Value)
            ValueType = "float"
        elif isinstance(Value, (dict, list)):
            ValueStr = json.dumps(Value)
            ValueType = "json"
        else:
            ValueStr = str(Value)
            ValueType = "string"
        
        # Check if preference exists
        Results = self.ExecuteQuery(
            "SELECT COUNT(*) FROM UserPreferences WHERE Key = ?",
            (Key,)
        )
        
        if Results[0][0] > 0:
            # Update existing preference
            self.ExecuteNonQuery(
                """
                UPDATE UserPreferences
                SET Value = ?, ValueType = ?, UpdatedAt = CURRENT_TIMESTAMP
                WHERE Key = ?
                """,
                (ValueStr, ValueType, Key)
            )
        else:
            # Insert new preference
            self.ExecuteNonQuery(
                """
                INSERT INTO UserPreferences (Key, Value, ValueType)
                VALUES (?, ?, ?)
                """,
                (Key, ValueStr, ValueType)
            )
    
    # App Settings Methods
    
    def GetAppSetting(self, Key: str, Default: Any = None) -> Any:
        """
        Get an application setting.
        
        Args:
            Key: Setting key
            Default: Default value if setting not found
            
        Returns:
            Setting value
        """
        Results = self.ExecuteQuery(
            "SELECT Value, ValueType FROM AppSettings WHERE Key = ?",
            (Key,)
        )
        
        if not Results:
            return Default
        
        Value, ValueType = Results[0]
        
        # Convert value based on type
        if ValueType == "int":
            return int(Value)
        elif ValueType == "float":
            return float(Value)
        elif ValueType == "bool":
            return Value.lower() in ("true", "1", "yes")
        elif ValueType == "json":
            return json.loads(Value)
        else:
            return Value
    
    def SetAppSetting(self, Key: str, Value: Any, Description: str = None) -> None:
        """
        Set an application setting.
        
        Args:
            Key: Setting key
            Value: Setting value
            Description: Optional setting description
        """
        # Determine value type
        if isinstance(Value, bool):
            ValueStr = "true" if Value else "false"
            ValueType = "bool"
        elif isinstance(Value, int):
            ValueStr = str(Value)
            ValueType = "int"
        elif isinstance(Value, float):
            ValueStr = str(Value)
            ValueType = "float"
        elif isinstance(Value, (dict, list)):
            ValueStr = json.dumps(Value)
            ValueType = "json"
        else:
            ValueStr = str(Value)
            ValueType = "string"
        
        # Check if setting exists
        Results = self.ExecuteQuery(
            "SELECT COUNT(*) FROM AppSettings WHERE Key = ?",
            (Key,)
        )
        
        if Results[0][0] > 0:
            # Update existing setting
            if Description:
                self.ExecuteNonQuery(
                    """
                    UPDATE AppSettings
                    SET Value = ?, ValueType = ?, Description = ?, UpdatedAt = CURRENT_TIMESTAMP
                    WHERE Key = ?
                    """,
                    (ValueStr, ValueType, Description, Key)
                )
            else:
                self.ExecuteNonQuery(
                    """
                    UPDATE AppSettings
                    SET Value = ?, ValueType = ?, UpdatedAt = CURRENT_TIMESTAMP
                    WHERE Key = ?
                    """,
                    (ValueStr, ValueType, Key)
                )
        else:
            # Insert new setting
            self.ExecuteNonQuery(
                """
                INSERT INTO AppSettings (Key, Value, ValueType, Description)
                VALUES (?, ?, ?, ?)
                """,
                (Key, ValueStr, ValueType, Description)
            )
    
    # UI String Methods
    
    def GetUIString(self, Key: str, Default: str = None) -> str:
        """
        Get a UI string.
        
        Args:
            Key: String key
            Default: Default value if string not found
            
        Returns:
            UI string
        """
        Results = self.ExecuteQuery(
            "SELECT EnText FROM UIStrings WHERE Key = ?",
            (Key,)
        )
        
        if not Results:
            return Default or Key
        
        return Results[0][0]
    
    def GetUIStrings(self, Context: str = None) -> Dict[str, str]:
        """
        Get all UI strings, optionally filtered by context.
        
        Args:
            Context: Optional context filter
            
        Returns:
            Dictionary of UI strings (key -> text)
        """
        if Context:
            Results = self.ExecuteQuery(
                "SELECT Key, EnText FROM UIStrings WHERE Context = ?",
                (Context,)
            )
        else:
            Results = self.ExecuteQuery(
                "SELECT Key, EnText FROM UIStrings"
            )
        
        return {Key: Text for Key, Text in Results}
    
    def SetUIString(self, Key: str, Text: str, Description: str = None, Context: str = None) -> None:
        """
        Set a UI string.
        
        Args:
            Key: String key
            Text: String text (English)
            Description: Optional description
            Context: Optional context
        """
        # Check if string exists
        Results = self.ExecuteQuery(
            "SELECT COUNT(*) FROM UIStrings WHERE Key = ?",
            (Key,)
        )
        
        if Results[0][0] > 0:
            # Update existing string
            if Description and Context:
                self.ExecuteNonQuery(
                    """
                    UPDATE UIStrings
                    SET EnText = ?, Description = ?, Context = ?
                    WHERE Key = ?
                    """,
                    (Text, Description, Context, Key)
                )
            elif Description:
                self.ExecuteNonQuery(
                    """
                    UPDATE UIStrings
                    SET EnText = ?, Description = ?
                    WHERE Key = ?
                    """,
                    (Text, Description, Key)
                )
            elif Context:
                self.ExecuteNonQuery(
                    """
                    UPDATE UIStrings
                    SET EnText = ?, Context = ?
                    WHERE Key = ?
                    """,
                    (Text, Context, Key)
                )
            else:
                self.ExecuteNonQuery(
                    """
                    UPDATE UIStrings
                    SET EnText = ?
                    WHERE Key = ?
                    """,
                    (Text, Key)
                )
        else:
            # Insert new string
            self.ExecuteNonQuery(
                """
                INSERT INTO UIStrings (Key, EnText, Description, Context)
                VALUES (?, ?, ?, ?)
                """,
                (Key, Text, Description, Context)
            )
    
    # Parameter Methods
    
    def GetAllParameters(self) -> List[Dict[str, Any]]:
        """
        Get all parameter definitions.
        
        Returns:
            List of parameter dictionaries
        """
        Results = self.ExecuteQuery(
            """
            SELECT * FROM Parameters
            ORDER BY OrderIndex
            """
        )
        
        Columns = [
            "Name", "DisplayName", "Description", "MinValue", "MaxValue",
            "DefaultValue", "StepSize", "IsInteger", "Category", "OrderIndex"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def GetParametersByCategory(self, Category: str) -> List[Dict[str, Any]]:
        """
        Get parameter definitions by category.
        
        Args:
            Category: Parameter category
            
        Returns:
            List of parameter dictionaries
        """
        Results = self.ExecuteQuery(
            """
            SELECT * FROM Parameters
            WHERE Category = ?
            ORDER BY OrderIndex
            """,
            (Category,)
        )
        
        Columns = [
            "Name", "DisplayName", "Description", "MinValue", "MaxValue",
            "DefaultValue", "StepSize", "IsInteger", "Category", "OrderIndex"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def GetParameter(self, Name: str) -> Optional[Dict[str, Any]]:
        """
        Get a parameter definition.
        
        Args:
            Name: Parameter name
            
        Returns:
            Parameter dictionary or None if not found
        """
        Results = self.ExecuteQuery(
            """
            SELECT * FROM Parameters
            WHERE Name = ?
            """,
            (Name,)
        )
        
        if not Results:
            return None
        
        Columns = [
            "Name", "DisplayName", "Description", "MinValue", "MaxValue",
            "DefaultValue", "StepSize", "IsInteger", "Category", "OrderIndex"
        ]
        
        return dict(zip(Columns, Results[0]))
    
    # Generation History Methods
    
    def AddGenerationHistory(self, ModelName: str, Prompt: str, Response: str, 
                             Params: Dict[str, Any], Metrics: Dict[str, Any]) -> int:
        """
        Add a generation history entry.
        
        Args:
            ModelName: Name of the model
            Prompt: Input prompt
            Response: Generated response
            Params: Generation parameters
            Metrics: Generation metrics
            
        Returns:
            ID of the new history entry
        """
        Query = """
        INSERT INTO GenerationHistory (
            ModelName, Prompt, Response, Temperature, TopP, MaxTokens,
            FrequencyPenalty, PresencePenalty, InputTokens, OutputTokens,
            TotalTokens, GenerationTime)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        return self.ExecuteNonQuery(
            Query,
            (
                ModelName,
                Prompt,
                Response,
                Params.get('Temperature', 0.7),
                Params.get('TopP', 0.9),
                Params.get('MaxTokens', 2048),
                Params.get('FrequencyPenalty', 0.0),
                Params.get('PresencePenalty', 0.0),
                Metrics.get('InputTokens', 0),
                Metrics.get('OutputTokens', 0),
                Metrics.get('TotalTokens', 0),
                Metrics.get('GenerationTime', 0.0)
            )
        )
    
    def GetGenerationHistory(self, Limit: int = 100, Offset: int = 0) -> List[Dict[str, Any]]:
        """
        Get generation history entries.
        
        Args:
            Limit: Maximum number of entries to retrieve
            Offset: Offset for pagination
            
        Returns:
            List of history entry dictionaries
        """
        Results = self.ExecuteQuery(
            """
            SELECT * FROM GenerationHistory
            ORDER BY CreatedAt DESC
            LIMIT ? OFFSET ?
            """,
            (Limit, Offset)
        )
        
        Columns = [
            "ID", "ModelName", "Prompt", "Response", "Temperature",
            "TopP", "MaxTokens", "FrequencyPenalty", "PresencePenalty",
            "InputTokens", "OutputTokens", "TotalTokens",
            "GenerationTime", "CreatedAt"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def GetGenerationHistoryForModel(self, ModelName: str, Limit: int = 100, Offset: int = 0) -> List[Dict[str, Any]]:
        """
        Get generation history entries for a specific model.
        
        Args:
            ModelName: Name of the model
            Limit: Maximum number of entries to retrieve
            Offset: Offset for pagination
            
        Returns:
            List of history entry dictionaries
        """
        Results = self.ExecuteQuery(
            """
            SELECT * FROM GenerationHistory
            WHERE ModelName = ?
            ORDER BY CreatedAt DESC
            LIMIT ? OFFSET ?
            """,
            (ModelName, Limit, Offset)
        )
        
        Columns = [
            "ID", "ModelName", "Prompt", "Response", "Temperature",
            "TopP", "MaxTokens", "FrequencyPenalty", "PresencePenalty",
            "InputTokens", "OutputTokens", "TotalTokens",
            "GenerationTime", "CreatedAt"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    def ClearGenerationHistory(self) -> int:
        """
        Clear all generation history.
        
        Returns:
            Number of entries deleted
        """
        return self.ExecuteNonQuery("DELETE FROM GenerationHistory")
    
    # Benchmark Methods
    
    def AddBenchmarkResult(self, BenchmarkName: str, ModelName: str, Prompt: str,
                          AverageTime: float, AverageTokens: int, TokensPerSecond: float,
                          Runs: int, ConfigParams: Dict[str, Any]) -> int:
        """
        Add a benchmark result.
        
        Args:
            BenchmarkName: Name of the benchmark
            ModelName: Name of the model
            Prompt: Benchmark prompt
            AverageTime: Average generation time (seconds)
            AverageTokens: Average number of tokens
            TokensPerSecond: Average tokens per second
            Runs: Number of benchmark runs
            ConfigParams: Configuration parameters used
            
        Returns:
            ID of the new benchmark result
        """
        # Save model configuration
        ConfigID = self.SaveModelConfig(ModelName, f"Benchmark-{BenchmarkName}", ConfigParams)
        
        Query = """
        INSERT INTO BenchmarkResults (
            BenchmarkName, ModelName, ConfigID, Prompt,
            AverageTime, AverageTokens, AverageTokensPerSecond, Runs)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        return self.ExecuteNonQuery(
            Query,
            (
                BenchmarkName,
                ModelName,
                ConfigID,
                Prompt,
                AverageTime,
                AverageTokens,
                TokensPerSecond,
                Runs
            )
        )
    
    def GetBenchmarkResults(self, ModelName: str = None) -> List[Dict[str, Any]]:
        """
        Get benchmark results, optionally filtered by model.
        
        Args:
            ModelName: Optional model name filter
            
        Returns:
            List of benchmark result dictionaries
        """
        if ModelName:
            Results = self.ExecuteQuery(
                """
                SELECT b.*, c.Temperature, c.TopP, c.MaxTokens, 
                       c.FrequencyPenalty, c.PresencePenalty
                FROM BenchmarkResults b
                JOIN ModelConfigs c ON b.ConfigID = c.ID
                WHERE b.ModelName = ?
                ORDER BY b.CreatedAt DESC
                """,
                (ModelName,)
            )
        else:
            Results = self.ExecuteQuery(
                """
                SELECT b.*, c.Temperature, c.TopP, c.MaxTokens, 
                       c.FrequencyPenalty, c.PresencePenalty
                FROM BenchmarkResults b
                JOIN ModelConfigs c ON b.ConfigID = c.ID
                ORDER BY b.CreatedAt DESC
                """
            )
        
        Columns = [
            "ID", "BenchmarkName", "ModelName", "ConfigID", "Prompt",
            "AverageTime", "AverageTokens", "AverageTokensPerSecond", "Runs",
            "CreatedAt", "Temperature", "TopP", "MaxTokens",
            "FrequencyPenalty", "PresencePenalty"
        ]
        
        return [dict(zip(Columns, Row)) for Row in Results]
    
    # Database Utility Methods
    
    def BackupDatabase(self, BackupPath: str) -> bool:
        """
        Create a backup of the database.
        
        Args:
            BackupPath: Path for the backup file
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Ensure directory exists
            os.makedirs(os.path.dirname(BackupPath), exist_ok=True)
            
            # Connect to source database
            SourceConn = sqlite3.connect(self.DBPath)
            
            # Connect to backup database
            BackupConn = sqlite3.connect(BackupPath)
            
            # Copy database content
            SourceConn.backup(BackupConn)
            
            # Close connections
            SourceConn.close()
            BackupConn.close()
            
            self.Logger.info(f"Database backed up to: {BackupPath}")
            return True
        
        except sqlite3.Error as Error:
            self.Logger.error(f"Error backing up database: {Error}")
            return False
    
    def RestoreDatabase(self, BackupPath: str) -> bool:
        """
        Restore the database from a backup.
        
        Args:
            BackupPath: Path to the backup file
            
        Returns:
            True if successful, False otherwise
        """
        try:
            if not os.path.exists(BackupPath):
                self.Logger.error(f"Backup file not found: {BackupPath}")
                return False
            
            # Close any open connections
            try:
                self.GetConnection().close()
            except:
                pass
            
            # Connect to backup database
            BackupConn = sqlite3.connect(BackupPath)
            
            # Connect to target database
            TargetConn = sqlite3.connect(self.DBPath)
            
            # Copy database content
            BackupConn.backup(TargetConn)
            
            # Close connections
            BackupConn.close()
            TargetConn.close()
            
            self.Logger.info(f"Database restored from: {BackupPath}")
            return True
        
        except sqlite3.Error as Error:
            self.Logger.error(f"Error restoring database: {Error}")
            return False

================
File: Core/LoggingUtils.py
================
# File: LoggingUtils.py
# Path: OllamaModelEditor/Core/LoggingUtils.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Logging utilities for the OllamaModelEditor application

import logging
import os
from pathlib import Path

def SetupLogging(LogLevel=logging.INFO, LogToFile=True):
    """
    Set up logging for the application.
    
    Args:
        LogLevel: Logging level (default: INFO)
        LogToFile: Whether to log to file (default: True)
    """
    # Create logger
    Logger = logging.getLogger('OllamaModelEditor')
    Logger.setLevel(LogLevel)
    
    # Create formatter
    Formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    
    # Create console handler
    ConsoleHandler = logging.StreamHandler()
    ConsoleHandler.setLevel(LogLevel)
    ConsoleHandler.setFormatter(Formatter)
    Logger.addHandler(ConsoleHandler)
    
    # Create file handler if requested
    if LogToFile:
        # Determine log directory
        HomeDir = Path.home()
        if os.name == 'nt':  # Windows
            LogDir = HomeDir / 'AppData' / 'Local' / 'OllamaModelEditor' / 'logs'
        else:  # macOS and Linux
            LogDir = HomeDir / '.config' / 'ollamaModelEditor' / 'logs'
        
        # Create directory if it doesn't exist
        LogDir.mkdir(parents=True, exist_ok=True)
        
        # Create file handler
        LogFile = LogDir / 'ollamaModelEditor.log'
        FileHandler = logging.FileHandler(str(LogFile))
        FileHandler.setLevel(LogLevel)
        FileHandler.setFormatter(Formatter)
        Logger.addHandler(FileHandler)
    
    return Logger

================
File: Core/ModelManager.py
================
# File: ModelManager.py
# Path: OllamaModelEditor/Core/ModelManager.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-12 11:30PM
# Description: Manages Ollama model operations for the OllamaModelEditor application

import os
import json
import requests
import time
from typing import Dict, List, Any, Optional, Tuple, Union
from pathlib import Path
import logging

# Import project modules
from Core.ConfigManager import ConfigManager

class ModelManager:
    """Manages Ollama model operations and interactions."""
    
    def __init__(self, Config: ConfigManager):
        """
        Initialize the model manager.
        
        Args:
            Config: Configuration manager instance
        """
        self.Config = Config
        self.APIEndpoint = Config.GetAppConfig('APIEndpoint', 'http://localhost:11434/api')
        self.Logger = logging.getLogger('OllamaModelEditor.ModelManager')
        self.AvailableModels = []
        self.CurrentModel = None
        
        # Get database reference from Config if available
        self.DB = getattr(Config, 'DB', None)
    
    def GetAvailableModels(self) -> List[Dict[str, Any]]:
        """
        Retrieve list of available Ollama models.
        
        Returns:
            List of model information dictionaries
        """
        try:
            # Send request to Ollama API
            Response = requests.get(f"{self.APIEndpoint}/tags")
            
            if Response.status_code == 200:
                # Parse response and update available models
                ModelData = Response.json()
                self.AvailableModels = ModelData.get('models', [])
                return self.AvailableModels
            else:
                self.Logger.error(f"Failed to retrieve models: {Response.status_code}")
                return []
                
        except Exception as Error:
            self.Logger.error(f"Error retrieving models: {Error}")
            return []
    
    def GetModelDetails(self, ModelName: str) -> Dict[str, Any]:
        """
        Get detailed information about a specific model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            Dict containing model details or empty dict if not found
        """
        try:
            # First check if we need to fetch the latest models
            if not self.AvailableModels:
                self.GetAvailableModels()
            
            # Find model in available models
            for Model in self.AvailableModels:
                if Model.get('name') == ModelName:
                    # Get additional model information
                    Response = requests.post(
                        f"{self.APIEndpoint}/show",
                        json={"name": ModelName}
                    )
                    
                    if Response.status_code == 200:
                        # Combine basic and detailed model information
                        DetailedInfo = Response.json()
                        
                        # Store last accessed time in database if available
                        if self.DB:
                            # Check if model exists in database
                            ModelConfigs = self.DB.GetModelConfigs(ModelName)
                            if not ModelConfigs:
                                # Create default config for model
                                DefaultParams = self.Config.GetModelConfig('DefaultParameters')
                                self.DB.SaveModelConfig(ModelName, "Default", DefaultParams)
                        
                        return {**Model, **DetailedInfo}
                    else:
                        self.Logger.error(f"Failed to get model details: {Response.status_code}")
                        return Model
            
            self.Logger.warning(f"Model not found: {ModelName}")
            return {}
                
        except Exception as Error:
            self.Logger.error(f"Error getting model details: {Error}")
            return {}
    
    def SetCurrentModel(self, ModelName: str) -> bool:
        """
        Set the current working model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Get model details
            ModelDetails = self.GetModelDetails(ModelName)
            
            if not ModelDetails:
                self.Logger.error(f"Cannot set current model: {ModelName} not found")
                return False
            
            # Set current model
            self.CurrentModel = ModelDetails
            
            # Add to recent models list
            self.Config.AddRecentModel(ModelName)
            
            # Update last used timestamp in database if available
            if self.DB:
                # Update LastUsed timestamp
                self.DB.ExecuteNonQuery(
                    """
                    UPDATE ModelConfigs 
                    SET LastUsed = CURRENT_TIMESTAMP 
                    WHERE ModelName = ?
                    """,
                    (ModelName,)
                )
            
            self.Logger.info(f"Current model set to: {ModelName}")
            return True
                
        except Exception as Error:
            self.Logger.error(f"Error setting current model: {Error}")
            return False
    
    def GetCurrentModel(self) -> Optional[Dict[str, Any]]:
        """
        Get the current working model.
        
        Returns:
            Dict containing current model details or None if not set
        """
        return self.CurrentModel
    
    def GenerateCompletion(self, Prompt: str, Parameters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Generate a completion using the current model.
        
        Args:
            Prompt: Input prompt for generation
            Parameters: Optional parameter overrides
            
        Returns:
            Dict containing the response
        """
        try:
            if not self.CurrentModel:
                self.Logger.error("No current model set")
                return {"error": "No current model set"}
            
            # Get model name
            ModelName = self.CurrentModel.get('name')
            
            # Get model parameters with defaults
            ModelParams = self.Config.GetModelConfig(ModelName)
            
            # Override with provided parameters if any
            if Parameters:
                ModelParams.update(Parameters)
            
            # Start timer for performance tracking
            StartTime = time.time()
            
            # Prepare request
            RequestData = {
                "model": ModelName,
                "prompt": Prompt,
                "temperature": ModelParams.get('Temperature', 0.7),
                "top_p": ModelParams.get('TopP', 0.9),
                "max_tokens": ModelParams.get('MaxTokens', 2048),
                "frequency_penalty": ModelParams.get('FrequencyPenalty', 0.0),
                "presence_penalty": ModelParams.get('PresencePenalty', 0.0),
                "stream": False
            }
            
            # Send request to Ollama API
            Response = requests.post(
                f"{self.APIEndpoint}/generate",
                json=RequestData
            )
            
            # Calculate elapsed time
            ElapsedTime = time.time() - StartTime
            
            if Response.status_code == 200:
                ResponseData = Response.json()
                
                # Add generation time to response
                ResponseData['generation_time'] = ElapsedTime
                
                # Record in history if database is available
                if self.DB:
                    # Extract metrics
                    Metrics = {
                        'InputTokens': ResponseData.get('prompt_eval_count', 0),
                        'OutputTokens': ResponseData.get('eval_count', 0),
                        'TotalTokens': ResponseData.get('prompt_eval_count', 0) + ResponseData.get('eval_count', 0),
                        'GenerationTime': ElapsedTime
                    }
                    
                    # Add to history
                    self.DB.AddGenerationHistory(
                        ModelName,
                        Prompt,
                        ResponseData.get('response', ''),
                        ModelParams,
                        Metrics
                    )
                
                return ResponseData
            else:
                self.Logger.error(f"Generation failed: {Response.status_code}")
                return {"error": f"Generation failed: {Response.status_code}"}
                
        except Exception as Error:
            self.Logger.error(f"Error generating completion: {Error}")
            return {"error": str(Error)}
    
    def UpdateModelParameters(self, ModelName: str, Parameters: Dict[str, Any]) -> bool:
        """
        Update parameters for a specific model.
        
        Args:
            ModelName: Name of the model
            Parameters: New parameter values
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Get current parameters
            CurrentParams = self.Config.GetModelConfig(ModelName)
            
            # Update parameters
            CurrentParams.update(Parameters)
            
            # Validate parameters
            if not self._ValidateParameters(CurrentParams):
                self.Logger.error("Invalid parameters")
                return False
            
            # Save updated parameters
            self.Config.SetModelConfig(ModelName, CurrentParams)
            
            # Save to database if available
            if self.DB:
                self.DB.SaveModelConfig(ModelName, "Default", CurrentParams)
            
            self.Logger.info(f"Model parameters updated for {ModelName}")
            return True
                
        except Exception as Error:
            self.Logger.error(f"Error updating model parameters: {Error}")
            return False
    
    def _ValidateParameters(self, Parameters: Dict[str, Any]) -> bool:
        """
        Validate model parameters.
        
        Args:
            Parameters: Parameters to validate
            
        Returns:
            bool: True if parameters are valid, False otherwise
        """
        # Required parameters
        RequiredParams = ['Temperature', 'TopP', 'MaxTokens']
        
        # Check required parameters
        for Param in RequiredParams:
            if Param not in Parameters:
                self.Logger.error(f"Missing required parameter: {Param}")
                return False
        
        # Validate parameter ranges
        if not 0 <= Parameters.get('Temperature', 0) <= 2:
            self.Logger.error("Temperature must be between 0 and 2")
            return False
        
        if not 0 <= Parameters.get('TopP', 0) <= 1:
            self.Logger.error("TopP must be between 0 and 1")
            return False
        
        if Parameters.get('MaxTokens', 0) <= 0:
            self.Logger.error("MaxTokens must be greater than 0")
            return False
        
        return True
    
    def BenchmarkModel(self, ModelName: str, Prompts: List[str], 
                      Parameters: Optional[Dict[str, Any]] = None, 
                      Runs: int = 3) -> Dict[str, Any]:
        """
        Benchmark model performance with provided prompts.
        
        Args:
            ModelName: Name of the model
            Prompts: List of test prompts
            Parameters: Optional parameter overrides
            Runs: Number of runs per prompt
            
        Returns:
            Dict containing benchmark results
        """
        try:
            # Set current model if not already set
            if not self.CurrentModel or self.CurrentModel.get('name') != ModelName:
                if not self.SetCurrentModel(ModelName):
                    return {"error": f"Could not set model: {ModelName}"}
            
            # Get parameters (with overrides if provided)
            ModelParams = self.Config.GetModelConfig(ModelName)
            if Parameters:
                ModelParams.update(Parameters)
            
            # Initialize results
            Results = {
                "model": ModelName,
                "parameters": ModelParams,
                "tests": [],
                "summary": {}
            }
            
            # Run tests for each prompt
            TotalTokens = 0
            TotalTime = 0
            
            for Index, Prompt in enumerate(Prompts):
                # Initialize metrics for this prompt
                PromptTotalTime = 0
                PromptTotalTokens = 0
                PromptTotalOutputTokens = 0
                SuccessfulRuns = 0
                
                # Run multiple times for consistent results
                for Run in range(Runs):
                    # Generate completion
                    Response = self.GenerateCompletion(Prompt, ModelParams)
                    
                    # Check for errors
                    if "error" in Response:
                        continue
                    
                    # Extract metrics
                    PromptTotalTime += Response.get('generation_time', 0)
                    InputTokens = Response.get('prompt_eval_count', 0)
                    OutputTokens = Response.get('eval_count', 0)
                    PromptTotalTokens += InputTokens + OutputTokens
                    PromptTotalOutputTokens += OutputTokens
                    
                    SuccessfulRuns += 1
                
                # Skip if all runs failed
                if SuccessfulRuns == 0:
                    Results["tests"].append({
                        "id": Index,
                        "prompt": Prompt,
                        "error": "All benchmark runs failed"
                    })
                    continue
                
                # Calculate averages
                AverageTime = PromptTotalTime / SuccessfulRuns
                AverageTokens = PromptTotalTokens / SuccessfulRuns
                AverageOutputTokens = PromptTotalOutputTokens / SuccessfulRuns
                TokensPerSecond = AverageOutputTokens / AverageTime if AverageTime > 0 else 0
                
                # Update totals
                TotalTokens += PromptTotalTokens
                TotalTime += PromptTotalTime
                
                # Add test result
                Results["tests"].append({
                    "id": Index,
                    "prompt": Prompt,
                    "average_time": AverageTime,
                    "average_tokens": AverageTokens,
                    "average_output_tokens": AverageOutputTokens,
                    "tokens_per_second": TokensPerSecond,
                    "successful_runs": SuccessfulRuns
                })
                
                # Save to database if available
                if self.DB:
                    self.DB.AddBenchmarkResult(
                        f"Prompt-{Index}",
                        ModelName,
                        Prompt,
                        AverageTime,
                        AverageTokens,
                        TokensPerSecond,
                        SuccessfulRuns,
                        ModelParams
                    )
            
            # Calculate summary statistics
            TestCount = len(Results["tests"])
            if TestCount > 0:
                Results["summary"] = {
                    "total_tests": TestCount,
                    "total_tokens": TotalTokens,
                    "total_time": TotalTime,
                    "average_tokens_per_second": TotalTokens / TotalTime if TotalTime > 0 else 0,
                    "average_time_per_test": TotalTime / TestCount,
                    "benchmark_date": time.strftime("%Y-%m-%d %H:%M:%S")
                }
            
            return Results
                
        except Exception as Error:
            self.Logger.error(f"Error benchmarking model: {Error}")
            return {"error": str(Error)}
    
    def ExportModelDefinition(self, ModelName: str, FilePath: str) -> bool:
        """
        Export model definition to a file.
        
        Args:
            ModelName: Name of the model
            FilePath: Path to save the definition
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Get model details
            ModelDetails = self.GetModelDetails(ModelName)
            
            if not ModelDetails:
                self.Logger.error(f"Model not found: {ModelName}")
                return False
            
            # Get model parameters
            ModelParams = self.Config.GetModelConfig(ModelName)
            
            # Get benchmark results if available
            BenchmarkResults = []
            if self.DB:
                BenchmarkResults = self.DB.GetBenchmarkResults(ModelName)
            
            # Combine details, parameters, and benchmarks
            ExportData = {
                "name": ModelName,
                "details": ModelDetails,
                "parameters": ModelParams,
                "benchmarks": BenchmarkResults
            }
            
            # Ensure directory exists
            Path(FilePath).parent.mkdir(parents=True, exist_ok=True)
            
            # Write to file
            with open(FilePath, 'w') as ExportFile:
                json.dump(ExportData, ExportFile, indent=2)
            
            self.Logger.info(f"Model definition exported to {FilePath}")
            return True
                
        except Exception as Error:
            self.Logger.error(f"Error exporting model definition: {Error}")
            return False
    
    def GetModelHistory(self, ModelName: str, Limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get generation history for a model.
        
        Args:
            ModelName: Name of the model
            Limit: Maximum number of entries to retrieve
            
        Returns:
            List of history entries
        """
        if self.DB:
            return self.DB.GetGenerationHistoryForModel(ModelName, Limit)
        
        return []
    
    def GetModelBenchmarks(self, ModelName: str) -> List[Dict[str, Any]]:
        """
        Get benchmark results for a model.
        
        Args:
            ModelName: Name of the model
            
        Returns:
            List of benchmark results
        """
        if self.DB:
            return self.DB.GetBenchmarkResults(ModelName)
        
        return []
    
    def ApplyPreset(self, ModelName: str, PresetName: str) -> bool:
        """
        Apply a parameter preset to a model.
        
        Args:
            ModelName: Name of the model
            PresetName: Name of the preset
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Get preset parameters
            PresetParams = None
            
            if self.DB:
                # Try to get from database
                Preset = self.DB.GetPreset(PresetName)
                if Preset:
                    PresetParams = {
                        'Temperature': Preset['Temperature'],
                        'TopP': Preset['TopP'],
                        'MaxTokens': Preset['MaxTokens'],
                        'FrequencyPenalty': Preset['FrequencyPenalty'],
                        'PresencePenalty': Preset['PresencePenalty']
                    }
                    
                    # Update preset usage statistics
                    self.DB.UpdatePresetUsage(PresetName)
            
            # Fall back to hardcoded presets if not found
            if not PresetParams:
                # Define presets
                Presets = {
                    "Default": {
                        'Temperature': 0.7,
                        'TopP': 0.9,
                        'MaxTokens': 2048,
                        'FrequencyPenalty': 0.0,
                        'PresencePenalty': 0.0
                    },
                    "Creative": {
                        'Temperature': 1.0,
                        'TopP': 0.95,
                        'MaxTokens': 4096,
                        'FrequencyPenalty': 0.0,
                        'PresencePenalty': 0.0
                    },
                    "Precise": {
                        'Temperature': 0.3,
                        'TopP': 0.7,
                        'MaxTokens': 2048,
                        'FrequencyPenalty': 0.5,
                        'PresencePenalty': 0.0
                    },
                    "Fast": {
                        'Temperature': 0.7,
                        'TopP': 0.9,
                        'MaxTokens': 1024,
                        'FrequencyPenalty': 0.0,
                        'PresencePenalty': 0.0
                    }
                }
                
                if PresetName in Presets:
                    PresetParams = Presets[PresetName]
                else:
                    self.Logger.error(f"Preset not found: {PresetName}")
                    return False
            
            # Apply preset parameters
            return self.UpdateModelParameters(ModelName, PresetParams)
        
        except Exception as Error:
            self.Logger.error(f"Error applying preset: {Error}")
            return False
    
    def SaveUserPreset(self, PresetName: str, Description: str, Parameters: Dict[str, Any]) -> bool:
        """
        Save a user-defined preset.
        
        Args:
            PresetName: Name of the preset
            Description: Preset description
            Parameters: Preset parameters
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Validate parameters
            if not self._ValidateParameters(Parameters):
                self.Logger.error("Invalid parameters for preset")
                return False
            
            # Save to database if available
            if self.DB:
                self.DB.SaveUserPreset(PresetName, Description, Parameters)
                self.Logger.info(f"User preset '{PresetName}' saved")
                return True
            
            # No database, cannot save user preset
            self.Logger.error("Database not available, cannot save user preset")
            return False
            
        except Exception as Error:
            self.Logger.error(f"Error saving user preset: {Error}")
            return False
    
    def GetUserPresets(self) -> List[Dict[str, Any]]:
        """
        Get all user-defined presets.
        
        Returns:
            List of preset dictionaries
        """
        if self.DB:
            UserPresets = self.DB.GetUserPresets()
            
            # Convert database format to application format
            return [{
                'Name': Preset['Name'],
                'Description': Preset['Description'],
                'Parameters': {
                    'Temperature': Preset['Temperature'],
                    'TopP': Preset['TopP'],
                    'MaxTokens': Preset['MaxTokens'],
                    'FrequencyPenalty': Preset['FrequencyPenalty'],
                    'PresencePenalty': Preset['PresencePenalty']
                }
            } for Preset in UserPresets]
        
        return []
    
    def DeleteUserPreset(self, PresetName: str) -> bool:
        """
        Delete a user-defined preset.
        
        Args:
            PresetName: Name of the preset
            
        Returns:
            bool: True if successful, False otherwise
        """
        if self.DB:
            Result = self.DB.DeleteUserPreset(PresetName)
            if Result:
                self.Logger.info(f"User preset '{PresetName}' deleted")
            else:
                self.Logger.warning(f"Failed to delete user preset '{PresetName}'")
            return Result
        
        return False

================
File: docs/Notes/Additional Features from Original Design and Brainstorming.md
================
# Additional Features from Original Design and Brainstorming

# 1. Add benchmark functionality to BenchmarkView.py

# Update BenchmarkView._SetupUI method
def _SetupUI(self):
    """Set up the user interface."""
    # Create layout
    Layout = QVBoxLayout()
    self.setLayout(Layout)
    
    # Add header label
    HeaderLabel = QLabel("Model Benchmark")
    HeaderLabel.setStyleSheet("font-weight: bold; font-size: 14px; margin-bottom: 10px;")
    Layout.addWidget(HeaderLabel)
    
    # Add description
    DescriptionLabel = QLabel(
        "Compare model performance with different configurations. "
        "Enter sample prompts below to test how the model responds with current settings."
    )
    DescriptionLabel.setWordWrap(True)
    Layout.addWidget(DescriptionLabel)
    
    # Add benchmark configuration section
    ConfigFrame = QFrame()
    ConfigFrame.setFrameShape(QFrame.StyledPanel)
    ConfigLayout = QFormLayout(ConfigFrame)
    
    # Add model comparison selector
    self.CompareCheckbox = QCheckBox("Compare with another configuration")
    self.CompareCheckbox.toggled.connect(self._OnCompareToggled)
    ConfigLayout.addRow(self.CompareCheckbox)
    
    # Add comparison config selector (initially hidden)
    self.ComparisonConfigLayout = QHBoxLayout()
    self.ComparisonConfigLabel = QLabel("Comparison config:")
    self.ComparisonConfigLabel.setEnabled(False)
    self.ComparisonConfigCombo = QComboBox()
    self.ComparisonConfigCombo.setEnabled(False)
    self.ComparisonConfigCombo.addItems(["Default", "Creative", "Precise", "Fast", "Custom..."])
    self.ComparisonConfigLayout.addWidget(self.ComparisonConfigLabel)
    self.ComparisonConfigLayout.addWidget(self.ComparisonConfigCombo, 1)
    ConfigLayout.addRow(self.ComparisonConfigLayout)
    
    # Add repetition control
    RepetitionLayout = QHBoxLayout()
    self.RepetitionLabel = QLabel("Repetitions:")
    self.RepetitionSpinner = QSpinBox()
    self.RepetitionSpinner.setMinimum(1)
    self.RepetitionSpinner.setMaximum(10)
    self.RepetitionSpinner.setValue(3)
    self.RepetitionSpinner.setToolTip("Number of times to run each prompt for more accurate benchmarking")
    RepetitionLayout.addWidget(self.RepetitionLabel)
    RepetitionLayout.addWidget(self.RepetitionSpinner)
    RepetitionLayout.addStretch()
    ConfigLayout.addRow(RepetitionLayout)
    
    Layout.addWidget(ConfigFrame)
    
    # Add prompt input
    PromptLabel = QLabel("Enter benchmark prompts (one per line):")
    Layout.addWidget(PromptLabel)
    
    self.PromptsText = QTextEdit()
    self.PromptsText.setPlaceholderText("Enter benchmark prompts here...\n\nExample:\nSummarize the key features of neural networks.\nExplain the difference between supervised and unsupervised learning.\nWrite a short poem about artificial intelligence.")
    self.PromptsText.setMinimumHeight(100)
    Layout.addWidget(self.PromptsText)
    
    # Add buttons
    ButtonLayout = QHBoxLayout()
    
    self.RunButton = QPushButton("Run Benchmark")
    self.RunButton.setIcon(QIcon.fromTheme("media-playback-start"))
    self.RunButton.clicked.connect(self._OnRunBenchmark)
    ButtonLayout.addWidget(self.RunButton)
    
    self.StopButton = QPushButton("Stop")
    self.StopButton.setIcon(QIcon.fromTheme("media-playback-stop"))
    self.StopButton.clicked.connect(self._OnStopBenchmark)
    self.StopButton.setEnabled(False)
    ButtonLayout.addWidget(self.StopButton)
    
    self.SaveButton = QPushButton("Save Results")
    self.SaveButton.setIcon(QIcon.fromTheme("document-save"))
    self.SaveButton.clicked.connect(self._OnSaveResults)
    self.SaveButton.setEnabled(False)
    ButtonLayout.addWidget(self.SaveButton)
    
    Layout.addLayout(ButtonLayout)
    
    # Add results display with tabs
    self.ResultsTabs = QTabWidget()
    
    # Summary tab
    self.SummaryTab = QWidget()
    SummaryLayout = QVBoxLayout(self.SummaryTab)
    
    self.SummaryText = QTextEdit()
    self.SummaryText.setReadOnly(True)
    SummaryLayout.addWidget(self.SummaryText)
    
    # Charts tab
    self.ChartsTab = QWidget()
    ChartsLayout = QVBoxLayout(self.ChartsTab)
    
    self.ChartPlaceholder = QLabel("Charts will appear here after running benchmarks")
    self.ChartPlaceholder.setAlignment(Qt.AlignCenter)
    ChartsLayout.addWidget(self.ChartPlaceholder)
    
    # Detailed results tab
    self.DetailsTab = QWidget()
    DetailsLayout = QVBoxLayout(self.DetailsTab)
    
    self.DetailsText = QTextEdit()
    self.DetailsText.setReadOnly(True)
    DetailsLayout.addWidget(self.DetailsText)
    
    # Add tabs to tab widget
    self.ResultsTabs.addTab(self.SummaryTab, "Summary")
    self.ResultsTabs.addTab(self.ChartsTab, "Charts")
    self.ResultsTabs.addTab(self.DetailsTab, "Details")
    
    Layout.addWidget(self.ResultsTabs)

# Add new method to BenchmarkView
def _OnCompareToggled(self, Checked):
    """
    Handle compare checkbox toggle.
    
    Args:
        Checked: Whether the checkbox is checked
    """
    self.ComparisonConfigLabel.setEnabled(Checked)
    self.ComparisonConfigCombo.setEnabled(Checked)

# 2. Add configuration export/import functionality to MainWindow.py

# Add to MainWindow._OnExportModel
def _OnExportModel(self) -> None:
    """Handle export model definition action."""
    CurrentModel = self.ModelManager.GetCurrentModel()
    if not CurrentModel:
        QMessageBox.warning(
            self,
            "Export Error",
            "Please select a model first."
        )
        return
    
    ModelName = CurrentModel.get('name', 'unknown')
    
    # Get save file path
    FilePath, _ = QFileDialog.getSaveFileName(
        self,
        "Export Model Configuration",
        f"{ModelName}_config.json",
        "JSON Files (*.json);;YAML Files (*.yaml *.yml);;All Files (*.*)"
    )
    
    if not FilePath:
        return
    
    # Export model definition
    Success = self.ModelManager.ExportModelDefinition(ModelName, FilePath)
    
    if Success:
        QMessageBox.information(
            self,
            "Export Successful",
            f"Model configuration for {ModelName} was exported successfully to {FilePath}."
        )
    else:
        QMessageBox.critical(
            self,
            "Export Error",
            f"Failed to export model configuration for {ModelName}."
        )

# Add export configuration dialog
class ExportConfigDialog(QDialog):
    """Dialog for exporting model configuration."""
    
    def __init__(self, ModelName, Config, Parent=None):
        """
        Initialize the dialog.
        
        Args:
            ModelName: Name of the model
            Config: Configuration manager instance
            Parent: Parent widget
        """
        super().__init__(Parent)
        
        self.ModelName = ModelName
        self.Config = Config
        
        self.setWindowTitle(f"Export {ModelName} Configuration")
        self.setMinimumWidth(400)
        
        # Create layout
        Layout = QVBoxLayout(self)
        
        # Add export options
        OptionsGroup = QGroupBox("Export Options")
        OptionsLayout = QVBoxLayout(OptionsGroup)
        
        self.IncludeModelInfo = QCheckBox("Include Model Information")
        self.IncludeModelInfo.setChecked(True)
        OptionsLayout.addWidget(self.IncludeModelInfo)
        
        self.IncludeParameters = QCheckBox("Include Parameters")
        self.IncludeParameters.setChecked(True)
        OptionsLayout.addWidget(self.IncludeParameters)
        
        self.IncludeBenchmarks = QCheckBox("Include Benchmark Results")
        self.IncludeBenchmarks.setChecked(False)
        OptionsLayout.addWidget(self.IncludeBenchmarks)
        
        Layout.addWidget(OptionsGroup)
        
        # Add file format selection
        FormatGroup = QGroupBox("File Format")
        FormatLayout = QVBoxLayout(FormatGroup)
        
        self.JsonFormat = QRadioButton("JSON")
        self.JsonFormat.setChecked(True)
        FormatLayout.addWidget(self.JsonFormat)
        
        self.YamlFormat = QRadioButton("YAML")
        FormatLayout.addWidget(self.YamlFormat)
        
        Layout.addWidget(FormatGroup)
        
        # Add buttons
        ButtonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        ButtonBox.accepted.connect(self.accept)
        ButtonBox.rejected.connect(self.reject)
        Layout.addWidget(ButtonBox)

# 3. Add detailed analysis view

# Create new AnalysisView.py component
"""
# File: AnalysisView.py
# Path: OllamaModelEditor/GUI/Components/AnalysisView.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-12
# Last Modified: 2025-03-12
# Description: Detailed analysis component for the OllamaModelEditor application

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QTextEdit, QComboBox, QSplitter, QTabWidget, QFrame,
    QFormLayout, QSpinBox, QCheckBox
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QFont

class AnalysisView(QWidget):
    \"""Widget for detailed model analysis.\"""
    
    def __init__(self, ModelManager, Config):
        \"""
        Initialize the analysis view.
        
        Args:
            ModelManager: Model manager instance
            Config: Configuration manager instance
        \"""
        super().__init__()
        
        # Store references
        self.ModelManager = ModelManager
        self.Config = Config
        
        # Set up UI
        self._SetupUI()
    
    def _SetupUI(self):
        \"""Set up the user interface.\"""
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add header label
        HeaderLabel = QLabel("Detailed Analysis")
        HeaderLabel.setStyleSheet("font-weight: bold; font-size: 14px; margin-bottom: 10px;")
        Layout.addWidget(HeaderLabel)
        
        # Add description
        DescriptionLabel = QLabel(
            "Get detailed insights into how parameter changes affect model performance. "
            "Test with different inputs and analyze the outputs."
        )
        DescriptionLabel.setWordWrap(True)
        Layout.addWidget(DescriptionLabel)
        
        # Create main splitter
        Splitter = QSplitter(Qt.Vertical)
        Splitter.setHandleWidth(6)
        Splitter.setChildrenCollapsible(False)
        
        # Input section
        InputWidget = QWidget()
        InputLayout = QVBoxLayout(InputWidget)
        InputLayout.setContentsMargins(0, 0, 0, 0)
        
        # Input parameters
        InputParamsLayout = QHBoxLayout()
        
        # Input type selector
        InputTypeLayout = QFormLayout()
        self.InputTypeCombo = QComboBox()
        self.InputTypeCombo.addItems(["Text", "Code", "Summary", "Translation", "Question/Answer"])
        InputTypeLayout.addRow("Input Type:", self.InputTypeCombo)
        InputParamsLayout.addLayout(InputTypeLayout)
        
        # Max tokens
        MaxTokensLayout = QFormLayout()
        self.MaxTokensSpinner = QSpinBox()
        self.MaxTokensSpinner.setRange(1, 32000)
        self.MaxTokensSpinner.setValue(2048)
        MaxTokensLayout.addRow("Max Tokens:", self.MaxTokensSpinner)
        InputParamsLayout.addLayout(MaxTokensLayout)
        
        # Stream output
        StreamLayout = QFormLayout()
        self.StreamCheckbox = QCheckBox("Stream Output")
        self.StreamCheckbox.setChecked(True)
        StreamLayout.addRow(self.StreamCheckbox)
        InputParamsLayout.addLayout(StreamLayout)
        
        InputLayout.addLayout(InputParamsLayout)
        
        # Input text
        InputLabel = QLabel("Input:")
        InputLayout.addWidget(InputLabel)
        
        self.InputText = QTextEdit()
        self.InputText.setPlaceholderText("Enter your input text here...")
        self.InputText.setMinimumHeight(100)
        InputLayout.addWidget(self.InputText)
        
        # Action buttons
        ButtonLayout = QHBoxLayout()
        
        self.AnalyzeButton = QPushButton("Analyze")
        self.AnalyzeButton.clicked.connect(self._OnAnalyze)
        ButtonLayout.addWidget(self.AnalyzeButton)
        
        self.ClearButton = QPushButton("Clear")
        self.ClearButton.clicked.connect(self._OnClear)
        ButtonLayout.addWidget(self.ClearButton)
        
        InputLayout.addLayout(ButtonLayout)
        
        # Add input widget to splitter
        Splitter.addWidget(InputWidget)
        
        # Results section
        ResultsWidget = QWidget()
        ResultsLayout = QVBoxLayout(ResultsWidget)
        ResultsLayout.setContentsMargins(0, 0, 0, 0)
        
        # Results tabs
        self.ResultsTabs = QTabWidget()
        
        # Output tab
        self.OutputTab = QWidget()
        OutputLayout = QVBoxLayout(self.OutputTab)
        
        self.OutputText = QTextEdit()
        self.OutputText.setReadOnly(True)
        OutputLayout.addWidget(self.OutputText)
        
        # Analysis tab
        self.AnalysisTab = QWidget()
        AnalysisLayout = QVBoxLayout(self.AnalysisTab)
        
        self.AnalysisText = QTextEdit()
        self.AnalysisText.setReadOnly(True)
        AnalysisLayout.addWidget(self.AnalysisText)
        
        # Metrics tab
        self.MetricsTab = QWidget()
        MetricsLayout = QVBoxLayout(self.MetricsTab)
        
        self.MetricsText = QTextEdit()
        self.MetricsText.setReadOnly(True)
        MetricsLayout.addWidget(self.MetricsText)
        
        # Add tabs to tab widget
        self.ResultsTabs.addTab(self.OutputTab, "Output")
        self.ResultsTabs.addTab(self.AnalysisTab, "Analysis")
        self.ResultsTabs.addTab(self.MetricsTab, "Metrics")
        
        ResultsLayout.addWidget(self.ResultsTabs)
        
        # Add results widget to splitter
        Splitter.addWidget(ResultsWidget)
        
        # Set initial splitter sizes
        Splitter.

================
File: docs/Notes/AIDEV-PascalCase Implementation Plan.md
================
# AIDEV-PascalCase Implementation Plan

## Overview

This document outlines the comprehensive plan for implementing the AIDEV-PascalCase-1.2 standard throughout the OllamaModelEditor project, with a particular focus on ensuring the database schema and related components adhere to the standard.

## Goals

1. Ensure complete consistency with the AIDEV-PascalCase-1.2 standard across all components
2. Update the database schema to use PascalCase for all tables and columns
3. Modify all code that interacts with the database to use the new schema
4. Provide migration tools for existing users to update their databases
5. Update documentation to reflect the changes

## Components to Update

### 1. Database Schema

- [x] Create PascalCase database schema (`DatabaseSchema.sql`)
- [x] Update all table names to PascalCase
- [x] Update all column names to PascalCase
- [x] Ensure special terms (API, DB, GUI, etc.) are properly capitalized

### 2. Database Manager

- [x] Update `DBManager.py` to use PascalCase for all database interactions
- [x] Update SQL queries to use PascalCase column names
- [x] Update the default database path to use PascalCase filename

### 3. Configuration Manager

- [x] Update `ConfigManager.py` to work with the PascalCase database schema
- [x] Update methods that interact with the database
- [x] Update the configuration migration logic

### 4. Model Manager

- [ ] Update `ModelManager.py` to work with the PascalCase database schema
- [ ] Update methods that interact with the database
- [ ] Update any SQL queries to use PascalCase column names

### 5. Main Application

- [ ] Update `Main.py` to handle database initialization with the new schema
- [ ] Update command-line arguments for database path if necessary
- [ ] Add support for database migration from snake_case to PascalCase

### 6. GUI Components

- [ ] Update `BenchmarkView.py` to use PascalCase for database interactions
- [ ] Update `ParameterEditor.py` to work with the new schema if it interacts with the database
- [ ] Update any other GUI components that directly interact with the database

### 7. Utility Scripts

- [x] Create a database migration script (`MigrateDBToPascalCase.py`)
- [ ] Update any utility scripts that interact with the database

### 8. Testing

- [ ] Create test cases for the new database schema
- [ ] Test the migration script with different database states
- [ ] Test all components that interact with the database

### 9. Documentation

- [x] Create database migration guide
- [ ] Update general documentation to reflect PascalCase usage
- [ ] Add notes about the AIDEV-PascalCase-1.2 standard in relevant documentation

## Implementation Steps

### Phase 1: Core Database Components

1.  Create a PascalCase database schema
2.  Update DBManager class to use PascalCase
3.  Create a database migration script
4.  Update ConfigManager to work with the new schema

### Phase 2: Application Logic Components

5. Update ModelManager to work with the new schema
6. Update other core components that interact with the database
7. Test database migrations and functionality

### Phase 3: GUI and Utility Components

8. Update GUI components that interact with the database
9. Update utility scripts to support the new schema
10. Test GUI functionality with the PascalCase database

### Phase 4: Documentation and Finalization

11.  Create documentation for the PascalCase standard implementation
12. Update user guides to reference the new schema
13. Add migration instructions to documentation
14. Perform final comprehensive testing

## Migration Strategy

### For Developers

1. Create a branch for the PascalCase implementation
2. Implement changes in phases as outlined above
3. Create merge requests for each phase
4. Review code changes thoroughly before merging

### For Users

1. Provide a database migration script that:
   -  Backs up the existing database
   -  Creates new tables with PascalCase names
   -  Transfers data from old tables to new ones
   -  Updates any indices or constraints

2. Include clear documentation on how to:
   - Backup existing data
   - Run the migration script
   - Verify successful migration
   - Troubleshoot common issues

## Testing Plan

1. Unit tests for each updated component
2. Integration tests for database interactions
3. Migration tests with various database states:
   - Empty database
   - Database with minimal data
   - Database with substantial data
   - Database with custom user data

4. Edge case testing:
   - Migration failure scenarios
   - Database corruption recovery
   - Concurrent access during migration

## Timeline

- Day 1: Complete Phase 1 (Core Database Components) 
- Day 2: Complete Phase 2 (Application Logic Components)
- Day 3: Complete Phase 3 (GUI and Utility Components)
- Day 4: Complete Phase 4 (Documentation and Finalization)
- Day 5: Final testing and refinement

## Potential Challenges

1. Maintaining backward compatibility with existing user databases
   - Solution: Provide comprehensive migration tools and documentation

2. Ensuring all database queries are updated correctly
   - Solution: Thorough testing and code review

3. Handling special case names with acronyms (API, DB, etc.)
   - Solution: Apply consistent rules for special terms as per the AIDEV-PascalCase-1.2 standard

4. Maintaining performance during database migration
   - Solution: Optimize migration script for efficiency with large datasets

## Conclusion

By following this implementation plan, we will fully align the OllamaModelEditor project with the AIDEV-PascalCase-1.2 standard, ensuring a consistent visual fingerprint throughout the codebase and improving the overall coherence and maintainability of the project.

The plan prioritizes the most critical components first, provides comprehensive migration tools for users, and includes thorough testing to ensure a smooth transition to the new standard.

================
File: docs/Notes/ConfigManager Update for PascalCase DB Schema.md
================
# ConfigManager Update for PascalCase Database Schema

## Overview

The `ConfigManager` class needs to be updated to work with the new PascalCase database schema. This document outlines the necessary changes and provides a plan for implementation.

## Required Changes

1. Update database interaction methods to use PascalCase column names
2. Update method names to consistently use PascalCase (if any are not already)
3. Ensure all variable names follow PascalCase conventions
4. Update any hardcoded SQL queries to use the new column names
5. Modify database-related methods to work with the new schema

## Implementation Plan

### 1. Update DB-Related Methods

The following methods in the `ConfigManager` class need to be updated:

- `_LoadAppConfigFromDB()`
- `_LoadUserPreferencesFromDB()`
- `_LoadModelConfigsFromDB()`
- `MigrateToDatabase()`

### 2. Update SQL Queries

All SQL queries in the class need to be updated to use PascalCase column names. For example:

Old:
```python
Settings = self.DB.ExecuteQuery(
    "SELECT key, value, value_type FROM AppSettings"
)
```

New:
```python
Settings = self.DB.ExecuteQuery(
    "SELECT Key, Value, ValueType FROM AppSettings"
)
```

### 3. Update Database Path Logic

Ensure the database path logic uses PascalCase for filenames:

Old:
```python
return str(ConfigDir / 'ollama_model_editor.db')
```

New:
```python
return str(ConfigDir / 'OllamaModelEditor.db')
```

### 4. Update Dictionary Keys

Update dictionary keys to maintain PascalCase throughout:

Old:
```python
self.AppConfig[Key] = Value
```

This is already using PascalCase, so no change needed. Verify all other dictionary keys.

### 5. Code Snippet for ConfigManager Class Update

Here are the key changes required for the `ConfigManager` class:

```python
def _LoadAppConfigFromDB(self) -> None:
    """Load application configuration from database."""
    # Get all app settings
    Settings = self.DB.ExecuteQuery(
        "SELECT Key, Value, ValueType FROM AppSettings"
    )
    
    # Clear existing app config
    self.AppConfig = {}
    
    # Convert settings to appropriate types and add to AppConfig
    for Key, Value, ValueType in Settings:
        if ValueType == "int":
            self.AppConfig[Key] = int(Value)
        elif ValueType == "float":
            self.AppConfig[Key] = float(Value)
        elif ValueType == "bool":
            self.AppConfig[Key] = Value.lower() in ("true", "1", "yes")
        elif ValueType == "json":
            self.AppConfig[Key] = json.loads(Value)
        else:
            self.AppConfig[Key] = Value

def _LoadUserPreferencesFromDB(self) -> None:
    """Load user preferences from database."""
    # Get all user preferences
    Preferences = self.DB.ExecuteQuery(
        "SELECT Key, Value, ValueType FROM UserPreferences"
    )
    
    # Clear existing preferences
    self.UserPreferences = {}
    
    # Convert preferences to appropriate types and add to UserPreferences
    for Key, Value, ValueType in Preferences:
        if ValueType == "int":
            self.UserPreferences[Key] = int(Value)
        elif ValueType == "float":
            self.UserPreferences[Key] = float(Value)
        elif ValueType == "bool":
            self.UserPreferences[Key] = Value.lower() in ("true", "1", "yes")
        elif ValueType == "json":
            self.UserPreferences[Key] = json.loads(Value)
        else:
            self.UserPreferences[Key] = Value

def _LoadModelConfigsFromDB(self) -> None:
    """Load model configurations from database."""
    # Get all model configurations
    ModelConfigs = self.DB.ExecuteQuery(
        """
        SELECT ModelName, ConfigName, Temperature, TopP, MaxTokens,
               FrequencyPenalty, PresencePenalty
        FROM ModelConfigs
        """
    )
    
    # Clear existing model configs
    self.ModelConfigs = {}
    
    # Group configurations by model
    for ModelName, ConfigName, Temperature, TopP, MaxTokens, FrequencyPenalty, PresencePenalty in ModelConfigs:
        # Create model entry if it doesn't exist
        if ModelName not in self.ModelConfigs:
            self.ModelConfigs[ModelName] = {}
        
        # Add configuration
        self.ModelConfigs[ModelName][ConfigName] = {
            'Temperature': Temperature,
            'TopP': TopP,
            'MaxTokens': MaxTokens,
            'FrequencyPenalty': FrequencyPenalty,
            'PresencePenalty': PresencePenalty
        }
```

### 6. Testing

After implementing these changes, thorough testing is required to ensure all functionality works correctly with the new database schema:

1. Test loading configuration from the database
2. Test saving configuration to the database
3. Test migrating from file to database
4. Test all get/set methods for the different configuration types
5. Test interaction with the ModelManager class

## Migration Strategy

To ensure a smooth transition, we recommend the following approach:

1. Make a backup of the existing code and database
2. Implement the changes to the ConfigManager class
3. Create a new test database with the PascalCase schema
4. Test the updated ConfigManager with the new database
5. Once verified, migrate the production database using the migration script
6. Deploy the updated code

## Additional Considerations

- Ensure any other classes that interact with the database are also updated to use the PascalCase schema
- Update any documentation that references the database schema
- Communicate the changes to the development team
- Consider adding a version check to handle potential version mismatches between code and database

## Conclusion

By updating the ConfigManager class to work with the PascalCase database schema, we maintain consistency throughout the codebase and adhere to the AIDEV-PascalCase-1.2 standard. This change will improve code readability and maintainability while ensuring the unique visual signature of the project is preserved at all levels.

================
File: docs/Notes/Database Migration to PascalCase Standard.md
================
# Database Migration to PascalCase Standard

## Overview

As part of our commitment to the AIDEV-PascalCase-1.2 standard, we've updated our database schema to use PascalCase for all table and column names. This document explains why this change was made and provides instructions for migrating existing databases to the new standard.

## Why PascalCase for Database Schema?

The AIDEV-PascalCase standard specifies that PascalCase should be used for naming conventions across the entire codebase, including:

- Classes
- Methods
- Functions
- Variables
- Database elements (tables, columns, etc.)

By using PascalCase for all database elements, we maintain a consistent visual fingerprint throughout the codebase. This consistency:

1. Improves code readability
2. Eliminates the need for mental translation between snake_case and PascalCase
3. Strengthens the distinctive signature of the project
4. Makes it easier to identify and correct naming inconsistencies

## Key Changes

The following changes have been made to standardize the database schema:

1. All table names now use PascalCase (e.g., `model_configs`  `ModelConfigs`)
2. All column names now use PascalCase (e.g., `model_name`  `ModelName`)
3. Special terms are properly capitalized (e.g., `api_key`  `APIKey`, `db_connection`  `DBConnection`)
4. Database filename uses PascalCase (`OllamaModelEditor.db` instead of `ollama_model_editor.db`)
5. Related file paths also use PascalCase for consistency

## Migration Process

### Automatic Migration

We provide a migration script that will automatically convert your existing database to the new PascalCase standard:

```bash
python scripts/MigrateDBToPascalCase.py --db /path/to/your/database.db --backup
```

The `--backup` flag will create a backup of your database before migration, which is strongly recommended.

### Migration Process Details

The migration script will:

1. Create a backup of your database (if the `--backup` flag is used)
2. Analyze all tables and columns in the database
3. Create temporary tables with PascalCase names and column definitions
4. Copy data from the original tables to the temporary tables
5. Drop the original tables
6. Rename the temporary tables to their final PascalCase names

### Manual Migration

If you prefer to perform the migration manually or if the automatic migration fails, you can use the SQL schema file `Core/DatabaseSchema.sql` to create a new database with the PascalCase standard, and then manually copy your data:

```bash
# Create a new database with the PascalCase schema
sqlite3 OllamaModelEditor_new.db < Core/DatabaseSchema.sql

# Then use SQLite tools to export and import your data
```

## Troubleshooting

If you encounter any issues during migration:

1. Check the logs for specific error messages
2. Restore from the backup if available
3. Try using the `--force` flag with the migration script to continue despite non-critical errors
4. If all else fails, create a new database using the schema file and manually copy your data

## Verifying Migration Success

After migration, you can verify that the database structure has been properly updated:

```bash
sqlite3 OllamaModelEditor.db ".schema"
```

All table and column names should now use PascalCase, with special terms like "API", "DB", etc. properly capitalized.

## Moving Forward

From this point forward, all database operations will use the PascalCase naming convention. The `DBManager` class has been updated to work with the new schema, so all database operations should continue to work seamlessly after migration.

## Support

If you encounter any issues with the migration process or the new database schema, please open an issue on the project repository or contact the project maintainer at Herb@BowersWorld.com.

================
File: docs/Notes/implementation-plan.md
================
# OllamaModelEditor UI and Feature Implementation Plan

Based on our brainstorming and the original design, here's a comprehensive plan to enhance the OllamaModelEditor application.

## 1. UI Improvements

### Menu and Tab Contrast
- Apply stylesheet to better differentiate the menu bar from tab controls
- Add subtle shadows or borders to create visual hierarchy
- Implement consistent padding and margins for cleaner separation

### Sidebar Behavior
- Fix the sidebar toggle to properly hide/show the sidebar
- Add proper resize handles with visible feedback
- Ensure the sidebar doesn't block the main content when toggled

### Parameter Controls
- Enhance sliders with better visual feedback
- Add parameter guidance information
- Implement preset system with quick-select options
- Add more advanced parameters from the original design

### Overall Styling
- Apply consistent dark theme with proper contrast
- Add visual distinction between interactive and static elements
- Ensure proper spacing between UI elements
- Add visual feedback for interactive elements (hover, click, etc.)

## 2. New Features to Implement

### Parameter Presets
- Pre-defined parameter combinations optimized for different use cases
- User-defined custom presets with save/load functionality
- Preset comparison tool

### Detailed Analysis
- Token-by-token analysis of generated content
- Performance metrics and visualization
- Parameter impact analysis

### Configuration Management
- Export/import parameter configurations
- Version tracking for configurations
- Configuration comparison tools

### Documentation and Help System
- Integrated documentation browser
- Context-sensitive help
- Parameter reference guide with explanations
- Interactive tutorials

### Benchmarking Enhancements
- More detailed metrics
- Visualization of benchmark results
- Configuration comparison
- Export benchmark results

## 3. Immediate Action Items

1. **Fix Sidebar Behavior**
   - Update the dock widget implementation
   - Add proper controls for hiding/showing

2. **Enhance Parameter Controls**
   - Add parameter guidance section
   - Implement preset selector
   - Add visual improvements to sliders

3. **Apply Styling Fixes**
   - Implement consistent stylesheet
   - Fix menu/tab contrast issues
   - Add proper spacing and margins

4. **Add Additional Parameters**
   - Include frequency penalty and presence penalty
   - Add context window settings
   - Include stop sequence configuration

## 4. Technical Implementation Notes

### UI Components
- Use QDockWidget for properly dockable sidebars
- Use QSplitter for resizable panels
- Apply stylesheet consistently across all elements
- Set objectNames for all major components

### Data Flow
- Maintain clear separation between UI and data objects
- Implement proper update mechanisms for parameter changes
- Use signals/slots for UI component communication

### Performance Considerations
- Lazy-load complex UI elements
- Implement background processing for intensive operations
- Add progress indicators for long-running tasks

### Error Handling
- Add robust error handling for API interactions
- Provide clear user feedback for errors
- Implement recovery mechanisms

## 5. Testing Plan

- Test UI on different screen sizes
- Verify all controls function as expected
- Test with both keyboard and mouse navigation
- Verify performance with large models
- Test error scenarios and recovery

================
File: docs/Notes/OllamaModelEditor - Database Integration Guide.md
================
# OllamaModelEditor - Database Integration Guide

## Overview

This guide will help you implement the SQLite database integration in the OllamaModelEditor project. The database will centralize data storage, eliminate hard-coded values, and provide a foundation for advanced features like history tracking and analytics.

## Implementation Steps

### 1. Add the DBManager Class

1. Create a new file `Core/DBManager.py` with the provided implementation.
2. This class handles all database operations and provides a clean interface for the rest of the application.
3. It includes automatic schema creation, data initialization, and comprehensive methods for working with the database.

### 2. Update Core Components

1. Update `Core/ConfigManager.py` to work with the database:
   - Add database support in the constructor
   - Modify methods to read/write from the database when available
   - Add migration functionality
   - Keep file-based configuration as a fallback

2. Update `Core/ModelManager.py` to leverage the database:
   - Add database integration for model configurations
   - Store generation history in the database
   - Save benchmark results
   - Implement user-defined presets

3. Update `Main.py` to initialize the database:
   - Add command-line arguments for database path
   - Create the database manager
   - Pass it to ConfigManager
   - Add migration option

### 3. Create Migration Script

1. Add `scripts/MigrateToDatabase.py` to transfer existing configuration to the database
2. This script can be run separately or from within the application
3. Ensures a smooth transition from file-based to database storage

## Testing the Implementation

### Running Migration

```bash
# Migrate existing configuration to database (interactive)
python scripts/MigrateToDatabase.py

# Specify source configuration and database location
python scripts/MigrateToDatabase.py --config config.yaml --db ollamaModelEditor.db
```

### Running With Database

```bash
# Run with database
python Main.py --db ollamaModelEditor.db

# Run with migration from file to database
python Main.py --migrate
```

### Database Verification

1. You can inspect the database using a SQLite browser tool like DB Browser for SQLite
2. Check that tables are created correctly
3. Verify data is stored as expected

## Benefits of Database Integration

The database integration provides several significant advantages:

1. **Centralized Data Storage**: All application data in one place with proper schema
2. **Improved Data Management**: Better organization and maintenance of application data
3. **Reduced Code Complexity**: No need to manage file I/O and format conversions
4. **Better Performance**: Faster data access, especially with indexed queries
5. **Enhanced Features**: Easier to implement history tracking, model comparisons, and user preferences
6. **Scalability**: Accommodates future growth and more complex data relationships
7. **Simplified Backup**: Single file to back up and restore

## Backward Compatibility

The implementation maintains backward compatibility with the file-based approach:

1. If database is not available, falls back to file-based configuration
2. Configuration can be exported from database to files
3. Command-line arguments allow choosing between database and file storage

## Future Enhancements

Once the database integration is complete, you can implement several advanced features:

1. **Generation History Viewer**: Display and filter past generations
2. **Benchmark Analytics**: Visualize performance trends over time
3. **Parameter Impact Analysis**: See how parameter changes affect output
4. **User Preset Management**: Save, share, and apply custom parameter presets
5. **Multi-Model Comparison**: Compare performance across different models
6. **Internationalization**: Support multiple languages with UI strings from database

## Tips for Implementation

1. **Gradual Integration**: Start with ConfigManager, then ModelManager
2. **Test Each Change**: Verify each component works with the database before moving on
3. **Error Handling**: Ensure robust fallbacks if database operations fail
4. **Migration Tools**: Create tools to help users transition to the database
5. **Documentation**: Update documentation to explain database features

## Conclusion

The database integration transforms OllamaModelEditor from a configuration tool to a comprehensive model management platform. By centralizing data and providing a foundation for advanced features, it significantly enhances the application's capabilities while making the code more maintainable and extensible.

================
File: docs/Notes/OllamaModelEditor UI and Feature Implementation Plan.md
================
# OllamaModelEditor UI and Feature Implementation Plan

Based on our brainstorming and the original design, here's a comprehensive plan to enhance the OllamaModelEditor application.

## 1. UI Improvements

### Menu and Tab Contrast
- Apply stylesheet to better differentiate the menu bar from tab controls
- Add subtle shadows or borders to create visual hierarchy
- Implement consistent padding and margins for cleaner separation

### Sidebar Behavior
- Fix the sidebar toggle to properly hide/show the sidebar
- Add proper resize handles with visible feedback
- Ensure the sidebar doesn't block the main content when toggled

### Parameter Controls
- Enhance sliders with better visual feedback
- Add parameter guidance information
- Implement preset system with quick-select options
- Add more advanced parameters from the original design

### Overall Styling
- Apply consistent dark theme with proper contrast
- Add visual distinction between interactive and static elements
- Ensure proper spacing between UI elements
- Add visual feedback for interactive elements (hover, click, etc.)

## 2. New Features to Implement

### Parameter Presets
- Pre-defined parameter combinations optimized for different use cases
- User-defined custom presets with save/load functionality
- Preset comparison tool

### Detailed Analysis
- Token-by-token analysis of generated content
- Performance metrics and visualization
- Parameter impact analysis

### Configuration Management
- Export/import parameter configurations
- Version tracking for configurations
- Configuration comparison tools

### Documentation and Help System
- Integrated documentation browser
- Context-sensitive help
- Parameter reference guide with explanations
- Interactive tutorials

### Benchmarking Enhancements
- More detailed metrics
- Visualization of benchmark results
- Configuration comparison
- Export benchmark results

## 3. Immediate Action Items

1. **Fix Sidebar Behavior**
   - Update the dock widget implementation
   - Add proper controls for hiding/showing

2. **Enhance Parameter Controls**
   - Add parameter guidance section
   - Implement preset selector
   - Add visual improvements to sliders

3. **Apply Styling Fixes**
   - Implement consistent stylesheet
   - Fix menu/tab contrast issues
   - Add proper spacing and margins

4. **Add Additional Parameters**
   - Include frequency penalty and presence penalty
   - Add context window settings
   - Include stop sequence configuration

## 4. Technical Implementation Notes

### UI Components
- Use QDockWidget for properly dockable sidebars
- Use QSplitter for resizable panels
- Apply stylesheet consistently across all elements
- Set objectNames for all major components

### Data Flow
- Maintain clear separation between UI and data objects
- Implement proper update mechanisms for parameter changes
- Use signals/slots for UI component communication

### Performance Considerations
- Lazy-load complex UI elements
- Implement background processing for intensive operations
- Add progress indicators for long-running tasks

### Error Handling
- Add robust error handling for API interactions
- Provide clear user feedback for errors
- Implement recovery mechanisms

## 5. Testing Plan

- Test UI on different screen sizes
- Verify all controls function as expected
- Test with both keyboard and mouse navigation
- Verify performance with large models
- Test error scenarios and recovery

================
File: docs/ProjectStructure.txt
================
OllamaModelEditor/
 .github/
    workflows/
       ci.yml                    # Continuous Integration workflow
       release.yml               # Release automation
    ISSUE_TEMPLATE/
       bug_report.md
       feature_request.md
    PULL_REQUEST_TEMPLATE.md
 .gitignore
 Core/
    __init__.py
    ConfigManager.py              # Configuration management
    ModelManager.py               # Ollama model operations
    ParameterManager.py           # Model parameter handling
    BenchmarkManager.py           # Performance testing
    LoggingUtils.py               # Centralized logging
    README.md                     # Core components documentation
 GUI/
    __init__.py
    Assets/
       icons/
       themes/
       fonts/
    Components/
       __init__.py
       ModelSelector.py          # Model selection widget
       ParameterEditor.py        # Parameter editing interface
       BenchmarkView.py          # Performance comparison view
       ConfigExporter.py         # Config export functionality
    Dialogs/
       __init__.py
       SettingsDialog.py         # Application settings
       AboutDialog.py            # About information
    Windows/
       __init__.py
       MainWindow.py             # Main application window
       SplashScreen.py           # Application splash screen
    ThemeManager.py               # Application theming
 Tests/
    __init__.py
    UnitTests/
       __init__.py
       TestConfigManager.py
       TestModelManager.py
       TestParameterManager.py
    IntegrationTests/
       __init__.py
       TestModelWorkflow.py
    UITests/
        __init__.py
        TestMainWindow.py
 Utils/
    __init__.py
    OllamaUtils.py                # Ollama-specific utilities
    ValidationUtils.py            # Input validation helpers
    FileUtils.py                  # File operations helpers
 Features/
    __init__.py
    ChatIntegration.py            # Chat functionality
    SecurityMonitor.py            # Security monitoring
    TextToSpeech.py               # TTL functionality
    VoiceRecognition.py           # Voice recognition
    RAGSupport.py                 # Retrieval Augmented Generation
 docs/
    QuickStartGuide.md            # Getting started guide
    parameters.md                 # Parameter reference
    advanced_usage.md             # Advanced usage guide
    screenshots/                  # Application screenshots
 scripts/
    Setup.sh                      # Environment setup script
    Setup.bat                     # Windows setup script
    UpdateDependencies.py         # Dependency update utility
 .env.example                      # Example environment variables
 LICENSE                           # MIT License
 Main.py                           # Application entry point
 README.md                         # Project README
 requirements.txt                  # Python dependencies
 pyproject.toml                    # Project metadata

================
File: GUI/Components/__init__.py
================
# File: __init__.py
# Path: OllamaModelEditor/GUI/Components/__init__.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Package initialization for GUI components

# This file is intentionally left empty to mark this directory as a Python package

================
File: GUI/Components/BenchmarkView.py
================
# File: BenchmarkView.py
# Path: OllamaModelEditor/GUI/Components/BenchmarkView.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Benchmarking component for the OllamaModelEditor application

from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QTextEdit, QPushButton, QHBoxLayout

class BenchmarkView(QWidget):
    """Widget for benchmarking models."""
    
    def __init__(self, ModelManager, Config):
        """
        Initialize the benchmark view.
        
        Args:
            ModelManager: Model manager instance
            Config: Configuration manager instance
        """
        super().__init__()
        
        # Store references
        self.ModelManager = ModelManager
        self.Config = Config
        
        # Set up UI
        self._SetupUI()
    
    def _SetupUI(self):
        """Set up the user interface."""
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add header label
        HeaderLabel = QLabel("Model Benchmark:")
        Layout.addWidget(HeaderLabel)
        
        # Add prompt input
        PromptLabel = QLabel("Enter benchmark prompts (one per line):")
        Layout.addWidget(PromptLabel)
        
        self.PromptsText = QTextEdit()
        self.PromptsText.setPlaceholderText("Enter benchmark prompts here...")
        Layout.addWidget(self.PromptsText)
        
        # Add buttons
        ButtonLayout = QHBoxLayout()
        
        self.RunButton = QPushButton("Run Benchmark")
        self.RunButton.clicked.connect(self._OnRunBenchmark)
        ButtonLayout.addWidget(self.RunButton)
        
        self.SaveButton = QPushButton("Save Results")
        self.SaveButton.clicked.connect(self._OnSaveResults)
        ButtonLayout.addWidget(self.SaveButton)
        
        Layout.addLayout(ButtonLayout)
        
        # Add results display
        ResultsLabel = QLabel("Benchmark Results:")
        Layout.addWidget(ResultsLabel)
        
        self.ResultsText = QTextEdit()
        self.ResultsText.setReadOnly(True)
        Layout.addWidget(self.ResultsText)
    
    def _OnRunBenchmark(self):
        """Handle run benchmark button click."""
        # Get prompts
        PromptText = self.PromptsText.toPlainText()
        Prompts = [p.strip() for p in PromptText.split('\n') if p.strip()]
        
        if not Prompts:
            self.ResultsText.setText("Please enter at least one prompt.")
            return
        
        # Get current model
        CurrentModel = self.ModelManager.GetCurrentModel()
        if not CurrentModel:
            self.ResultsText.setText("Please select a model first.")
            return
        
        ModelName = CurrentModel.get('name')
        
        # Run benchmark
        self.ResultsText.setText(f"Running benchmark for {ModelName}...\n")
        
        # This would be replaced with actual benchmark implementation
        self.ResultsText.append("Benchmark functionality not yet implemented.")
        self.ResultsText.append("This is a placeholder for the actual benchmark.")
    
    def _OnSaveResults(self):
        """Handle save results button click."""
        # Implementation would go here
        self.ResultsText.append("\nSaving results functionality not yet implemented.")

================
File: GUI/Components/ModelSelector.py
================
# File: ModelSelector.py
# Path: OllamaModelEditor/GUI/Components/ModelSelector.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Model selection component for the OllamaModelEditor application

from PySide6.QtWidgets import QWidget, QVBoxLayout, QListWidget, QLabel
from PySide6.QtCore import Signal, Slot

class ModelSelector(QWidget):
    """Widget for selecting Ollama models."""
    
    # Signal emitted when a model is selected
    ModelSelected = Signal(str)
    
    def __init__(self, ModelManager, Config):
        """
        Initialize the model selector.
        
        Args:
            ModelManager: Model manager instance
            Config: Configuration manager instance
        """
        super().__init__()
        
        # Store references
        self.ModelManager = ModelManager
        self.Config = Config
        
        # Set up UI
        self._SetupUI()
    
    def _SetupUI(self):
        """Set up the user interface."""
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add header label
        HeaderLabel = QLabel("Available Models:")
        Layout.addWidget(HeaderLabel)
        
        # Add list widget
        self.ModelList = QListWidget()
        self.ModelList.currentTextChanged.connect(self._OnModelSelected)
        Layout.addWidget(self.ModelList)
        
        # Load models
        self._LoadModels()
    
    def _LoadModels(self):
        """Load available models."""
        # Clear list
        self.ModelList.clear()
        
        # Get available models
        Models = self.ModelManager.GetAvailableModels()
        
        # Add to list
        for Model in Models:
            self.ModelList.addItem(Model.get('name', 'Unknown'))
    
    @Slot(str)
    def _OnModelSelected(self, ModelName):
        """
        Handle model selection.
        
        Args:
            ModelName: Selected model name
        """
        if ModelName:
            # Emit signal
            self.ModelSelected.emit(ModelName)

================
File: GUI/Components/ParameterEditor.py
================
# File: ParameterEditor.py
# Path: OllamaModelEditor/GUI/Components/ParameterEditor.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Parameter editing component for the OllamaModelEditor application

from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QGridLayout, QSlider, QSpinBox, QDoubleSpinBox
from PySide6.QtCore import Qt

class ParameterEditor(QWidget):
    """Widget for editing model parameters."""
    
    def __init__(self, ModelManager, Config):
        """
        Initialize the parameter editor.
        
        Args:
            ModelManager: Model manager instance
            Config: Configuration manager instance
        """
        super().__init__()
        
        # Store references
        self.ModelManager = ModelManager
        self.Config = Config
        self.CurrentModel = None
        
        # Set up UI
        self._SetupUI()
    
    def _SetupUI(self):
        """Set up the user interface."""
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add header label
        HeaderLabel = QLabel("Model Parameters:")
        Layout.addWidget(HeaderLabel)
        
        # Create parameters grid
        self.ParametersGrid = QGridLayout()
        Layout.addLayout(self.ParametersGrid)
        
        # Add placeholder message
        self.PlaceholderLabel = QLabel("Select a model to edit parameters")
        self.PlaceholderLabel.setAlignment(Qt.AlignCenter)
        Layout.addWidget(self.PlaceholderLabel)
        
        # Add stretch to bottom
        Layout.addStretch()
    
    def LoadModel(self, ModelName):
        """
        Load a model for editing.
        
        Args:
            ModelName: Name of the model to load
        """
        # Store current model
        self.CurrentModel = ModelName
        
        # Hide placeholder
        self.PlaceholderLabel.setVisible(False)
        
        # Clear parameters grid
        while self.ParametersGrid.count():
            Item = self.ParametersGrid.takeAt(0)
            if Item.widget():
                Item.widget().deleteLater()
        
        # Get model parameters
        ModelParams = self.Config.GetModelConfig(ModelName)
        
        # Add parameter controls
        self._AddParameterControl("Temperature", ModelParams.get('Temperature', 0.7), 0.0, 2.0, 0.1)
        self._AddParameterControl("TopP", ModelParams.get('TopP', 0.9), 0.0, 1.0, 0.01)
        self._AddParameterControl("MaxTokens", ModelParams.get('MaxTokens', 2048), 1, 32000, 1, True)
    
    def _AddParameterControl(self, Name, Value, Min, Max, Step, IsInteger=False):
        """
        Add a parameter control to the grid.
        
        Args:
            Name: Parameter name
            Value: Current value
            Min: Minimum value
            Max: Maximum value
            Step: Step size
            IsInteger: Whether the parameter is an integer
        """
        # Determine next row
        Row = self.ParametersGrid.rowCount()
        
        # Add label
        Label = QLabel(f"{Name}:")
        self.ParametersGrid.addWidget(Label, Row, 0)
        
        # Add slider
        Slider = QSlider(Qt.Horizontal)
        if IsInteger:
            Slider.setMinimum(int(Min))
            Slider.setMaximum(int(Max))
            Slider.setValue(int(Value))
        else:
            Slider.setMinimum(int(Min * 100))
            Slider.setMaximum(int(Max * 100))
            Slider.setValue(int(Value * 100))
        self.ParametersGrid.addWidget(Slider, Row, 1)
        
        # Add spin box
        if IsInteger:
            SpinBox = QSpinBox()
            SpinBox.setMinimum(int(Min))
            SpinBox.setMaximum(int(Max))
            SpinBox.setValue(int(Value))
        else:
            SpinBox = QDoubleSpinBox()
            SpinBox.setMinimum(Min)
            SpinBox.setMaximum(Max)
            SpinBox.setSingleStep(Step)
            SpinBox.setValue(Value)
        self.ParametersGrid.addWidget(SpinBox, Row, 2)
        
        # Connect signals
        if IsInteger:
            Slider.valueChanged.connect(SpinBox.setValue)
            SpinBox.valueChanged.connect(Slider.setValue)
        else:
            Slider.valueChanged.connect(lambda v: SpinBox.setValue(v / 100))
            SpinBox.valueChanged.connect(lambda v: Slider.setValue(int(v * 100)))

================
File: GUI/Windows/MainWindow.py
================
# File: MainWindow.py
# Path: OllamaModelEditor/GUI/Windows/MainWindow.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-12
# Description: Main window for the OllamaModelEditor application

import sys
from pathlib import Path
import logging
from typing import Optional, Dict, Any

# Import PySide6 components
from PySide6.QtWidgets import (
    QMainWindow, QMenu, QToolBar, QStatusBar, 
    QVBoxLayout, QHBoxLayout, QWidget, QTabWidget,
    QComboBox, QLabel, QPushButton, QMessageBox,
    QSplitter, QDockWidget, QApplication, QFrame
)
from PySide6.QtCore import Qt, QSize, Slot, Signal, QTimer
from PySide6.QtGui import QIcon, QFont, QKeySequence, QAction  # QAction moved to QtGui

# Import project modules
from Core.ConfigManager import ConfigManager
from Core.ModelManager import ModelManager
from GUI.Components.ModelSelector import ModelSelector
from GUI.Components.ParameterEditor import ParameterEditor
from GUI.Components.BenchmarkView import BenchmarkView

class MainWindow(QMainWindow):
    """Main application window for OllamaModelEditor."""
    
    def __init__(self, Config: ConfigManager):
        """
        Initialize the main window.
        
        Args:
            Config: Configuration manager instance
        """
        super().__init__()
        
        # Initialize logging
        self.Logger = logging.getLogger('OllamaModelEditor.MainWindow')
        
        # Store configuration
        self.Config = Config
        
        # Create model manager
        self.ModelManager = ModelManager(Config)
        
        # Set up UI
        self._SetupWindow()
        self._CreateMenus()
        self._CreateToolbars()
        self._CreateStatusBar()
        self._CreateCentralWidget()
        self._CreateDockWidgets()
        
        # Load user preferences
        self._LoadPreferences()
        
        # Connect signals and slots
        self._ConnectSignals()
        
        # Load models
        self._LoadModels()
    
    def _SetupWindow(self) -> None:
        """Set up the main window properties."""
        # Set window title and icon
        self.setWindowTitle("Ollama Model Editor")
        # self.setWindowIcon(QIcon("GUI/Assets/icons/app_icon.png"))
        
        # Set window geometry
        WindowWidth = self.Config.GetUserPreference('WindowWidth', 1200)
        WindowHeight = self.Config.GetUserPreference('WindowHeight', 800)
        self.resize(WindowWidth, WindowHeight)
        
        # Get the screen size
        ScreenSize = self.screen().size()
        
        # Center window on screen
        self.move(
            (ScreenSize.width() - WindowWidth) // 2,
            (ScreenSize.height() - WindowHeight) // 2
        )
        
        # Apply application-wide stylesheet for better visual hierarchy
        self._ApplyAppStylesheet()
    
    def _ApplyAppStylesheet(self) -> None:
        """Apply application-wide stylesheet."""
        # Application-wide stylesheet for consistent dark theme and better visual separation
        AppStyleSheet = """
            /* Main application styling */
            QMainWindow, QDialog {
                background-color: #232323;
                color: #E0E0E0;
            }
            
            /* Menu and toolbar styling for better contrast */
            QMenuBar {
                background-color: #1A1A1A;
                color: #FFFFFF;
                border-bottom: 1px solid #3D3D3D;
                min-height: 28px;
                padding: 2px;
            }
            
            QMenuBar::item {
                background-color: transparent;
                padding: 4px 8px;
                margin: 2px 1px;
            }
            
            QMenuBar::item:selected {
                background-color: #3D3D3D;
                border-radius: 3px;
            }
            
            QToolBar {
                background-color: #2A2A2A;
                border-bottom: 1px solid #3D3D3D;
                padding: 2px;
                spacing: 2px;
            }
            
            /* Tab widget styling for better separation from menu */
            QTabWidget::pane {
                border-top: 1px solid #3D3D3D;
                background-color: #232323;
                top: -1px;
            }
            
            QTabBar::tab {
                background-color: #333333;
                color: #E0E0E0;
                padding: 8px 12px;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border: 1px solid #3D3D3D;
                border-bottom: none;
                min-width: 120px;
            }
            
            QTabBar::tab:selected {
                background-color: #404040;
                border-bottom-color: #404040;
            }
            
            QTabBar::tab:hover:!selected {
                background-color: #383838;
            }
            
            /* Dock widget styling */
            QDockWidget {
                titlebar-close-icon: url(close.png);
                titlebar-normal-icon: url(undock.png);
            }
            
            QDockWidget::title {
                background-color: #2A2A2A;
                padding-left: 10px;
                padding-top: 4px;
                border-bottom: 1px solid #3D3D3D;
            }
            
            /* Control styling */
            QSlider::groove:horizontal {
                border: 1px solid #5A5A5A;
                height: 8px;
                background: #3A3A3A;
                margin: 2px 0;
                border-radius: 4px;
            }
            
            QSlider::handle:horizontal {
                background: #0078D7;
                border: 1px solid #0078D7;
                width: 18px;
                margin: -2px 0;
                border-radius: 9px;
            }
            
            QSlider::handle:horizontal:hover {
                background: #1C86E0;
            }
            
            QComboBox {
                background-color: #3A3A3A;
                border: 1px solid #5A5A5A;
                border-radius: 3px;
                padding: 2px 8px;
                min-height: 24px;
            }
            
            QComboBox::drop-down {
                subcontrol-origin: padding;
                subcontrol-position: right;
                width: 20px;
                border-left: 1px solid #5A5A5A;
            }
            
            QPushButton {
                background-color: #3A3A3A;
                border: 1px solid #5A5A5A;
                border-radius: 3px;
                padding: 5px 15px;
                color: #E0E0E0;
                min-height: 24px;
            }
            
            QPushButton:hover {
                background-color: #4A4A4A;
            }
            
            QPushButton:pressed {
                background-color: #2A2A2A;
            }
            
            /* List and tree views */
            QListWidget, QTreeWidget {
                background-color: #2A2A2A;
                border: 1px solid #3D3D3D;
                alternate-background-color: #323232;
            }
            
            QListWidget::item, QTreeWidget::item {
                padding: 4px 2px;
            }
            
            QListWidget::item:selected, QTreeWidget::item:selected {
                background-color: #0078D7;
                color: white;
            }
            
            QListWidget::item:hover, QTreeWidget::item:hover {
                background-color: #383838;
            }
            
            /* Other elements */
            QLineEdit, QTextEdit, QSpinBox, QDoubleSpinBox {
                background-color: #2A2A2A;
                border: 1px solid #3D3D3D;
                border-radius: 3px;
                padding: 3px;
            }
            
            QStatusBar {
                background-color: #2A2A2A;
                color: #B0B0B0;
                border-top: 1px solid #3D3D3D;
            }
        """
        
        # Apply the stylesheet to the application
        app = QApplication.instance()
        if app:
            app.setStyleSheet(AppStyleSheet)
    
    def _CreateMenus(self) -> None:
        """Create the application menu bar."""
        self.MenuBar = self.menuBar()
        
        # File menu
        self.FileMenu = self.MenuBar.addMenu("&File")
        
        self.NewAction = QAction("&New Configuration", self)
        self.NewAction.setShortcut(QKeySequence.New)
        self.NewAction.triggered.connect(self._OnNewConfig)
        self.FileMenu.addAction(self.NewAction)
        
        self.OpenAction = QAction("&Open Configuration...", self)
        self.OpenAction.setShortcut(QKeySequence.Open)
        self.OpenAction.triggered.connect(self._OnOpenConfig)
        self.FileMenu.addAction(self.OpenAction)
        
        self.SaveAction = QAction("&Save Configuration", self)
        self.SaveAction.setShortcut(QKeySequence.Save)
        self.SaveAction.triggered.connect(self._OnSaveConfig)
        self.FileMenu.addAction(self.SaveAction)
        
        self.SaveAsAction = QAction("Save Configuration &As...", self)
        self.SaveAsAction.setShortcut(QKeySequence.SaveAs)
        self.SaveAsAction.triggered.connect(self._OnSaveConfigAs)
        self.FileMenu.addAction(self.SaveAsAction)
        
        self.FileMenu.addSeparator()
        
        self.ExitAction = QAction("E&xit", self)
        self.ExitAction.setShortcut(QKeySequence.Quit)
        self.ExitAction.triggered.connect(self.close)
        self.FileMenu.addAction(self.ExitAction)
        
        # Edit menu
        self.EditMenu = self.MenuBar.addMenu("&Edit")
        
        self.PreferencesAction = QAction("&Preferences...", self)
        self.PreferencesAction.triggered.connect(self._OnPreferences)
        self.EditMenu.addAction(self.PreferencesAction)
        
        # View menu
        self.ViewMenu = self.MenuBar.addMenu("&View")
        
        # Tools menu
        self.ToolsMenu = self.MenuBar.addMenu("&Tools")
        
        self.BenchmarkAction = QAction("&Benchmark Model...", self)
        self.BenchmarkAction.triggered.connect(self._OnBenchmark)
        self.ToolsMenu.addAction(self.BenchmarkAction)
        
        self.ExportAction = QAction("&Export Model Definition...", self)
        self.ExportAction.triggered.connect(self._OnExportModel)
        self.ToolsMenu.addAction(self.ExportAction)
        
        # Help menu
        self.HelpMenu = self.MenuBar.addMenu("&Help")
        
        self.DocumentationAction = QAction("&Documentation", self)
        self.DocumentationAction.triggered.connect(self._OnDocumentation)
        self.HelpMenu.addAction(self.DocumentationAction)
        
        self.HelpMenu.addSeparator()
        
        self.AboutAction = QAction("&About", self)
        self.AboutAction.triggered.connect(self._OnAbout)
        self.HelpMenu.addAction(self.AboutAction)
    
    def _CreateToolbars(self) -> None:
        """Create the application toolbars."""
        # Main toolbar
        self.MainToolbar = QToolBar("Main Toolbar")
        self.MainToolbar.setObjectName("MainToolbar")  # Add objectName to fix warning
        self.MainToolbar.setMovable(False)
        self.MainToolbar.setIconSize(QSize(24, 24))
        self.addToolBar(self.MainToolbar)
        
        # Add actions to toolbar
        self.MainToolbar.addAction(self.NewAction)
        self.MainToolbar.addAction(self.OpenAction)
        self.MainToolbar.addAction(self.SaveAction)
        self.MainToolbar.addSeparator()
        
        # Add model selector to toolbar
        self.ModelSelectorLabel = QLabel("Model:")
        self.MainToolbar.addWidget(self.ModelSelectorLabel)
        
        self.ModelSelectorCombo = QComboBox()
        self.ModelSelectorCombo.setMinimumWidth(200)
        self.MainToolbar.addWidget(self.ModelSelectorCombo)
        
        self.RefreshModelsButton = QPushButton("Refresh")
        self.RefreshModelsButton.clicked.connect(self._OnRefreshModels)
        self.MainToolbar.addWidget(self.RefreshModelsButton)
    
    def _CreateStatusBar(self) -> None:
        """Create the application status bar."""
        self.StatusBar = QStatusBar()
        self.setStatusBar(self.StatusBar)
        
        # Add status labels
        self.ModelStatusLabel = QLabel("No model selected")
        self.StatusBar.addWidget(self.ModelStatusLabel)
        
        self.APIStatusLabel = QLabel("API: Not connected")
        self.StatusBar.addPermanentWidget(self.APIStatusLabel)
    
    def _CreateCentralWidget(self) -> None:
        """Create the central widget."""
        # Create central widget
        self.CentralWidget = QWidget()
        self.setCentralWidget(self.CentralWidget)
        
        # Main layout
        self.MainLayout = QVBoxLayout()
        self.CentralWidget.setLayout(self.MainLayout)
        
        # Create tab widget
        self.TabWidget = QTabWidget()
        self.MainLayout.addWidget(self.TabWidget)
        
        # Add parameter editor tab
        self.ParameterEditorWidget = ParameterEditor(self.ModelManager, self.Config)
        self.TabWidget.addTab(self.ParameterEditorWidget, "Parameter Editor")
        
        # Add benchmark tab
        self.BenchmarkWidget = BenchmarkView(self.ModelManager, self.Config)
        self.TabWidget.addTab(self.BenchmarkWidget, "Benchmark")
        
        # Add analysis tab if available
        try:
            from GUI.Components.AnalysisView import AnalysisView
            self.AnalysisWidget = AnalysisView(self.ModelManager, self.Config)
            self.TabWidget.addTab(self.AnalysisWidget, "Analysis")
        except ImportError:
            # Analysis view not available, skip
            pass
    
    def _CreateDockWidgets(self) -> None:
        """Create dock widgets."""
        # Model selector dock
        self.ModelSelectorDock = QDockWidget("Model Library", self)
        self.ModelSelectorDock.setObjectName("ModelLibraryDock")  # Add objectName to fix warning
        self.ModelSelectorDock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        
        # Create a container widget with layout for the dock
        DockContainer = QWidget()
        DockLayout = QVBoxLayout(DockContainer)
        DockLayout.setContentsMargins(0, 0, 0, 0)
        
        # Add header with label and toolbar
        HeaderLayout = QHBoxLayout()
        HeaderLayout.setSpacing(2)
        HeaderLabel = QLabel("Available Models:")
        HeaderLabel.setStyleSheet("font-weight: bold;")
        HeaderLayout.addWidget(HeaderLabel)
        
        # Add spacer to push toolbar to right
        HeaderLayout.addStretch()
        
        # Add refresh button to dock header
        RefreshButton = QPushButton("")
        RefreshButton.setToolTip("Refresh Models")
        RefreshButton.setMaximumWidth(24)
        RefreshButton.clicked.connect(self._OnRefreshModels)
        HeaderLayout.addWidget(RefreshButton)
        
        DockLayout.addLayout(HeaderLayout)
        
        # Create model selector widget
        self.ModelSelectorWidget = ModelSelector(self.ModelManager, self.Config)
        DockLayout.addWidget(self.ModelSelectorWidget)
        
        # Set dock widget content
        self.ModelSelectorDock.setWidget(DockContainer)
        
        # Add dock to main window
        self.addDockWidget(Qt.LeftDockWidgetArea, self.ModelSelectorDock)
        self.ViewMenu.addAction(self.ModelSelectorDock.toggleViewAction())
    
    def _LoadPreferences(self) -> None:
        """Load user preferences."""
        # Load window state if saved
        WindowState = self.Config.GetUserPreference('WindowState')
        WindowGeometry = self.Config.GetUserPreference('WindowGeometry')
        
        if WindowState:
            self.restoreState(WindowState)
        
        if WindowGeometry:
            self.restoreGeometry(WindowGeometry)
        
        # Apply theme
        Theme = self.Config.GetUserPreference('Theme', 'system')
        self._ApplyTheme(Theme)
    
    def _ApplyTheme(self, Theme: str) -> None:
        """
        Apply the selected theme.
        
        Args:
            Theme: Theme name ('light', 'dark', or 'system')
        """
        # Theme implementation would go here
        pass
    
    def _ConnectSignals(self) -> None:
        """Connect signals and slots."""
        # Connect model selector combo box
        self.ModelSelectorCombo.currentTextChanged.connect(self._OnModelSelected)
        
        # Connect model selector widget
        self.ModelSelectorWidget.ModelSelected.connect(self._OnModelSelectedFromWidget)
    
    def _LoadModels(self) -> None:
        """Load available models."""
        # Update status
        self.StatusBar.showMessage("Loading models...", 2000)
        
        # Get available models
        Models = self.ModelManager.GetAvailableModels()
        
        # Update model selector combo box
        self.ModelSelectorCombo.clear()
        for Model in Models:
            self.ModelSelectorCombo.addItem(Model.get('name', 'Unknown'))
        
        # Update status
        if Models:
            self.APIStatusLabel.setText("API: Connected")
            self.StatusBar.showMessage(f"Loaded {len(Models)} models", 3000)
        else:
            self.APIStatusLabel.setText("API: Error")
            self.StatusBar.showMessage("Failed to load models", 3000)
    
    @Slot()
    def _OnRefreshModels(self) -> None:
        """Handle refresh models button click."""
        self._LoadModels()
    
    @Slot(str)
    def _OnModelSelected(self, ModelName: str) -> None:
        """
        Handle model selection from combo box.
        
        Args:
            ModelName: Selected model name
        """
        if not ModelName:
            return
        
        # Set current model
        if self.ModelManager.SetCurrentModel(ModelName):
            self.ModelStatusLabel.setText(f"Model: {ModelName}")
            self.StatusBar.showMessage(f"Model {ModelName} selected", 3000)
            
            # Update parameter editor
            self.ParameterEditorWidget.LoadModel(ModelName)
        else:
            self.StatusBar.showMessage(f"Failed to select model {ModelName}", 3000)
    
    @Slot(str)
    def _OnModelSelectedFromWidget(self, ModelName: str) -> None:
        """
        Handle model selection from model selector widget.
        
        Args:
            ModelName: Selected model name
        """
        # Update combo box
        Index = self.ModelSelectorCombo.findText(ModelName)
        if Index >= 0:
            self.ModelSelectorCombo.setCurrentIndex(Index)
    
    @Slot()
    def _OnNewConfig(self) -> None:
        """Handle new configuration action."""
        # Check if current configuration should be saved
        # Implementation would go here
        
        # Create new configuration
        pass
    
    @Slot()
    def _OnOpenConfig(self) -> None:
        """Handle open configuration action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnSaveConfig(self) -> None:
        """Handle save configuration action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnSaveConfigAs(self) -> None:
        """Handle save configuration as action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnPreferences(self) -> None:
        """Handle preferences action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnBenchmark(self) -> None:
        """Handle benchmark action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnExportModel(self) -> None:
        """Handle export model action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnDocumentation(self) -> None:
        """Handle documentation action."""
        # Implementation would go here
        pass
    
    @Slot()
    def _OnAbout(self) -> None:
        """Handle about action."""
        AboutText = (
            "<h2>Ollama Model Editor</h2>"
            "<p>Version 1.0.0</p>"
            "<p>A powerful tool for customizing and optimizing Ollama AI models.</p>"
            "<p>This project is a collaboration between human developers and AI assistants.</p>"
            "<p>&copy; 2025 Herbert J. Bowers (Herb@BowersWorld.com)</p>"
        )
        
        QMessageBox.about(self, "About Ollama Model Editor", AboutText)
    
    def closeEvent(self, event) -> None:
        """
        Handle window close event.
        
        Save user preferences before closing.
        """
        # Save window state and geometry
        self.Config.SetUserPreference('WindowState', self.saveState())
        self.Config.SetUserPreference('WindowGeometry', self.saveGeometry())
        self.Config.SetUserPreference('WindowWidth', self.width())
        self.Config.SetUserPreference('WindowHeight', self.height())
        
        # Save configuration
        self.Config.SaveConfig()
        
        # Accept close event
        event.accept()

================
File: GUI/Windows/SplashScreen.py
================
# File: SplashScreen.py
# Path: OllamaModelEditor/GUI/Windows/SplashScreen.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-12
# Description: Splash screen for the OllamaModelEditor application

from PySide6.QtWidgets import QSplashScreen
from PySide6.QtCore import Qt, QTimer
from PySide6.QtGui import QPixmap, QFont, QColor, QPainter

class SplashScreen(QSplashScreen):
    """Splash screen displayed during application startup."""
    
    def __init__(self):
        """Initialize the splash screen."""
        # Create a pixmap for the splash screen
        self.BasePixmap = QPixmap(600, 400)
        self.BasePixmap.fill(Qt.white)
        
        # Initialize with the base pixmap
        super().__init__(self.BasePixmap)
        
        # Set window flags
        self.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint)
        
        # Initialize progress
        self.Progress = 0
        self.ProgressMax = 100
        
        # Draw initial content
        self._DrawContent()
        
        # Start progress timer
        self.ProgressTimer = QTimer(self)
        self.ProgressTimer.timeout.connect(self._UpdateProgress)
        self.ProgressTimer.start(50)
    
    def _DrawContent(self):
        """Draw splash screen content."""
        # Create a new pixmap based on the base pixmap for drawing
        CurrentPixmap = QPixmap(self.BasePixmap)
        
        # Create painter for the current pixmap
        Painter = QPainter(CurrentPixmap)
        
        # Draw application name
        Painter.setPen(QColor(40, 40, 40))
        TitleFont = QFont("Arial", 28, QFont.Bold)
        Painter.setFont(TitleFont)
        Painter.drawText(50, 100, "Ollama Model Editor")
        
        # Draw tagline
        TaglineFont = QFont("Arial", 14)
        Painter.setFont(TaglineFont)
        Painter.drawText(50, 140, "A powerful tool for customizing and optimizing Ollama AI models")
        
        # Draw version
        VersionFont = QFont("Arial", 10)
        Painter.setFont(VersionFont)
        Painter.drawText(50, 180, "Version 1.0.0")
        
        # Draw credits
        CreditsFont = QFont("Arial", 10)
        Painter.setFont(CreditsFont)
        Painter.setPen(QColor(100, 100, 100))
        Painter.drawText(50, 350, " 2025 Herbert J. Bowers")
        Painter.drawText(50, 370, "A Human-AI Collaboration Project")
        
        # Draw progress bar frame
        Painter.setPen(QColor(200, 200, 200))
        Painter.setBrush(Qt.white)
        Painter.drawRect(50, 250, 500, 30)
        
        # Draw progress bar
        ProgressWidth = int(500 * (self.Progress / self.ProgressMax))
        Painter.setPen(Qt.NoPen)
        Painter.setBrush(QColor(0, 120, 212))
        Painter.drawRect(50, 250, ProgressWidth, 30)
        
        # Determine status message based on progress
        StatusMessage = "Initializing..."
        if self.Progress > 20:
            StatusMessage = "Loading configuration..."
        if self.Progress > 40:
            StatusMessage = "Connecting to Ollama API..."
        if self.Progress > 60:
            StatusMessage = "Loading model information..."
        if self.Progress > 80:
            StatusMessage = "Preparing UI components..."
        
        # Draw status text
        Painter.setPen(QColor(40, 40, 40))
        StatusFont = QFont("Arial", 10)
        Painter.setFont(StatusFont)
        Painter.drawText(50, 220, StatusMessage)
        
        # End painting
        Painter.end()
        
        # Set the updated pixmap to the splash screen
        self.setPixmap(CurrentPixmap)
    
    def _UpdateProgress(self):
        """Update progress bar display."""
        if self.Progress >= self.ProgressMax:
            self.ProgressTimer.stop()
            return
        
        # Increase progress
        self.Progress += 2
        
        # Update display
        self._DrawContent()
    
    def mousePressEvent(self, event):
        """
        Handle mouse press events.
        
        Mouse clicks will hide the splash screen.
        
        Args:
            event: Mouse event
        """
        self.hide()

================
File: scripts/GithubUpdate.sh
================
#!/bin/bash

# GitHub Update Script for OllamaModelEditor
# This script automates the process of committing and pushing changes to GitHub

# Color codes for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}========================================${NC}"
echo -e "${BLUE}  GitHub Update Script for OllamaModelEditor${NC}"
echo -e "${BLUE}========================================${NC}"

# Check if git is installed
if ! command -v git &> /dev/null; then
    echo -e "${RED}Error: git is not installed.${NC}"
    exit 1
fi

# Check if the current directory is a git repository
if [ ! -d ".git" ]; then
    echo -e "${RED}Error: This directory is not a git repository.${NC}"
    echo -e "${YELLOW}Run 'git init' to initialize a new repository.${NC}"
    exit 1
fi

# Check if remote origin exists
if ! git remote get-url origin &> /dev/null; then
    echo -e "${RED}Error: Remote 'origin' not configured.${NC}"
    echo -e "${YELLOW}Use 'git remote add origin <url>' to add a remote repository.${NC}"
    exit 1
fi

# Function to get commit message
get_commit_message() {
    # Default commit message
    default_message="Update OllamaModelEditor files"
    
    # If a message was provided as an argument, use it
    if [ -n "$1" ]; then
        echo "$1"
    else
        # Ask for commit message with default
        read -p "Enter commit message [$default_message]: " message
        echo "${message:-$default_message}"
    fi
}

# Check git status
echo -e "${BLUE}Checking repository status...${NC}"
git status

# Store current status output
status_output=$(git status --porcelain)

# If there are no changes, exit
if [ -z "$status_output" ]; then
    echo -e "${GREEN}No changes to commit. Repository is up to date.${NC}"
    exit 0
fi

# Show summary of changes
echo -e "${YELLOW}Changes detected:${NC}"
echo -e "${YELLOW}-------------------${NC}"
modified_files=$(echo "$status_output" | grep '^ M\|^M ' | wc -l)
untracked_files=$(echo "$status_output" | grep '^??' | wc -l)
deleted_files=$(echo "$status_output" | grep '^ D\|^D ' | wc -l)

echo -e "${YELLOW}Modified files: ${NC}$modified_files"
echo -e "${YELLOW}New files: ${NC}$untracked_files"
echo -e "${YELLOW}Deleted files: ${NC}$deleted_files"
echo -e "${YELLOW}-------------------${NC}"

# Prompt to continue
read -p "Continue with update? (y/n): " continue_update
if [[ ! "$continue_update" =~ ^[Yy]$ ]]; then
    echo -e "${YELLOW}Update canceled.${NC}"
    exit 0
fi

# Stage all changes
echo -e "${BLUE}Staging all changes...${NC}"
git add .

# Show what's staged
echo -e "${BLUE}Files staged for commit:${NC}"
git status

# Get commit message (from argument or prompt)
commit_message=$(get_commit_message "$1")

# Commit changes
echo -e "${BLUE}Committing changes...${NC}"
git commit -m "$commit_message"

# Check if commit was successful
if [ $? -ne 0 ]; then
    echo -e "${RED}Commit failed. Exiting.${NC}"
    exit 1
fi

# Prompt before pushing
read -p "Push changes to GitHub? (y/n): " push_changes
if [[ ! "$push_changes" =~ ^[Yy]$ ]]; then
    echo -e "${YELLOW}Changes committed but not pushed.${NC}"
    echo -e "${YELLOW}Run 'git push origin main' to push changes when ready.${NC}"
    exit 0
fi

# Push changes
echo -e "${BLUE}Pushing changes to GitHub...${NC}"
git push origin main

# Check if push was successful
if [ $? -eq 0 ]; then
    echo -e "${GREEN}Success! All changes have been pushed to GitHub.${NC}"
else
    echo -e "${RED}Push failed. You may need to pull changes first with 'git pull origin main'.${NC}"
    exit 1
fi

echo -e "${BLUE}========================================${NC}"
echo -e "${GREEN}GitHub update complete!${NC}"
echo -e "${BLUE}========================================${NC}"

================
File: scripts/MigrateDBToPascalCase.py
================
#!/usr/bin/env python3
# File: MigrateDBToPascalCase.py
# Path: OllamaModelEditor/scripts/MigrateDBToPascalCase.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-12
# Last Modified: 2025-03-12 09:00PM
# Description: Migrates the database schema from snake_case to PascalCase

import os
import sys
import sqlite3
import json
import time
import argparse
from pathlib import Path
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, 
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
Logger = logging.getLogger('DatabaseMigration')

# Add project root to path
ProjectRoot = Path(__file__).resolve().parents[1]
sys.path.append(str(ProjectRoot))

def ParseCommandLine():
    """
    Parse command line arguments.
    
    Returns:
        Namespace with parsed arguments
    """
    Parser = argparse.ArgumentParser(description="OllamaModelEditor - Database Schema Migration")
    Parser.add_argument("--db", help="Path to database file", required=True)
    Parser.add_argument("--backup", action="store_true", help="Create a backup before migration")
    Parser.add_argument("--force", action="store_true", help="Force migration even if errors occur")
    return Parser.parse_args()

def BackupDatabase(SourcePath: str) -> str:
    """
    Create a backup of the database.
    
    Args:
        SourcePath: Path to the database file
        
    Returns:
        Path to the backup file
    """
    Logger.info(f"Creating database backup...")
    
    # Define backup path
    BackupPath = f"{SourcePath}.backup_{int(time.time())}"
    
    try:
        # Connect to source database
        SourceConn = sqlite3.connect(SourcePath)
        
        # Connect to backup database
        BackupConn = sqlite3.connect(BackupPath)
        
        # Copy database content
        SourceConn.backup(BackupConn)
        
        # Close connections
        SourceConn.close()
        BackupConn.close()
        
        Logger.info(f"Database backed up to: {BackupPath}")
        return BackupPath
        
    except sqlite3.Error as Error:
        Logger.error(f"Error backing up database: {Error}")
        raise

def GetTableNames(Conn: sqlite3.Connection) -> list:
    """
    Get a list of all tables in the database.
    
    Args:
        Conn: Database connection
        
    Returns:
        List of table names
    """
    Cursor = Conn.cursor()
    Cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
    return [Row[0] for Row in Cursor.fetchall()]

def GetColumnInfo(Conn: sqlite3.Connection, TableName: str) -> list:
    """
    Get column information for a table.
    
    Args:
        Conn: Database connection
        TableName: Name of the table
        
    Returns:
        List of column information (name, type, etc.)
    """
    Cursor = Conn.cursor()
    Cursor.execute(f"PRAGMA table_info({TableName})")
    return Cursor.fetchall()

def ConvertSnakeToPascalCase(SnakeCase: str) -> str:
    """
    Convert snake_case to PascalCase.
    
    Args:
        SnakeCase: String in snake_case
        
    Returns:
        String in PascalCase
    """
    # Special case for ID
    if SnakeCase.lower() == "id":
        return "ID"
    
    # Handle special terms
    SpecialTerms = {
        "api": "API",
        "db": "DB",
        "gui": "GUI",
        "url": "URL",
        "uri": "URI",
        "json": "JSON",
        "xml": "XML",
        "html": "HTML",
        "css": "CSS",
        "sql": "SQL"
    }
    
    # Split by underscore and convert each word
    Words = SnakeCase.split("_")
    
    # Process each word
    for i, Word in enumerate(Words):
        # Check if the word is a special term
        if Word.lower() in SpecialTerms:
            Words[i] = SpecialTerms[Word.lower()]
        else:
            # Capitalize the first letter of each word
            Words[i] = Word.capitalize()
    
    # Join words together
    return "".join(Words)

def CreateMigrationScript(SourceTables: dict) -> list:
    """
    Create SQL migration script.
    
    Args:
        SourceTables: Dictionary of table names and their columns
        
    Returns:
        List of SQL statements for migration
    """
    MigrationScript = []
    
    # Create temporary tables, copy data, drop original tables, rename temp tables
    for TableName, Columns in SourceTables.items():
        # Skip tables that already use PascalCase
        if TableName == "DBVersion" or TableName.startswith("sqlite_"):
            continue
            
        # Create PascalCase table name
        NewTableName = TableName
        if "_" in TableName:
            NewTableName = ConvertSnakeToPascalCase(TableName)
        
        # Get column definitions with PascalCase names
        ColumnDefs = []
        OldColumns = []
        NewColumns = []
        
        for Column in Columns:
            CID, Name, Type, NotNull, DefaultValue, PK = Column
            
            # Convert column name to PascalCase
            NewName = Name
            if "_" in Name:
                NewName = ConvertSnakeToPascalCase(Name)
            
            # Build column definition
            ColumnDef = f"{NewName} {Type}"
            if NotNull:
                ColumnDef += " NOT NULL"
            if DefaultValue is not None:
                ColumnDef += f" DEFAULT {DefaultValue}"
            if PK:
                ColumnDef += " PRIMARY KEY"
            
            ColumnDefs.append(ColumnDef)
            OldColumns.append(Name)
            NewColumns.append(NewName)
        
        # Create temporary table
        TempTableName = f"temp_{TableName}"
        CreateTableSQL = f"CREATE TABLE {TempTableName} ({', '.join(ColumnDefs)})"
        MigrationScript.append(CreateTableSQL)
        
        # Copy data
        OldColumnsStr = ', '.join(OldColumns)
        NewColumnsStr = ', '.join(NewColumns)
        CopyDataSQL = f"INSERT INTO {TempTableName} ({NewColumnsStr}) SELECT {OldColumnsStr} FROM {TableName}"
        MigrationScript.append(CopyDataSQL)
        
        # Drop original table
        DropTableSQL = f"DROP TABLE {TableName}"
        MigrationScript.append(DropTableSQL)
        
        # Rename temporary table
        RenameTableSQL = f"ALTER TABLE {TempTableName} RENAME TO {NewTableName}"
        MigrationScript.append(RenameTableSQL)
    
    return MigrationScript

def MigrateDatabase(DBPath: str, Force: bool = False) -> bool:
    """
    Migrate database from snake_case to PascalCase.
    
    Args:
        DBPath: Path to the database file
        Force: Whether to force migration even if errors occur
        
    Returns:
        True if successful, False otherwise
    """
    try:
        # Connect to the database
        Conn = sqlite3.connect(DBPath)
        
        # Get table names
        TableNames = GetTableNames(Conn)
        Logger.info(f"Found {len(TableNames)} tables in the database")
        
        # Get column information for each table
        SourceTables = {}
        for TableName in TableNames:
            if not TableName.startswith("sqlite_"):  # Skip SQLite internal tables
                SourceTables[TableName] = GetColumnInfo(Conn, TableName)
        
        # Create migration script
        MigrationScript = CreateMigrationScript(SourceTables)
        Logger.info(f"Generated {len(MigrationScript)} SQL statements for migration")
        
        # Execute migration script
        Cursor = Conn.cursor()
        for SQL in MigrationScript:
            try:
                Logger.debug(f"Executing: {SQL}")
                Cursor.execute(SQL)
            except sqlite3.Error as Error:
                Logger.error(f"Error executing SQL: {Error}")
                Logger.error(f"SQL: {SQL}")
                if not Force:
                    raise
        
        # Commit changes
        Conn.commit()
        Logger.info("Migration completed successfully")
        
        # Close connection
        Conn.close()
        
        return True
    
    except Exception as Error:
        Logger.error(f"Error migrating database: {Error}")
        return False

def main():
    """Main function."""
    # Parse command line arguments
    Args = ParseCommandLine()
    
    try:
        Logger.info(f"Starting database migration from snake_case to PascalCase")
        Logger.info(f"Database path: {Args.db}")
        
        # Check if database exists
        if not os.path.exists(Args.db):
            Logger.error(f"Database file not found: {Args.db}")
            return 1
        
        # Create backup if requested
        if Args.backup:
            try:
                BackupPath = BackupDatabase(Args.db)
                Logger.info(f"Backup created at: {BackupPath}")
            except Exception as Error:
                Logger.error(f"Failed to create backup: {Error}")
                return 1
        
        # Migrate database
        Success = MigrateDatabase(Args.db, Args.force)
        
        if Success:
            Logger.info("Database migration completed successfully")
            return 0
        else:
            Logger.error("Database migration failed")
            return 1
    
    except Exception as Error:
        Logger.error(f"Error: {Error}")
        return 1

if __name__ == "__main__":
    sys.exit(main())

================
File: scripts/MigrateToDatabase.py
================
#!/usr/bin/env python3
# File: MigrateToDatabase.py
# Path: OllamaModelEditor/scripts/MigrateToDatabase.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-12
# Last Modified: 2025-03-12 06:30PM
# Description: Migrates configuration from files to SQLite database

import os
import sys
import json
import yaml
import argparse
from pathlib import Path

# Add project root to path
ProjectRoot = Path(__file__).resolve().parents[1]
sys.path.append(str(ProjectRoot))

try:
    from Core.DBManager import DBManager
    from Core.ConfigManager import ConfigManager
except ImportError as Error:
    print(f"Error importing required modules: {Error}")
    print("Make sure you're running this script from the OllamaModelEditor directory")
    sys.exit(1)

def MigrateToDatabase(ConfigPath=None, DBPath=None):
    """
    Migrate configuration from files to database.
    
    Args:
        ConfigPath: Optional path to configuration file
        DBPath: Optional path to database file
    """
    print("\nOllamaModelEditor - Configuration Migration Tool")
    print("==============================================\n")
    print("This tool will migrate your configuration from files to the SQLite database.")
    print("Your existing configuration files will not be modified.")
    
    # Initialize database
    try:
        print("\nInitializing database...")
        DB = DBManager(DBPath)
        print(f"Database initialized: {DB.DBPath}")
    except Exception as Error:
        print(f"Error initializing database: {Error}")
        sys.exit(1)
    
    # Initialize file-based configuration
    try:
        print("\nLoading configuration files...")
        Config = ConfigManager(ConfigPath)
        Success = Config.LoadConfig()
        
        if Success:
            print("Configuration loaded successfully.")
        else:
            print("Warning: Configuration loaded with default values.")
    except Exception as Error:
        print(f"Error loading configuration: {Error}")
        sys.exit(1)
    
    # Start migration
    print("\nStarting migration...")
    
    print("\nMigrating application settings...")
    SuccessCount = 0
    TotalCount = len(Config.AppConfig)
    
    # Migrate application settings
    for Key, Value in Config.AppConfig.items():
        try:
            DB.SetAppSetting(Key, Value)
            SuccessCount += 1
            print(f"   Setting migrated: {Key}")
        except Exception as Error:
            print(f"   Error migrating setting {Key}: {Error}")
    
    print(f"Migrated {SuccessCount} of {TotalCount} application settings.")
    
    print("\nMigrating user preferences...")
    SuccessCount = 0
    TotalCount = len(Config.UserPreferences)
    
    # Migrate user preferences
    for Key, Value in Config.UserPreferences.items():
        try:
            DB.SetUserPreference(Key, Value)
            SuccessCount += 1
            print(f"   Preference migrated: {Key}")
        except Exception as Error:
            print(f"   Error migrating preference {Key}: {Error}")
    
    print(f"Migrated {SuccessCount} of {TotalCount} user preferences.")
    
    print("\nMigrating model configurations...")
    SuccessCount = 0
    TotalCount = 0
    
    # Count total configurations
    for ModelName, ModelConfig in Config.ModelConfigs.items():
        if isinstance(ModelConfig, dict) and not isinstance(list(ModelConfig.values())[0], dict):
            TotalCount += 1
        else:
            TotalCount += len(ModelConfig)
    
    # Migrate model configurations
    for ModelName, ModelConfig in Config.ModelConfigs.items():
        try:
            if isinstance(ModelConfig, dict) and not isinstance(list(ModelConfig.values())[0], dict):
                # This is a single configuration (not a dict of configs)
                DB.SaveModelConfig(ModelName, "Default", ModelConfig)
                SuccessCount += 1
                print(f"   Model configuration migrated: {ModelName}")
            else:
                # This is a dict of configurations
                for ConfigName, ConfigParams in ModelConfig.items():
                    DB.SaveModelConfig(ModelName, ConfigName, ConfigParams)
                    SuccessCount += 1
                    print(f"   Model configuration migrated: {ModelName}/{ConfigName}")
        except Exception as Error:
            print(f"   Error migrating model configuration {ModelName}: {Error}")
    
    print(f"Migrated {SuccessCount} of {TotalCount} model configurations.")
    
    print("\nMigration completed successfully!")
    print(f"Database path: {DB.DBPath}")
    print("\nYou can now use the database for configuration storage.")
    print("To use the database, run the application with the --db flag:")
    print(f"  python Main.py --db {DB.DBPath}")

def ParseCommandLine():
    """
    Parse command line arguments.
    
    Returns:
        Namespace with parsed arguments
    """
    Parser = argparse.ArgumentParser(description="OllamaModelEditor - Configuration Migration Tool")
    Parser.add_argument("--config", help="Path to configuration file")
    Parser.add_argument("--db", help="Path to database file")
    return Parser.parse_args()

if __name__ == "__main__":
    Args = ParseCommandLine()
    MigrateToDatabase(Args.config, Args.db)

================
File: scripts/Setup.bat
================
@echo off
REM File: Setup.bat
REM Path: OllamaModelEditor/scripts/Setup.bat
REM Standard: AIDEV-PascalCase-1.2
REM Created: 2025-03-11
REM Last Modified: 2025-03-11
REM Description: Windows setup script for OllamaModelEditor project

echo === Setting Up Python Virtual Environment ===
python -m venv .venv
call .venv\Scripts\activate.bat

echo === Installing Dependencies ===
pip install -r requirements.txt

echo === Setup Complete ===
echo.
echo Virtual environment created and dependencies installed.
echo To activate the virtual environment in the future, run:
echo   .venv\Scripts\activate.bat
echo.
pause

================
File: scripts/Setup.sh
================
#!/bin/bash
# File: Setup.sh
# Path: OllamaModelEditor/scripts/Setup.sh
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Setup script for OllamaModelEditor project

# Text colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Function to print section headers
PrintHeader() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

# Function to check command existence
CheckCommand() {
    if ! command -v $1 &> /dev/null; then
        echo -e "${RED}Error: $1 is required but not installed.${NC}"
        echo -e "Please install $1 and try again."
        exit 1
    fi
}

# Function to create directories from project structure
CreateDirectories() {
    PrintHeader "Creating Project Structure"
    
    # Main directories
    mkdir -p OllamaModelEditor
    cd OllamaModelEditor
    
    # Create directory structure
    mkdir -p .github/workflows
    mkdir -p .github/ISSUE_TEMPLATE
    mkdir -p Core
    mkdir -p GUI/Assets/{icons,themes,fonts}
    mkdir -p GUI/Components
    mkdir -p GUI/Dialogs
    mkdir -p GUI/Windows
    mkdir -p Tests/{UnitTests,IntegrationTests,UITests}
    mkdir -p Utils
    mkdir -p Features
    mkdir -p docs/screenshots
    mkdir -p scripts
    
    echo -e "${GREEN}Directory structure created successfully.${NC}"
}

# Function to set up virtual environment
SetupVirtualEnv() {
    PrintHeader "Setting Up Python Virtual Environment"
    
    # Create virtual environment
    python3 -m venv .venv
    
    # Activate virtual environment
    source .venv/bin/activate
    
    # Create initial requirements.txt
    cat > requirements.txt << EOF
PySide6>=6.5.0
pytest>=7.3.1
pytest-qt>=4.2.0
requests>=2.28.2
pyyaml>=6.0
loguru>=0.7.0
EOF
    
    # Install requirements
    pip install -r requirements.txt
    
    echo -e "${GREEN}Virtual environment created and dependencies installed.${NC}"
}

# Function to initialize Git repository
SetupGit() {
    PrintHeader "Setting Up Git Repository"
    
    # Initialize git repository
    git init
    
    # Create .gitignore
    cat > .gitignore << EOF
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
.venv/
venv/
ENV/
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# IDE
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Project specific
*.log
.env
EOF
    
    # Create GitHub workflow for CI
    mkdir -p .github/workflows
    cat > .github/workflows/ci.yml << EOF
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Run tests
      run: |
        pytest
EOF
    
    # Create PR template
    cat > .github/PULL_REQUEST_TEMPLATE.md << EOF
## Description
<!-- Provide a brief description of the changes in this PR -->

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Documentation update
- [ ] Code refactoring
- [ ] Other (please describe):

## Testing Performed
<!-- Describe the testing done to verify your changes -->

## Checklist
- [ ] My code follows the AIDEV-PascalCase standards of this project
- [ ] I have performed a self-review of my own code
- [ ] I have added tests that prove my fix is effective or that my feature works
- [ ] New and existing unit tests pass locally with my changes
- [ ] I have updated the documentation accordingly
EOF
    
    # Create issue templates
    cat > .github/ISSUE_TEMPLATE/bug_report.md << EOF
---
name: Bug report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '...'
3. Scroll down to '...'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Environment:**
 - OS: [e.g. Windows, macOS, Linux]
 - Python Version: [e.g. 3.8, 3.9]
 - Application Version: [e.g. 1.0.0]

**Additional context**
Add any other context about the problem here.
EOF
    
    cat > .github/ISSUE_TEMPLATE/feature_request.md << EOF
---
name: Feature request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is.

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
EOF
    
    # Initial commit
    git add .
    git commit -m "Initial project structure"
    
    echo -e "${GREEN}Git repository initialized successfully.${NC}"
}

# Function to set up GitHub remote (if credentials available)
SetupGitHubRemote() {
    PrintHeader "Setting Up GitHub Remote"
    
    echo -e "${YELLOW}Would you like to set up the GitHub remote now? (y/n)${NC}"
    read answer
    
    if [ "$answer" != "${answer#[Yy]}" ]; then
        echo -e "Enter your GitHub username (default: CallMeChewy):"
        read username
        username=${username:-CallMeChewy}
        
        echo -e "Enter the repository name (default: OllamaModelEditor):"
        read repo
        repo=${repo:-OllamaModelEditor}
        
        echo -e "Setting up remote repository..."
        git remote add origin https://github.com/$username/$repo.git
        
        echo -e "${YELLOW}Would you like to push the initial commit to GitHub? (y/n)${NC}"
        read push
        
        if [ "$push" != "${push#[Yy]}" ]; then
            echo -e "Pushing to GitHub..."
            git push -u origin main
            echo -e "${GREEN}Repository pushed to GitHub successfully.${NC}"
        else
            echo -e "${BLUE}Skipping push to GitHub. You can push later with:${NC}"
            echo -e "  git push -u origin main"
        fi
    else
        echo -e "${BLUE}Skipping GitHub remote setup. You can set up later with:${NC}"
        echo -e "  git remote add origin https://github.com/CallMeChewy/OllamaModelEditor.git"
    fi
}

# Function to create Windows setup script
CreateWindowsScript() {
    PrintHeader "Creating Windows Setup Script"
    
    cat > scripts/Setup.bat << EOF
@echo off
REM File: Setup.bat
REM Path: OllamaModelEditor/scripts/Setup.bat
REM Standard: AIDEV-PascalCase-1.2
REM Created: 2025-03-11
REM Last Modified: 2025-03-11
REM Description: Windows setup script for OllamaModelEditor project

echo === Setting Up Python Virtual Environment ===
python -m venv .venv
call .venv\Scripts\activate.bat

echo === Installing Dependencies ===
pip install -r requirements.txt

echo === Setup Complete ===
echo.
echo Virtual environment created and dependencies installed.
echo To activate the virtual environment in the future, run:
echo   .venv\Scripts\activate.bat
echo.
pause
EOF
    
    chmod +x scripts/Setup.bat
    echo -e "${GREEN}Windows setup script created.${NC}"
}

# Function to create initial Main.py
CreateMainPy() {
    PrintHeader "Creating Main.py"
    
    cat > Main.py << EOF
# File: Main.py
# Path: OllamaModelEditor/Main.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Entry point for the OllamaModelEditor application

import sys
from pathlib import Path

# Add project root to path
ProjectRoot = Path(__file__).resolve().parent
sys.path.append(str(ProjectRoot))

# Import GUI components
try:
    from PySide6.QtWidgets import QApplication
    from PySide6.QtCore import QTimer
    from GUI.Windows.MainWindow import MainWindow
    from GUI.Windows.SplashScreen import SplashScreen
except ImportError:
    print("Error: PySide6 is required but not installed.")
    print("Please install dependencies with: pip install -r requirements.txt")
    sys.exit(1)

# Import core components
from Core.LoggingUtils import SetupLogging
from Core.ConfigManager import ConfigManager

def Main():
    """Application entry point."""
    # Initialize logging
    SetupLogging()
    
    # Create application
    App = QApplication(sys.argv)
    App.setApplicationName("OllamaModelEditor")
    App.setOrganizationName("CallMeChewy")
    
    # Initialize configuration
    Config = ConfigManager()
    Config.LoadConfig()
    
    # Create and display splash screen
    Splash = SplashScreen()
    Splash.show()
    
    # Initialize main window
    MainWin = MainWindow(Config)
    
    # Close splash and show main window after delay
    QTimer.singleShot(2000, lambda: ShowMainWindow(Splash, MainWin))
    
    # Start event loop
    return App.exec()

def ShowMainWindow(Splash, MainWin):
    """Close splash screen and show main window."""
    Splash.finish(MainWin)
    MainWin.show()

if __name__ == "__main__":
    sys.exit(Main())
EOF
    
    echo -e "${GREEN}Main.py created successfully.${NC}"
}

# Function to create README.md
CreateReadme() {
    PrintHeader "Creating README.md"
    
    cat > README.md << EOF
# OLLAMA MODEL EDITOR

**A powerful tool for customizing and optimizing Ollama AI models**

[Features](#features)  [Installation](#installation)  [Usage](#usage)  [Documentation](#documentation)  [Contributing](#contributing)  [License](#license)

## About

Ollama Model Editor is a comprehensive GUI application that allows you to customize, optimize, and manage your Ollama AI models. This tool provides an intuitive interface for adjusting model parameters, comparing performance across different configurations, and streamlining your AI workflow.

**This project is a collaboration between human developers and AI assistants, demonstrating the power of human-AI teamwork in software development.**

## Features

-  **Parameter Customization**: Fine-tune model parameters through an intuitive GUI
-  **Performance Benchmarking**: Compare different model configurations side-by-side
-  **Model Management**: Easily manage multiple Ollama models in one interface
-  **Optimization Presets**: Apply pre-configured optimization settings for specific use cases
-  **Detailed Analysis**: Get insights into how parameter changes affect model performance
-  **Theming Support**: Choose between light and dark themes for comfortable usage
-  **Configuration Export**: Share your optimized model configurations with others

## Installation

### Prerequisites

- Python 3.8 or higher
- Ollama installed and running on your system
- Git (for cloning the repository)

### Setup

```bash
# Clone the repository
git clone https://github.com/CallMeChewy/OllamaModelEditor.git
cd OllamaModelEditor

# Create a virtual environment
python -m venv .venv
source .venv/bin/activate # On Windows: .venv\\Scripts\\activate

# Install dependencies
pip install -r requirements.txt

# Run the application
python Main.py
```

## Usage

1. Launch the application with **python Main.py**
2. Select an Ollama model from the dropdown menu
3. Adjust parameters using the intuitive interface
4. Compare performance with different settings
5. Save your optimized configuration
6. Export settings to share with the community

For more detailed instructions, see the [Quick Start Guide](docs/QuickStartGuide.md).

## Documentation

- [Quick Start Guide](docs/QuickStartGuide.md)
- [Core Components](Core/README.md)
- [Parameter Reference](docs/parameters.md)
- [Advanced Usage](docs/advanced_usage.md)

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (**git checkout -b feature/amazing-feature**)
3. Commit your changes (**git commit -m 'Add some amazing feature'**)
4. Push to the branch (**git push origin feature/amazing-feature**)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgements

- This project is a collaboration between human developers and AI assistants
- Special thanks to the Ollama project for making powerful AI models accessible
- Developed by Herbert J. Bowers (Herb@BowersWorld.com)
EOF
    
    echo -e "${GREEN}README.md created successfully.${NC}"
}

# Function to create MIT license
CreateLicense() {
    PrintHeader "Creating LICENSE"
    
    cat > LICENSE << EOF
MIT License

Copyright (c) 2025 Herbert J. Bowers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
EOF
    
    echo -e "${GREEN}LICENSE created successfully.${NC}"
}

# Main execution
PrintHeader "OllamaModelEditor Project Setup"

# Check for required commands
CheckCommand "python3"
CheckCommand "git"

# Create project structure
CreateDirectories

# Setup tasks
SetupVirtualEnv
SetupGit
CreateWindowsScript
CreateMainPy
CreateReadme
CreateLicense
SetupGitHubRemote

PrintHeader "Setup Complete"
echo -e "${GREEN}OllamaModelEditor project has been successfully set up!${NC}"
echo -e "\nTo activate the virtual environment:"
echo -e "  ${BLUE}source .venv/bin/activate${NC}"
echo -e "\nTo start the application:"
echo -e "  ${BLUE}python Main.py${NC}"
echo -e "\nHappy coding! "

================
File: scripts/SimpleGitHubSetup.sh
================
#!/bin/bash
# File: SimpleGitHubSetup.sh
# Path: OllamaModelEditor/scripts/SimpleGitHubSetup.sh
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Simple script to reset and initialize GitHub repository

# Text colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Function to print section headers
PrintHeader() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

# Check if git is installed
if ! command -v git &> /dev/null; then
    echo -e "${RED}Error: git is required but not installed.${NC}"
    echo -e "Please install git and try again."
    exit 1
fi

PrintHeader "GitHub Repository Setup"

# GitHub username and repository name
GITHUB_USERNAME="CallMeChewy"
REPO_NAME="OllamaModelEditor"

echo -e "This script will set up your GitHub repository for:"
echo -e "  ${GREEN}$GITHUB_USERNAME/$REPO_NAME${NC}"
echo -e "\n${YELLOW}Is this correct? (y/n)${NC}"
read answer

if [ "$answer" != "${answer#[Yy]}" ]; then
    # Make sure we're in the project root directory (where Main.py is)
    if [ ! -f "Main.py" ]; then
        echo -e "${RED}Error: Main.py not found. Please run this script from the project root directory.${NC}"
        exit 1
    fi

    PrintHeader "Initializing Git Repository"
    
    # Remove any existing git directory
    echo -e "Removing any existing Git data..."
    rm -rf .git
    
    # Initialize new git repository
    echo -e "Initializing new Git repository..."
    git init
    
    # Create .gitignore file
    echo -e "Creating .gitignore file..."
    cat > .gitignore << EOF
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
.venv/
venv/
ENV/
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# IDE
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Project specific
*.log
.env

# Custom exclusions
..Exclude/
..Scripts/
..Next/
..Vision/
EOF
    
    # Add all files
    echo -e "Adding files to Git..."
    git add .
    
    # Make initial commit
    echo -e "Creating initial commit..."
    git commit -m "Initial commit of OllamaModelEditor project"
    
    PrintHeader "Connecting to GitHub"
    
    # Add GitHub as remote origin
    echo -e "Adding GitHub remote..."
    git remote add origin https://github.com/$GITHUB_USERNAME/$REPO_NAME.git
    
    echo -e "${YELLOW}Do you want to push to GitHub now? (y/n)${NC}"
    echo -e "${YELLOW}Note: This will overwrite any existing content in your GitHub repository.${NC}"
    read push_now
    
    if [ "$push_now" != "${push_now#[Yy]}" ]; then
        PrintHeader "Pushing to GitHub"
        
        echo -e "Enter your GitHub username: $GITHUB_USERNAME"
        
        # Force push to overwrite any existing content
        echo -e "Pushing to GitHub (you'll be prompted for your password or access token)..."
        git push -f origin master
        
        # Check if push was successful
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Successfully pushed to GitHub!${NC}"
            echo -e "Your repository is now available at: ${BLUE}https://github.com/$GITHUB_USERNAME/$REPO_NAME${NC}"
        else
            echo -e "${RED}Push failed.${NC}"
            echo -e "You may need to:"
            echo -e "1. Create a personal access token on GitHub:"
            echo -e "   ${BLUE}https://github.com/settings/tokens${NC}"
            echo -e "2. Use that token as your password when prompted"
            echo -e "\nOr push manually with:"
            echo -e "  git push -f origin master"
        fi
    else
        echo -e "${BLUE}Skipping push to GitHub. You can push later with:${NC}"
        echo -e "  git push -f origin master"
    fi
    
    PrintHeader "Setup Complete"
    echo -e "${GREEN}Your repository has been set up successfully!${NC}"
    
else
    echo -e "${RED}Operation cancelled.${NC}"
    exit 1
fi

================
File: scripts/UpdateGitHub.sh
================
#!/bin/bash
# File: UpdateGitHub.sh
# Path: OllamaModelEditor/scripts/UpdateGitHub.sh
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Updates existing GitHub repository with new project structure

# Text colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Function to print section headers
PrintHeader() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

# Check if git is installed
if ! command -v git &> /dev/null; then
    echo -e "${RED}Error: git is required but not installed.${NC}"
    echo -e "Please install git and try again."
    exit 1
fi

# Check if we're in a git repository
if ! git rev-parse --is-inside-work-tree &> /dev/null; then
    echo -e "${RED}Error: Not in a git repository.${NC}"
    echo -e "Please run this script from within your OllamaModelEditor git repository."
    exit 1
fi

PrintHeader "Updating GitHub Repository"

# Define repository details
GITHUB_USERNAME="CallMeChewy"
PROJECT_NAME="OllamaModelEditor"
EXPECTED_REPO_URL="https://github.com/$GITHUB_USERNAME/$PROJECT_NAME.git"

# Verify repository
echo -e "${YELLOW}Current repository:${NC}"
ACTUAL_REPO_URL=$(git config --get remote.origin.url)
echo -e "Expected repository: ${GREEN}$GITHUB_USERNAME/$PROJECT_NAME${NC}"
echo -e "Expected URL: ${GREEN}$EXPECTED_REPO_URL${NC}"
echo -e "\nActual repository URL: ${BLUE}$ACTUAL_REPO_URL${NC}"
echo -e "\nRemote details:"
git remote -v

# Check if this is the expected repository
if [[ "$ACTUAL_REPO_URL" == "$EXPECTED_REPO_URL" || "$ACTUAL_REPO_URL" == "git@github.com:$GITHUB_USERNAME/$PROJECT_NAME.git" ]]; then
    echo -e "\n${GREEN} This is the correct repository.${NC}"
else
    echo -e "\n${YELLOW} Warning: The current repository does not match the expected repository.${NC}"
fi

echo -e "\n${YELLOW}Is this the correct repository you want to update? (y/n)${NC}"
read answer
if [ "$answer" != "${answer#[Yy]}" ]; then
    # Proceed with update
    PrintHeader "Backing up any existing changes"
    
    # Check if there are uncommitted changes
    if ! git diff --quiet HEAD; then
        # Create backup branch with timestamp
        BACKUP_BRANCH="backup_$(date +%Y%m%d_%H%M%S)"
        echo -e "Creating backup branch: ${BACKUP_BRANCH}"
        git checkout -b $BACKUP_BRANCH
        git add .
        git commit -m "Backup before repository update"
        echo -e "${GREEN}Backup created on branch: ${BACKUP_BRANCH}${NC}"
        
        # Switch back to main branch
        git checkout main || git checkout master
    else
        echo -e "No uncommitted changes to backup."
    fi
    
    PrintHeader "Preparing for update"
    
    # Ask if user wants to keep any specific files
    echo -e "${YELLOW}Do you want to keep any specific files from the current repository? (y/n)${NC}"
    read keep_files
    if [ "$keep_files" != "${keep_files#[Yy]}" ]; then
        echo -e "Please enter file/directory patterns to keep, separated by spaces:"
        echo -e "(For example: README.md LICENSE .github/workflows)"
        read -a files_to_keep
        
        # Create a temporary directory to store files
        TEMP_DIR=$(mktemp -d)
        echo -e "Temporarily storing files in: ${TEMP_DIR}"
        
        # Copy files to keep to temp directory
        for file in "${files_to_keep[@]}"; do
            if [ -e "$file" ]; then
                # Create directory structure in temp
                mkdir -p "$TEMP_DIR/$(dirname "$file")"
                cp -r "$file" "$TEMP_DIR/$(dirname "$file")/"
                echo -e "Saved: $file"
            else
                echo -e "${YELLOW}Warning: $file not found${NC}"
            fi
        done
    fi
    
    PrintHeader "Removing existing files"
    
    # Get root directory of the git repository
    REPO_ROOT=$(git rev-parse --show-toplevel)
    
    # Remove all files except .git directory and temporary script
    find "$REPO_ROOT" -mindepth 1 -not -path "$REPO_ROOT/.git*" -not -path "$0" | xargs rm -rf
    
    echo -e "${GREEN}Repository cleaned successfully.${NC}"
    
    # Restore kept files if any
    if [ "$keep_files" != "${keep_files#[Yy]}" ] && [ -d "$TEMP_DIR" ]; then
        echo -e "Restoring files you chose to keep..."
        cp -r "$TEMP_DIR"/* "$REPO_ROOT"/ 2>/dev/null || true
        rm -rf "$TEMP_DIR"
    fi
    
    PrintHeader "Adding new project files"
    
    # Assuming we're in the OllamaModelEditor directory
    echo -e "Copying new files to repository..."
    
    # Get the current directory
    CURRENT_DIR=$(pwd)
    
    # Copy all project files to the repository root
    rsync -av --exclude='.git/' --exclude='scripts/UpdateGitHub.sh' "$CURRENT_DIR"/* "$REPO_ROOT"/
    
    echo -e "${GREEN}New files copied successfully.${NC}"
    
    PrintHeader "Committing changes"
    
    # Add all new files
    git add .
    
    # Commit changes
    git commit -m "Complete project restructure to AIDEV-PascalCase standards"
    
    echo -e "${GREEN}Changes committed successfully.${NC}"
    
    PrintHeader "Push to GitHub"
    
    echo -e "${YELLOW}Do you want to push these changes to GitHub now? (y/n)${NC}"
    read push_now
    if [ "$push_now" != "${push_now#[Yy]}" ]; then
        # Determine default branch name
        DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
        
        echo -e "Pushing to ${DEFAULT_BRANCH} branch..."
        git push origin $DEFAULT_BRANCH
        
        echo -e "${GREEN}Changes pushed to GitHub successfully.${NC}"
    else
        echo -e "${BLUE}Changes were not pushed. You can push manually with:${NC}"
        echo -e "  git push origin main  # or 'master' depending on your default branch"
    fi
    
    PrintHeader "Update Complete"
    echo -e "${GREEN}Your GitHub repository has been updated successfully!${NC}"
    
else
    echo -e "${RED}Operation cancelled.${NC}"
    exit 1
fi

================
File: Tests/UnitTests/TestConfigManager.py
================
# File: TestConfigManager.py
# Path: OllamaModelEditor/Tests/UnitTests/TestConfigManager.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Unit tests for the ConfigManager module

import os
import sys
import json
import yaml
import tempfile
import unittest
from pathlib import Path
from typing import Dict, Any

# Add project root to path for imports
ProjectRoot = Path(__file__).resolve().parents[2]
sys.path.append(str(ProjectRoot))

# Import the module to test
from Core.ConfigManager import ConfigManager

class TestConfigManager(unittest.TestCase):
    """Test case for the ConfigManager class."""
    
    def setUp(self):
        """Set up test fixtures."""
        # Create a temporary directory for test files
        self.TempDir = tempfile.TemporaryDirectory()
        self.ConfigPath = os.path.join(self.TempDir.name, "test_config.yaml")
        
        # Create a ConfigManager instance with the test path
        self.ConfigManager = ConfigManager(self.ConfigPath)
    
    def tearDown(self):
        """Tear down test fixtures."""
        # Clean up temporary directory
        self.TempDir.cleanup()
    
    def test_InitialState(self):
        """Test initial state of ConfigManager."""
        # Check that ConfigPath is set correctly
        self.assertEqual(self.ConfigManager.ConfigPath, self.ConfigPath)
        
        # Check that initial dictionaries are empty
        self.assertEqual(self.ConfigManager.AppConfig, {})
        self.assertEqual(self.ConfigManager.ModelConfigs, {})
        self.assertEqual(self.ConfigManager.UserPreferences, {})
    
    def test_CreateDefaultConfig(self):
        """Test creation of default configuration."""
        # Call method to create default configuration
        self.ConfigManager._CreateDefaultConfig()
        
        # Check that AppConfig contains expected default values
        self.assertIn('Version', self.ConfigManager.AppConfig)
        self.assertIn('APIEndpoint', self.ConfigManager.AppConfig)
        self.assertIn('LogLevel', self.ConfigManager.AppConfig)
        
        # Check that ModelConfigs contains DefaultParameters
        self.assertIn('DefaultParameters', self.ConfigManager.ModelConfigs)
        
        # Check that UserPreferences contains expected default values
        self.assertIn('UIFontSize', self.ConfigManager.UserPreferences)
        self.assertIn('EditorFontFamily', self.ConfigManager.UserPreferences)
    
    def test_SaveAndLoadConfig(self):
        """Test saving and loading configuration."""
        # Set test values
        TestAppConfig = {
            'Version': '1.0.0-test',
            'APIEndpoint': 'http://test-endpoint:11434',
            'LogLevel': 'DEBUG'
        }
        
        TestModelConfigs = {
            'DefaultParameters': {
                'Temperature': 0.5,
                'TopP': 0.8,
                'MaxTokens': 1000
            },
            'TestModel': {
                'Temperature': 0.7,
                'TopP': 0.9,
                'MaxTokens': 2000
            }
        }
        
        TestUserPreferences = {
            'UIFontSize': 14,
            'EditorFontFamily': 'Test Font',
            'ShowWelcomeOnStartup': False
        }
        
        # Set values in ConfigManager
        self.ConfigManager.AppConfig = TestAppConfig
        self.ConfigManager.ModelConfigs = TestModelConfigs
        self.ConfigManager.UserPreferences = TestUserPreferences
        
        # Save configuration
        SaveResult = self.ConfigManager.SaveConfig()
        self.assertTrue(SaveResult, "SaveConfig should return True")
        
        # Check that file was created
        self.assertTrue(os.path.exists(self.ConfigPath), "Config file should exist")
        
        # Create a new ConfigManager instance to load the saved configuration
        NewConfigManager = ConfigManager(self.ConfigPath)
        
        # Load configuration
        LoadResult = NewConfigManager.LoadConfig()
        self.assertTrue(LoadResult, "LoadConfig should return True")
        
        # Check that loaded values match original values
        self.assertEqual(NewConfigManager.AppConfig, TestAppConfig)
        self.assertEqual(NewConfigManager.ModelConfigs, TestModelConfigs)
        self.assertEqual(NewConfigManager.UserPreferences, TestUserPreferences)
    
    def test_GetSetAppConfig(self):
        """Test get and set methods for AppConfig."""
        # Set test values
        self.ConfigManager.SetAppConfig('TestKey', 'TestValue')
        self.ConfigManager.SetAppConfig('AnotherKey', 123)
        
        # Get values
        TestValue = self.ConfigManager.GetAppConfig('TestKey')
        AnotherValue = self.ConfigManager.GetAppConfig('AnotherKey')
        
        # Check values
        self.assertEqual(TestValue, 'TestValue')
        self.assertEqual(AnotherValue, 123)
        
        # Get default value for non-existent key
        NonExistentValue = self.ConfigManager.GetAppConfig('NonExistentKey', 'DefaultValue')
        self.assertEqual(NonExistentValue, 'DefaultValue')
        
        # Get entire AppConfig
        EntireConfig = self.ConfigManager.GetAppConfig()
        self.assertEqual(EntireConfig, {
            'TestKey': 'TestValue',
            'AnotherKey': 123
        })
    
    def test_GetSetModelConfig(self):
        """Test get and set methods for ModelConfigs."""
        # Define test model configuration
        TestModelConfig = {
            'Temperature': 0.8,
            'TopP': 0.95,
            'MaxTokens': 1500
        }
        
        # Set model configuration
        self.ConfigManager.SetModelConfig('TestModel', TestModelConfig)
        
        # Get model configuration
        ModelConfig = self.ConfigManager.GetModelConfig('TestModel')
        
        # Check that retrieved configuration matches
        self.assertEqual(ModelConfig, TestModelConfig)
        
        # Get configuration for non-existent model (should return DefaultParameters)
        # First set DefaultParameters
        DefaultConfig = {
            'Temperature': 0.7,
            'TopP': 0.9,
            'MaxTokens': 2000
        }
        self.ConfigManager.SetModelConfig('DefaultParameters', DefaultConfig)
        
        # Get non-existent model
        NonExistentModel = self.ConfigManager.GetModelConfig('NonExistentModel')
        
        # Should return DefaultParameters
        self.assertEqual(NonExistentModel, DefaultConfig)
    
    def test_GetSetUserPreference(self):
        """Test get and set methods for UserPreferences."""
        # Set test values
        self.ConfigManager.SetUserPreference('TestPref', 'TestValue')
        self.ConfigManager.SetUserPreference('AnotherPref', 456)
        
        # Get values
        TestValue = self.ConfigManager.GetUserPreference('TestPref')
        AnotherValue = self.ConfigManager.GetUserPreference('AnotherPref')
        
        # Check values
        self.assertEqual(TestValue, 'TestValue')
        self.assertEqual(AnotherValue, 456)
        
        # Get default value for non-existent key
        NonExistentValue = self.ConfigManager.GetUserPreference('NonExistentPref', 'DefaultValue')
        self.assertEqual(NonExistentValue, 'DefaultValue')
    
    def test_AddRecentModel(self):
        """Test adding models to recent models list."""
        # Initially recent models should be empty
        RecentModels = self.ConfigManager.GetUserPreference('RecentModels', [])
        self.assertEqual(RecentModels, [])
        
        # Add a model
        self.ConfigManager.AddRecentModel('Model1')
        RecentModels = self.ConfigManager.GetUserPreference('RecentModels', [])
        self.assertEqual(RecentModels, ['Model1'])
        
        # Add another model
        self.ConfigManager.AddRecentModel('Model2')
        RecentModels = self.ConfigManager.GetUserPreference('RecentModels', [])
        self.assertEqual(RecentModels, ['Model2', 'Model1'])
        
        # Add the first model again (should move to front)
        self.ConfigManager.AddRecentModel('Model1')
        RecentModels = self.ConfigManager.GetUserPreference('RecentModels', [])
        self.assertEqual(RecentModels, ['Model1', 'Model2'])
        
        # Add models until we exceed the limit of 10
        for i in range(3, 12):
            self.ConfigManager.AddRecentModel(f'Model{i}')
        
        # Check that we only have 10 models and the oldest is removed
        RecentModels = self.ConfigManager.GetUserPreference('RecentModels', [])
        self.assertEqual(len(RecentModels), 10)
        self.assertEqual(RecentModels[0], 'Model11')
        self.assertNotIn('Model2', RecentModels)
    
    def test_ExportModelConfig(self):
        """Test exporting model configuration to a file."""
        # Define test model configuration
        TestModelConfig = {
            'Temperature': 0.8,
            'TopP': 0.95,
            'MaxTokens': 1500
        }
        
        # Set model configuration
        self.ConfigManager.SetModelConfig('TestModel', TestModelConfig)
        
        # Export to JSON
        JsonPath = os.path.join(self.TempDir.name, "test_export.json")
        JsonResult = self.ConfigManager.ExportModelConfig('TestModel', JsonPath)
        self.assertTrue(JsonResult, "ExportModelConfig should return True for JSON")
        self.assertTrue(os.path.exists(JsonPath), "JSON export file should exist")
        
        # Read exported JSON and verify
        with open(JsonPath, 'r') as JsonFile:
            ExportedJson = json.load(JsonFile)
        self.assertEqual(ExportedJson, TestModelConfig)
        
        # Export to YAML
        YamlPath = os.path.join(self.TempDir.name, "test_export.yaml")
        YamlResult = self.ConfigManager.ExportModelConfig('TestModel', YamlPath)
        self.assertTrue(YamlResult, "ExportModelConfig should return True for YAML")
        self.assertTrue(os.path.exists(YamlPath), "YAML export file should exist")
        
        # Read exported YAML and verify
        with open(YamlPath, 'r') as YamlFile:
            ExportedYaml = yaml.safe_load(YamlFile)
        self.assertEqual(ExportedYaml, TestModelConfig)
        
        # Test export for non-existent model
        NonExistentResult = self.ConfigManager.ExportModelConfig('NonExistentModel', JsonPath)
        self.assertFalse(NonExistentResult, "ExportModelConfig should return False for non-existent model")
        
        # Test export with unsupported format
        BadFormatPath = os.path.join(self.TempDir.name, "test_export.txt")
        BadFormatResult = self.ConfigManager.ExportModelConfig('TestModel', BadFormatPath)
        self.assertFalse(BadFormatResult, "ExportModelConfig should return False for unsupported format")
    
    def test_ValidateModelConfig(self):
        """Test validation of model configuration."""
        # Valid configuration
        ValidConfig = {
            'Temperature': 0.8,
            'TopP': 0.9,
            'MaxTokens': 2000
        }
        self.assertTrue(self.ConfigManager._ValidateModelConfig(ValidConfig))
        
        # Missing required parameter
        MissingParam = {
            'Temperature': 0.8,
            'TopP': 0.9
            # Missing MaxTokens
        }
        self.assertFalse(self.ConfigManager._ValidateModelConfig(MissingParam))
        
        # Invalid Temperature (too high)
        InvalidTemp = {
            'Temperature': 3.0,  # Should be between 0 and 2
            'TopP': 0.9,
            'MaxTokens': 2000
        }
        self.assertFalse(self.ConfigManager._ValidateModelConfig(InvalidTemp))
        
        # Invalid TopP (too high)
        InvalidTopP = {
            'Temperature': 0.8,
            'TopP': 1.5,  # Should be between 0 and 1
            'MaxTokens': 2000
        }
        self.assertFalse(self.ConfigManager._ValidateModelConfig(InvalidTopP))
        
        # Invalid MaxTokens (negative)
        InvalidTokens = {
            'Temperature': 0.8,
            'TopP': 0.9,
            'MaxTokens': -100  # Should be positive
        }
        self.assertFalse(self.ConfigManager._ValidateModelConfig(InvalidTokens))

if __name__ == '__main__':
    unittest.main()

================
File:  test_pyside.py
================
# test_pyside.py
import sys
print(f"Python version: {sys.version}")
print(f"Python path: {sys.path}")

try:
    from PySide6.QtWidgets import QApplication
    from PySide6.QtCore import QTimer
    print("Basic PySide6 imports successful")
    
    # Now try to import your custom modules
    print("Trying to import custom modules...")
    from GUI.Windows.MainWindow import MainWindow
    from GUI.Windows.SplashScreen import SplashScreen
    print("GUI modules imported successfully")
    
    from Core.LoggingUtils import SetupLogging
    from Core.ConfigManager import ConfigManager
    print("Core modules imported successfully")
    
except ImportError as e:
    print(f"Import error: {e}")

================
File: .gitignore
================
# Python
__pycache__/
*.py[cod]
*.class
*.so
.Python
.venv/
venv/
ENV/
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# IDE
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Project specific
*.log
.env

# Custom exclusions
..Exclude/
..Scripts/
..Next/
..Vision/

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Herbert J. Bowers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: Main.py
================
# File: Main.py
# Path: OllamaModelEditor/Main.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-12 05:45PM
# Description: Entry point for the OllamaModelEditor application

import sys
import logging
from pathlib import Path
import argparse

# Add project root to path
ProjectRoot = Path(__file__).resolve().parent
sys.path.append(str(ProjectRoot))

# Set up basic logging
logging.basicConfig(level=logging.INFO, 
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
Logger = logging.getLogger('OllamaModelEditor')

# Import Core components first to ensure they're available
try:
    from Core.DBManager import DBManager
    from Core.LoggingUtils import SetupLogging
    from Core.ConfigManager import ConfigManager
    Logger.info("Core imports successful")
except ImportError as e:
    Logger.error(f"Error importing Core components: {e}")
    print(f"Error importing Core components: {e}")
    print("Please make sure all required files are in place.")
    sys.exit(1)

# Import PySide6 components
try:
    from PySide6.QtWidgets import QApplication, QMainWindow, QMessageBox
    from PySide6.QtCore import QTimer
    Logger.info("PySide6 imports successful")
except ImportError as e:
    Logger.error(f"Error importing PySide6: {e}")
    print("Error: PySide6 is required but not installed.")
    print("Please install dependencies with: pip install -r requirements.txt")
    sys.exit(1)

# Import GUI components
try:
    from GUI.Windows.MainWindow import MainWindow
    from GUI.Windows.SplashScreen import SplashScreen
    Logger.info("GUI imports successful")
except ImportError as e:
    Logger.error(f"Error importing GUI components: {e}")
    print(f"Error importing GUI components: {e}")
    print("Please make sure all required files are in place.")
    sys.exit(1)

def ParseCommandLine():
    """
    Parse command line arguments.
    
    Returns:
        Namespace with parsed arguments
    """
    Parser = argparse.ArgumentParser(description="OllamaModelEditor - A tool for managing Ollama AI models")
    Parser.add_argument("--config", help="Path to configuration file")
    Parser.add_argument("--db", help="Path to database file")
    Parser.add_argument("--migrate", action="store_true", help="Migrate from file config to database")
    Parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    return Parser.parse_args()

def Main():
    """Application entry point."""
    # Parse command line arguments
    Args = ParseCommandLine()
    
    # Set log level based on arguments
    LogLevel = logging.DEBUG if Args.debug else logging.INFO
    
    Logger.info("Starting OllamaModelEditor")
    
    # Initialize database if using database storage
    DB = DBManager(Args.db) if DBManager else None
    Logger.info(f"Database initialized: {DB.DBPath if DB else 'Not using database'}")
    
    # Initialize logging
    SetupLogging(LogLevel=LogLevel)
    
    # Create application
    App = QApplication(sys.argv)
    App.setApplicationName("OllamaModelEditor")
    App.setOrganizationName("CallMeChewy")
    
    # Initialize configuration
    try:
        Config = ConfigManager(Args.config, DB)
        
        # Migrate from file to database if requested
        if Args.migrate and DB:
            Config.MigrateToDatabase(DB)
        
        Config.LoadConfig()
        Logger.info("Configuration loaded")
    except Exception as e:
        Logger.error(f"Error loading configuration: {e}")
        QMessageBox.critical(None, "Configuration Error", 
                            f"Error loading configuration: {e}")
        return 1
    
    # Create and display splash screen
    try:
        Splash = SplashScreen()
        Splash.show()
        Logger.info("Splash screen displayed")
    except Exception as e:
        Logger.error(f"Error creating splash screen: {e}")
        # Continue without splash screen
        Splash = None
    
    # Initialize main window
    try:
        MainWin = MainWindow(Config)
        Logger.info("Main window created")
        
        # Close splash and show main window after delay
        if Splash:
            QTimer.singleShot(2000, lambda: ShowMainWindow(Splash, MainWin))
        else:
            MainWin.show()
    except Exception as e:
        Logger.error(f"Error creating main window: {e}")
        QMessageBox.critical(None, "Error", 
                            f"Error creating main window: {e}")
        return 1
    
    # Start event loop
    Logger.info("Starting application event loop")
    return App.exec()

def ShowMainWindow(Splash, MainWin):
    """Close splash screen and show main window."""
    try:
        Splash.finish(MainWin)
        MainWin.show()
    except Exception as e:
        Logger.error(f"Error showing main window: {e}")
        MainWin.show()

if __name__ == "__main__":
    sys.exit(Main())

================
File: README.md
================
# OLLAMA MODEL EDITOR

**A powerful tool for customizing and optimizing Ollama AI models**

[Features](#features)  [Installation](#installation)  [Usage](#usage)  [Documentation](#documentation)  [Contributing](#contributing)  [License](#license)

## About

Ollama Model Editor is a comprehensive GUI application that allows you to customize, optimize, and manage your Ollama AI models. This tool provides an intuitive interface for adjusting model parameters, comparing performance across different configurations, and streamlining your AI workflow.

**This project is a collaboration between human developers and AI assistants, demonstrating the power of human-AI teamwork in software development.**

## Features

-  **Parameter Customization**: Fine-tune model parameters through an intuitive GUI
-  **Performance Benchmarking**: Compare different model configurations side-by-side
-  **Model Management**: Easily manage multiple Ollama models in one interface
-  **Optimization Presets**: Apply pre-configured optimization settings for specific use cases
-  **Detailed Analysis**: Get insights into how parameter changes affect model performance
-  **Theming Support**: Choose between light and dark themes for comfortable usage
-  **Configuration Export**: Share your optimized model configurations with others

## Installation

### Prerequisites

- Python 3.8 or higher
- Ollama installed and running on your system
- Git (for cloning the repository)

### Setup

Collecting PySide6>=6.5.0 (from -r requirements.txt (line 1))
  Using cached PySide6-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl.metadata (5.3 kB)
Collecting pytest>=7.3.1 (from -r requirements.txt (line 2))
  Using cached pytest-8.3.5-py3-none-any.whl.metadata (7.6 kB)
Collecting pytest-qt>=4.2.0 (from -r requirements.txt (line 3))
  Using cached pytest_qt-4.4.0-py3-none-any.whl.metadata (7.7 kB)
Collecting requests>=2.28.2 (from -r requirements.txt (line 4))
  Using cached requests-2.32.3-py3-none-any.whl.metadata (4.6 kB)
Collecting pyyaml>=6.0 (from -r requirements.txt (line 5))
  Using cached PyYAML-6.0.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.1 kB)
Collecting loguru>=0.7.0 (from -r requirements.txt (line 6))
  Using cached loguru-0.7.3-py3-none-any.whl.metadata (22 kB)
Collecting shiboken6==6.8.2.1 (from PySide6>=6.5.0->-r requirements.txt (line 1))
  Using cached shiboken6-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl.metadata (2.5 kB)
Collecting PySide6-Essentials==6.8.2.1 (from PySide6>=6.5.0->-r requirements.txt (line 1))
  Using cached PySide6_Essentials-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl.metadata (3.7 kB)
Collecting PySide6-Addons==6.8.2.1 (from PySide6>=6.5.0->-r requirements.txt (line 1))
  Using cached PySide6_Addons-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl.metadata (4.0 kB)
Collecting iniconfig (from pytest>=7.3.1->-r requirements.txt (line 2))
  Using cached iniconfig-2.0.0-py3-none-any.whl.metadata (2.6 kB)
Collecting packaging (from pytest>=7.3.1->-r requirements.txt (line 2))
  Using cached packaging-24.2-py3-none-any.whl.metadata (3.2 kB)
Collecting pluggy<2,>=1.5 (from pytest>=7.3.1->-r requirements.txt (line 2))
  Using cached pluggy-1.5.0-py3-none-any.whl.metadata (4.8 kB)
Collecting charset-normalizer<4,>=2 (from requests>=2.28.2->-r requirements.txt (line 4))
  Using cached charset_normalizer-3.4.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (35 kB)
Collecting idna<4,>=2.5 (from requests>=2.28.2->-r requirements.txt (line 4))
  Using cached idna-3.10-py3-none-any.whl.metadata (10 kB)
Collecting urllib3<3,>=1.21.1 (from requests>=2.28.2->-r requirements.txt (line 4))
  Using cached urllib3-2.3.0-py3-none-any.whl.metadata (6.5 kB)
Collecting certifi>=2017.4.17 (from requests>=2.28.2->-r requirements.txt (line 4))
  Using cached certifi-2025.1.31-py3-none-any.whl.metadata (2.5 kB)
Using cached PySide6-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl (550 kB)
Using cached PySide6_Addons-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl (160.6 MB)
Using cached PySide6_Essentials-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl (95.3 MB)
Using cached shiboken6-6.8.2.1-cp39-abi3-manylinux_2_28_x86_64.whl (204 kB)
Using cached pytest-8.3.5-py3-none-any.whl (343 kB)
Using cached pytest_qt-4.4.0-py3-none-any.whl (36 kB)
Using cached requests-2.32.3-py3-none-any.whl (64 kB)
Using cached PyYAML-6.0.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (767 kB)
Using cached loguru-0.7.3-py3-none-any.whl (61 kB)
Using cached certifi-2025.1.31-py3-none-any.whl (166 kB)
Using cached charset_normalizer-3.4.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (145 kB)
Using cached idna-3.10-py3-none-any.whl (70 kB)
Using cached pluggy-1.5.0-py3-none-any.whl (20 kB)
Using cached urllib3-2.3.0-py3-none-any.whl (128 kB)
Using cached iniconfig-2.0.0-py3-none-any.whl (5.9 kB)
Using cached packaging-24.2-py3-none-any.whl (65 kB)
Installing collected packages: urllib3, shiboken6, pyyaml, pluggy, packaging, loguru, iniconfig, idna, charset-normalizer, certifi, requests, pytest, PySide6-Essentials, pytest-qt, PySide6-Addons, PySide6
Successfully installed PySide6-6.8.2.1 PySide6-Addons-6.8.2.1 PySide6-Essentials-6.8.2.1 certifi-2025.1.31 charset-normalizer-3.4.1 idna-3.10 iniconfig-2.0.0 loguru-0.7.3 packaging-24.2 pluggy-1.5.0 pytest-8.3.5 pytest-qt-4.4.0 pyyaml-6.0.2 requests-2.32.3 shiboken6-6.8.2.1 urllib3-2.3.0

## Usage

1. Launch the application with **python Main.py**
2. Select an Ollama model from the dropdown menu
3. Adjust parameters using the intuitive interface
4. Compare performance with different settings
5. Save your optimized configuration
6. Export settings to share with the community

For more detailed instructions, see the [Quick Start Guide](docs/QuickStartGuide.md).

## Documentation

- [Quick Start Guide](docs/QuickStartGuide.md)
- [Core Components](Core/README.md)
- [Parameter Reference](docs/parameters.md)
- [Advanced Usage](docs/advanced_usage.md)

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (**git checkout -b feature/amazing-feature**)
3. Commit your changes (**git commit -m 'Add some amazing feature'**)
4. Push to the branch (**git push origin feature/amazing-feature**)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgements

- This project is a collaboration between human developers and AI assistants
- Special thanks to the Ollama project for making powerful AI models accessible
- Developed by Herbert J. Bowers (Herb@BowersWorld.com)

================
File: requirements.txt
================
PySide6>=6.5.0
pytest>=7.3.1
pytest-qt>=4.2.0
requests>=2.28.2
pyyaml>=6.0
loguru>=0.7.0

================
File: SimpleTest.py
================
# File: SimpleTest.py
# Path: OllamaModelEditor/SimpleTest.py
# Standard: AIDEV-PascalCase-1.2
# Created: 2025-03-11
# Last Modified: 2025-03-11
# Description: Simple test application to verify PySide6 is working

import sys
print(f"Python version: {sys.version}")
print(f"Python executable: {sys.executable}")

try:
    from PySide6.QtWidgets import QApplication, QWidget, QVBoxLayout, QLabel, QPushButton
    from PySide6.QtCore import Qt
    print("PySide6 imported successfully")
except ImportError as e:
    print(f"Error importing PySide6: {e}")
    sys.exit(1)

class SimpleTestWindow(QWidget):
    """Simple window to test PySide6 functionality."""
    
    def __init__(self):
        """Initialize the test window."""
        super().__init__()
        
        # Set window properties
        self.setWindowTitle("OllamaModelEditor - PySide6 Test")
        self.setGeometry(100, 100, 400, 300)
        
        # Create layout
        Layout = QVBoxLayout()
        self.setLayout(Layout)
        
        # Add widgets
        HeaderLabel = QLabel("PySide6 Test Application")
        HeaderLabel.setAlignment(Qt.AlignCenter)
        HeaderLabel.setStyleSheet("font-size: 18px; font-weight: bold; margin-bottom: 20px;")
        Layout.addWidget(HeaderLabel)
        
        SuccessLabel = QLabel("If you can see this window, PySide6 is working correctly!")
        SuccessLabel.setAlignment(Qt.AlignCenter)
        SuccessLabel.setStyleSheet("font-size: 14px; color: green;")
        Layout.addWidget(SuccessLabel)
        
        InfoLabel = QLabel(f"Python version: {sys.version}")
        InfoLabel.setAlignment(Qt.AlignCenter)
        Layout.addWidget(InfoLabel)
        
        # Add close button
        CloseButton = QPushButton("Close")
        CloseButton.clicked.connect(self.close)
        Layout.addWidget(CloseButton)

if __name__ == "__main__":
    print("Starting PySide6 test application...")
    
    # Create application
    App = QApplication(sys.argv)
    
    # Create and show window
    Window = SimpleTestWindow()
    Window.show()
    
    # Start event loop
    sys.exit(App.exec())



================================================================
End of Codebase
================================================================
